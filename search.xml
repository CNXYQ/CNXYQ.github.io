<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>更新日志</title>
    <url>/2020/03/01/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><h1 id="1-更新："><a href="#1-更新：" class="headerlink" title="1. 更新："></a>1. 更新：</h1><h2 id="2020-2-29"><a href="#2020-2-29" class="headerlink" title="2020.2.29"></a>2020.2.29</h2><ol><li><em>页面加载性能优化</em></li><li><em>图片懒加载</em></li><li><em>发布新博客</em></li><li><em>优化背景</em></li><li><em>压缩代码</em></li></ol><h2 id="2020-6-09"><a href="#2020-6-09" class="headerlink" title="2020.6.09"></a>2020.6.09</h2><ul><li>更换Butterfly主题</li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>更新日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Python bcrypy模块</title>
    <url>/2020/07/10/Python%20bcrypt%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 15:20:40 GMT+0800 (GMT+08:00) --><h1 id="Python-bcrypt模块"><a href="#Python-bcrypt模块" class="headerlink" title="Python bcrypt模块"></a>Python bcrypt模块</h1><p>bcrypt 库：对 Python 中的密码进行哈希处理。 它定义了基本术语，包括加密，哈希和盐。</p><p>Python <code>bcrypt</code>模块是一个用于在 Python 中生成强哈希值的库。 它通过<code>pip install bcrypt</code>命令安装。</p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>加密是对消息或信息进行编码的过程，以使只有授权人员才能使用相应的键读取消息或信息，而未经授权的人员则不能。 预期的信息或消息，称为纯文本，使用加密算法-密码-加密，生成密文，只有解密后才能读取。 加密是一种双向功能。 当我们加密某些东西时，我们这样做是为了以后对其进行解密。 加密用于传输时保护数据； 例如 在邮件通讯中。</p><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>哈希是使用算法将任意大小的数据映射到固定长度的过程。 这称为哈希值。 加密是一种双向功能，而散列是一种单向功能。 尽管在技术上可以反向散列值，但所需的计算能力使其不可行。 加密是为了保护传输中的数据，而散列是为了验证数据没有被更改并且是真实的。</p><blockquote><p><strong>注意:</strong> 哈希不限于安全性，它还用于比较大量数据或快速键查找。</p></blockquote><p>密码不是以纯文本格式存储在数据库中，而是以散列值存储。</p><h2 id="盐"><a href="#盐" class="headerlink" title="盐"></a>盐</h2><p>盐是固定长度的加密强度强的随机值，将其添加到哈希函数的输入中以为每个输入创建唯一的哈希。 添加盐可以使密码哈希输出唯一，即使对于采用通用密码的用户也是如此。</p><h2 id="bcrypt-哈希函数"><a href="#bcrypt-哈希函数" class="headerlink" title="bcrypt 哈希函数"></a>bcrypt 哈希函数</h2><p>bcrypt 是 Niels Provos 和 DavidMazières 基于 Blowfish 密码设计的密码哈希功能。 bcrypt 函数是 OpenBSD 的默认密码哈希算法。 有针对 C，C++ ，C# ，Java，JavaScript，PHP，Python 和其他语言的 bcrypt 实现。</p><p>bcrypt 算法使用强大的加密技术为我们创建哈希并加盐。 该算法的计算成本是参数化的，因此随着计算机变得越来越快，它可能会增加。 计算成本被称为工作因子或成本因子。 它减慢了散列的速度，使暴力破解的尝试越来越难。 随着计算机变得越来越快，最佳成本因数会随着时间而变化。 高成本因素的缺点是增加了系统资源的负载并影响了用户体验。</p><h2 id="Python-bcrypt-创建哈希密码"><a href="#Python-bcrypt-创建哈希密码" class="headerlink" title="Python bcrypt 创建哈希密码"></a>Python bcrypt 创建哈希密码</h2><p>在下一个示例中，我们创建一个哈希密码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create_hashed_password.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">b's$cret12'</span></span><br><span class="line"></span><br><span class="line">salt = bcrypt.gensalt()</span><br><span class="line">hashed = bcrypt.hashpw(passwd, salt)</span><br><span class="line"></span><br><span class="line">print(salt)</span><br><span class="line">print(hashed)</span><br></pre></td></tr></table></figure><p>该示例使用 bcrypt 创建一个 salt 和一个哈希密码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bcrypt</span><br></pre></td></tr></table></figure><p>我们导入<code>bcrypt</code>模块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">salt = bcrypt.gensalt()</span><br></pre></td></tr></table></figure><p>用<code>gensalt()</code>功能生成盐。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hashed = bcrypt.hashpw(passwd, salt)</span><br></pre></td></tr></table></figure><p>使用<code>hashpw()</code>函数创建一个哈希值，该函数将明文值和盐作为参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python first.py</span><br><span class="line"><span class="string">b'$2b$12$mwSIOyxLJid1jFLgnU0s0.'</span></span><br><span class="line"><span class="string">b'$2b$12$mwSIOyxLJid1jFLgnU0s0.7pmzp8Mtx.GEO30x0AbI2v8r2sb98Cy'</span></span><br><span class="line">$ python first.py</span><br><span class="line"><span class="string">b'$2b$12$MgGs11HIXGkg1Bm1Epw0Du'</span></span><br><span class="line"><span class="string">b'$2b$12$MgGs11HIXGkg1Bm1Epw0Du20TV8ppi2Latgq7kKng8UjM5ZFWKKeS'</span></span><br></pre></td></tr></table></figure><p>请注意，盐是生成的哈希值的第一部分。 还要注意，每次生成唯一的 salt 和哈希值。</p><h2 id="Python-bcrypt-检查密码"><a href="#Python-bcrypt-检查密码" class="headerlink" title="Python bcrypt 检查密码"></a>Python bcrypt 检查密码</h2><p>下面的示例根据哈希值检查密码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">check_passwd.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">b's$cret12'</span></span><br><span class="line"></span><br><span class="line">salt = bcrypt.gensalt()</span><br><span class="line">hashed = bcrypt.hashpw(passwd, salt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bcrypt.checkpw(passwd, hashed):</span><br><span class="line">    print(<span class="string">"match"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"does not match"</span>)</span><br></pre></td></tr></table></figure><p>使用<code>checkpw()</code>功能检查密码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python check_passwd.py</span><br><span class="line">match</span><br></pre></td></tr></table></figure><h2 id="Python-bcrypt-成本因子"><a href="#Python-bcrypt-成本因子" class="headerlink" title="Python bcrypt 成本因子"></a>Python bcrypt 成本因子</h2><p>成本因子通过减慢散列来提高安全性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cost_factor.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">b's$cret12'</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">salt = bcrypt.gensalt(rounds=<span class="number">16</span>)</span><br><span class="line">hashed = bcrypt.hashpw(passwd, salt)</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">print(end - start)</span><br><span class="line"></span><br><span class="line">print(hashed)</span><br></pre></td></tr></table></figure><p>我们使用<code>rounds</code>参数将成本因子设置为 16。 我们测量生成 passowrd 哈希的时间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ cost_factor.py</span><br><span class="line"><span class="number">4.268407821655273</span></span><br><span class="line"><span class="string">b'$2b$16$.1FczuSNl2iXHmLojhwBZO9vCfA5HIqrONkefhvn2qLQpth3r7Jwe'</span></span><br></pre></td></tr></table></figure><p>花费超过四秒钟的时间来生成具有指定成本因子的哈希值。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python 模块</category>
        <category>加密</category>
      </categories>
      <tags>
        <tag>bcrypt</tag>
        <tag>加密</tag>
        <tag>python模块</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器和HyperLogLog</title>
    <url>/2020/07/01/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8CHyperLogLog/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 15:20:40 GMT+0800 (GMT+08:00) --><h1 id="python-布隆过滤器"><a href="#python-布隆过滤器" class="headerlink" title="python-布隆过滤器"></a>python-布隆过滤器</h1><p>在学习<code>redis</code>过程中提到一个缓存穿透的问题， 书中参考的解决方案之一是使用布隆过滤器， 那么就有必要来了解一下什么是布隆过滤器。在参考了许多博客之后， 写个总结记录一下。</p><h2 id="一、布隆过滤器简介"><a href="#一、布隆过滤器简介" class="headerlink" title="一、布隆过滤器简介"></a>一、布隆过滤器简介</h2><h3 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h3><p>本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>布隆过滤器内部维护一个<code>bitArray</code>(位数组)， 开始所有数据全部置 0 。当一个元素过来时，能过多个哈希函数（hash1,hash2,hash3….）计算不同的在哈希值，并通过哈希值找到对应的<code>bitArray</code>下标处，将里面的值 0 置为 1 。 需要说明的是，布隆过滤器有一个误判率的概念，误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间越小。</p><p>下面以网址为例来进行说明, 例如布隆过滤器的初始情况如下图所示：<br><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205013684-856617678.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205013684-856617678.jpg" alt="img"></a></p><p>现在我们需要往布隆过滤里中插入<code>baidu</code>这个url，经过3个哈希函数的计算，hash值分别为1，4，7，那么我们就需要对布隆过滤器的对应的bit位置1， 就如图下所示：</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205051490-438287903.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205051490-438287903.jpg" alt="img"></a></p><p>接下来，需要继续往布隆过滤器中添加<code>tencent</code>这个url，然后它计算出来的hash值分别3，4，8，继续往对应的bit位置1。这里就需要注意一个点， 上面两个url最后计算出来的hash值都有4，这个现象也是布隆不能确认某个元素一定存在的原因，最后如下图所示：</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205113779-698386268.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205113779-698386268.jpg" alt="img"></a></p><p>布隆过滤器的查询也很简单，例如我们需要查找<code>python</code>，只需要计算出它的hash值， 如果该值为2，4，7，那么因为对应bit位上的数据有一个不为1， 那么一定可以断言<code>python</code>不存在，但是如果它计算的hash值是1，3，7，那么就只能判断出<code>python</code>可能存在，这个例子就可以看出来， 我们没有存入<code>python</code>，但是由于其他key存储的时候返回的hash值正好将<code>python</code>计算出来的hash值对应的bit位占用了，这样就不能准确地判断出<code>python</code>是否存在。</p><p>因此， 随着添加的值越来越多， 被占的bit位越来越多， 这时候误判的可能性就开始变高，如果布隆过滤器所有bit位都被置为1的话，那么所有key都有可能存在， 这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。</p><p>从上面布隆过滤器的实现原理可以看出，它不支持删除， 一旦将某个key对应的bit位置0，可能会导致同样bit位的其他key的存在性判断错误。</p><h3 id="布隆过滤器的准确性"><a href="#布隆过滤器的准确性" class="headerlink" title="布隆过滤器的准确性"></a>布隆过滤器的准确性</h3><p>布隆过滤器的核心思想有两点：</p><ol><li>多个hash，增大随机性，减少hash碰撞的概率</li><li>扩大数组范围，使hash值均匀分布，进一步减少hash碰撞的概率。</li></ol><p>虽然布隆过滤器已经尽可能的减小hash碰撞的概率了，但是，并不能彻底消除，因此正如上面的小例子所举的小例子的结果来看， 布隆过滤器只能告诉我们<strong>某样东西一定不存在以及它可能存在</strong>。</p><p>关于布隆过滤器的数组大小以及相应的hash函数个数的选择， 可以参考网上的其他博客或者是这个维基百科上对应词条上的结果: <a href="http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives" target="_blank" rel="noopener">Probability of false positives</a> .</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205508471-460587233.png" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205508471-460587233.png" alt="1024px-Bloom_filter_fp_probability.svg"></a></p><p>上图的纵坐标p是误判率，横坐标n表示插入的元素个数，m表示布隆过滤器的bit长度，当然上图结果成立都假设hash函数的个数k满足条件<code>k = (m/n)ln2</code>(忽略k是整数)。</p><p>从上面的结果来看， 选择合适后误判率还是比较低的。</p><h3 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h3><ol><li>网页爬虫对URL的去重，避免爬取相同的URL地址</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li><li>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</li><li>黑名单过滤，</li></ol><h2 id="二、python中使用布隆过滤器"><a href="#二、python中使用布隆过滤器" class="headerlink" title="二、python中使用布隆过滤器"></a>二、python中使用布隆过滤器</h2><ol><li><p>先去这个网站下载<code>bitarray</code>这个依赖 <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/#bitarray</code></p><p>直接安装会报错<code>error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Build Tools for Visual Studio&quot;: https://visualstudio.microsoft.com/downloads/</code></p></li><li><p>安装<code>wheel</code>文件, 防止我们主动安装报这样的错误<code>pip3 install bitarray-1.1.0-cp36-cp36m-win_amd64.whl</code></p></li></ol><p>注: 如果不知道怎么确定版本可以查看这个链接 <a href="https://blog.csdn.net/happywlg123/article/details/107281936" target="_blank" rel="noopener">https://blog.csdn.net/happywlg123/article/details/107281936</a></p><ol start="3"><li><code>pip3 install pybloom_live</code></li></ol><p>使用案例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copyfrom pybloom_live <span class="keyword">import</span> ScalableBloomFilter, BloomFilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可自动扩容的布隆过滤器</span></span><br><span class="line">bloom = ScalableBloomFilter(initial_capacity=<span class="number">100</span>, error_rate=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">url1 = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">url2 = <span class="string">'http://qq.com'</span></span><br><span class="line"></span><br><span class="line">bloom.add(url1)</span><br><span class="line">print(url1 <span class="keyword">in</span> bloom)</span><br><span class="line">print(url2 <span class="keyword">in</span> bloom)</span><br><span class="line">Copy<span class="comment"># BloomFilter 是定长的</span></span><br><span class="line"><span class="keyword">from</span> pybloom_live <span class="keyword">import</span> BloomFilter</span><br><span class="line"></span><br><span class="line">url1 = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">url2 = <span class="string">'http://qq.com'</span></span><br><span class="line"></span><br><span class="line">bf = BloomFilter(capacity=<span class="number">1000</span>)</span><br><span class="line">bf.add(url1)</span><br><span class="line">print(url1 <span class="keyword">in</span> bf)</span><br><span class="line">print(url2 <span class="keyword">in</span> bf)</span><br></pre></td></tr></table></figure><h2 id="三、redis中使用布隆过滤器"><a href="#三、redis中使用布隆过滤器" class="headerlink" title="三、redis中使用布隆过滤器"></a>三、redis中使用布隆过滤器</h2><p>详细的文档可以参考<a href="https://oss.redislabs.com/redisbloom/Quick_Start/" target="_blank" rel="noopener">官方文档</a>。</p><p>这个模块不仅仅实现了布隆过滤器，还实现了 <code>CuckooFilter</code>（布谷鸟过滤器），以及 <code>TopK</code>功能。<code>CuckooFilter</code>是在 <code>BloomFilter</code>的基础上主要解决了<code>BloomFilter</code>不能删除的缺点。 下面只说明了布隆过滤器</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>传统的<code>redis</code>服务器安装 <code>RedisBloom</code> 插件，详情可以参考<a href="https://blog.csdn.net/u013030276/article/details/88350641" target="_blank" rel="noopener">centos中安装redis插件bloom-filter</a></p><p>我这里使用docker进行安装，简单快捷。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copydocker pull redislabs/rebloom:latest</span><br><span class="line">docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span><br><span class="line">docker <span class="built_in">exec</span> -it redis-redisbloom /bin/bash</span><br></pre></td></tr></table></figure><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>命令使用非常简单。</p><h4 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h4><blockquote><p>bf.reserve {key} {error_rate} {size}</p></blockquote><p>创建一个空的名为<code>key</code>的布隆过滤器，并设置一个期望的错误率和初始大小。<code>{error_rate}</code>过滤器的错误率在0-1之间，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copy127.0.0.1:6379&gt; bf.reserve black_male 0.001 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="add-madd"><a href="#add-madd" class="headerlink" title="add, madd"></a>add, madd</h4><blockquote><p>bf.add {key} {item}</p><p>bf.madd {key} {item} [item…]</p></blockquote><p>往过滤器中添加元素。如果key不存在，过滤器会自动创建。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copy127.0.0.1:6379&gt; bf.add <span class="built_in">test</span> 123</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.madd urls baidu google tencent</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面已经存在的值再次添加会返回0， 不存在则返回1</span></span><br></pre></td></tr></table></figure><h4 id="exists-mexists"><a href="#exists-mexists" class="headerlink" title="exists, mexists"></a>exists, mexists</h4><blockquote><p>bf.exists {key} {item}</p><p>bf.mexists {key} {item} [item…]</p></blockquote><p>判断过滤器中是否存在该元素，不存在返回0，存在返回1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copy127.0.0.1:6379&gt; bf.exists <span class="built_in">test</span> 123</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.mexists urls baidu google hello</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h2 id="四、python程序中使用redisbloom"><a href="#四、python程序中使用redisbloom" class="headerlink" title="四、python程序中使用redisbloom"></a>四、python程序中使用redisbloom</h2><p>使用<code>redisbloom</code>这个模块来操作<code>redis</code>的布隆过滤器插件</p><blockquote><p>pip3 install redisbloom</p></blockquote><p>使用方法，参考官方给出的例子即可。<a href="https://github.com/RedisBloom/redisbloom-py" target="_blank" rel="noopener">https://github.com/RedisBloom/redisbloom-py</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copy<span class="comment"># 自己的简单使用</span></span><br><span class="line"><span class="keyword">from</span> redisbloom.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为我使用的是虚拟机中docker的redis, 填写虚拟机的ip地址和暴露的端口</span></span><br><span class="line">rb = Client(host=<span class="string">'192.168.12.78'</span>, port=<span class="number">6379</span>)</span><br><span class="line">rb.bfAdd(<span class="string">'urls'</span>, <span class="string">'baidu'</span>)</span><br><span class="line">rb.bfAdd(<span class="string">'urls'</span>, <span class="string">'google'</span>)</span><br><span class="line">print(rb.bfExists(<span class="string">'urls'</span>, <span class="string">'baidu'</span>))  <span class="comment"># out: 1</span></span><br><span class="line">print(rb.bfExists(<span class="string">'urls'</span>, <span class="string">'tencent'</span>))  <span class="comment"># out: 0</span></span><br><span class="line"></span><br><span class="line">rb.bfMAdd(<span class="string">'urls'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">print(rb.bfMExists(<span class="string">'urls'</span>, <span class="string">'google'</span>, <span class="string">'baidu'</span>, <span class="string">'tencent'</span>))  <span class="comment"># out: [1, 1, 0]</span></span><br></pre></td></tr></table></figure><p><strong>误判率的测试demo</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copy<span class="string">"""</span></span><br><span class="line"><span class="string">基于redis布隆过滤器的误判率的测试</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> redisbloom.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">rb = Client(host=<span class="string">'192.168.12.78'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(size, key=<span class="string">'book'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""插入数据"""</span></span><br><span class="line">    <span class="comment"># 一条条插入速度太慢了</span></span><br><span class="line">    <span class="comment"># for i in range(size):</span></span><br><span class="line">    <span class="comment">#     rb.bfAdd(key, f'book&#123;i&#125;')</span></span><br><span class="line">    s = time.time()</span><br><span class="line">    step = <span class="number">1000</span>  <span class="comment"># 每次插入1000条数据</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">0</span>, size, step):</span><br><span class="line">        stop = start + step</span><br><span class="line">        <span class="keyword">if</span> stop &gt;= size:</span><br><span class="line">            stop = size</span><br><span class="line">        rb.bfMAdd(key, *range(start, stop))</span><br><span class="line">    print(<span class="string">'插入结束... 花费时间: &#123;:.4f&#125;s'</span>.format(time.time() - s))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(size, key=<span class="string">'book'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""查询数据"""</span></span><br><span class="line">    <span class="comment"># 统计误判个数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    s = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单条查询速度太慢了。。。</span></span><br><span class="line">    <span class="comment"># for i in range(size, size * 2):</span></span><br><span class="line">    <span class="comment">#     count += rb.bfExists(key, i)</span></span><br><span class="line"></span><br><span class="line">    step = <span class="number">1000</span>  <span class="comment"># 每次查1000条数据</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(size, size * <span class="number">2</span>, step):</span><br><span class="line">        stop = start + step</span><br><span class="line">        <span class="keyword">if</span> stop &gt;= size * <span class="number">2</span>:</span><br><span class="line">            stop = size * <span class="number">2</span></span><br><span class="line">        count += rb.bfMExists(key, *range(start, stop)).count(<span class="number">1</span>)  <span class="comment"># 返回值[1, 0, 1, ...]统计1的个数</span></span><br><span class="line">    print(<span class="string">'size: &#123;&#125;, 误判元素个数: &#123;&#125;, 误判率&#123;:.4%&#125;'</span>.format(size, count, count / size))</span><br><span class="line">    print(<span class="string">'查询结束... 花费时间: &#123;:.4f&#125;s'</span>.format(time.time() - s))</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test1</span><span class="params">(size, key=<span class="string">'book'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""测试size个不存在的"""</span></span><br><span class="line">    rb.delete(key)  <span class="comment"># 先清空原来的key</span></span><br><span class="line">    insert(size, key)</span><br><span class="line">    select(size, key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test2</span><span class="params">(size, error=<span class="number">0.001</span>, key=<span class="string">'book'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""指定误差率和初始大小的布隆过滤器"""</span></span><br><span class="line">    rb.delete(key)</span><br><span class="line"></span><br><span class="line">    rb.bfCreate(key, error, size)  <span class="comment"># 误差率为0.1%， 初始个数为size</span></span><br><span class="line"></span><br><span class="line">    insert(size, key)</span><br><span class="line">    select(size, key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># The default error rate is 0.01 and the default initial capacity is 100.</span></span><br><span class="line">    <span class="comment"># 这个是默认的配置， 初始大小为100， 误差率默认为0.01</span></span><br><span class="line">    _test1(<span class="number">1000</span>)</span><br><span class="line">    _test1(<span class="number">10000</span>)</span><br><span class="line">    _test1(<span class="number">100000</span>)</span><br><span class="line">    _test2(<span class="number">500000</span>)</span><br><span class="line">Copy<span class="comment"># 输出的结果</span></span><br><span class="line"></span><br><span class="line">插入结束... 花费时间: <span class="number">0.0409</span>s</span><br><span class="line">size: <span class="number">1000</span>, 误判元素个数: <span class="number">14</span>, 误判率<span class="number">1.4000</span>%</span><br><span class="line">查询结束... 花费时间: <span class="number">0.0060</span>s</span><br><span class="line">******************************</span><br><span class="line">插入结束... 花费时间: <span class="number">0.1389</span>s</span><br><span class="line">size: <span class="number">10000</span>, 误判元素个数: <span class="number">110</span>, 误判率<span class="number">1.1000</span>%</span><br><span class="line">查询结束... 花费时间: <span class="number">0.0628</span>s</span><br><span class="line">******************************</span><br><span class="line">插入结束... 花费时间: <span class="number">0.5372</span>s</span><br><span class="line">size: <span class="number">100000</span>, 误判元素个数: <span class="number">1419</span>, 误判率<span class="number">1.4190</span>%</span><br><span class="line">查询结束... 花费时间: <span class="number">0.4318</span>s</span><br><span class="line">******************************</span><br><span class="line">插入结束... 花费时间: <span class="number">1.9484</span>s</span><br><span class="line">size: <span class="number">500000</span>, 误判元素个数: <span class="number">152</span>, 误判率<span class="number">0.0304</span>%</span><br><span class="line">查询结束... 花费时间: <span class="number">2.2177</span>s</span><br><span class="line">******************************</span><br></pre></td></tr></table></figure><p>如果想要布隆过滤器知道具体的耗费内存大小以及对应的错误率的信息， 可以使用查看这个<a href="https://krisives.github.io/bloom-calculator/" target="_blank" rel="noopener">布隆过滤器计算器</a>计算出最后的结果。就如下面所示， 1kw数据， 误差为0.01%， 只需要23M内存。</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205337366-2116880413.png" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205337366-2116880413.png" alt="img"></a></p><h2 id="五、缓存穿透"><a href="#五、缓存穿透" class="headerlink" title="五、缓存穿透"></a>五、缓存穿透</h2><p>现在又回到开头的问题， 解决缓存穿透的问题。</p><p><strong>什么是缓存穿透</strong></p><p>我们通常使用<code>redis</code>作为数据缓存，当请求进来时先通过<code>key</code>去<code>redis</code>缓存查询，如果缓存中数据不存在，需要去查询数据库的数据。当数据库和缓存中都不存在的数据来查询时候，请求都打在数据库的请求中。如果这种请求量很大，会给数据库造成更大的压力进而影响系统的性能。</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205359267-68051944.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205359267-68051944.jpg" alt="img"></a></p><p><strong>解决这类问题的方法</strong></p><blockquote><p>方法一:当DB和redis中都不存在<code>key</code>，在DB返回<code>null</code>时，在redis中插入``当<code>key</code>再次请求时,redis直接返回<code>null</code>，而不用再次请求DB。</p></blockquote><blockquote><p>方法二:使用redis提供的<code>redisbloom</code>，同样是将存在的key放入到过滤器中。当请求进来时，先去过滤器中校验是否存在，如果不存在直接返回<code>null</code>。</p></blockquote><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205415414-1027574260.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205415414-1027574260.jpg" alt="img"></a><br><strong>黑名单的小例子</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copyimport redis</span><br><span class="line"><span class="keyword">from</span> redisbloom.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个连接池来进行使用</span></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'192.168.12.78'</span>, port=<span class="number">6379</span>, max_connections=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_key</span><span class="params">(key, error, capacity)</span>:</span></span><br><span class="line">    rb = Client(connection_pool=pool)</span><br><span class="line">    rb.bfCreate(key, errorRate=error, capacity=capacity)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_item</span><span class="params">(key, item)</span>:</span></span><br><span class="line">    <span class="string">"""判断是否存在"""</span></span><br><span class="line">    rb = Client(connection_pool=pool)</span><br><span class="line">    <span class="keyword">return</span> rb.bfExists(key, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(key, item)</span>:</span></span><br><span class="line">    <span class="string">"""添加值"""</span></span><br><span class="line">    rb = Client(connection_pool=pool)</span><br><span class="line">    <span class="keyword">return</span> rb.bfAdd(key, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 添加黑名单, 误差为0.001， 大小为1000</span></span><br><span class="line">    create_key(<span class="string">'blacklist'</span>, <span class="number">0.001</span>, <span class="number">1000</span>)</span><br><span class="line">    add_item(<span class="string">'blacklist'</span>, <span class="string">'user:1'</span>)</span><br><span class="line">    add_item(<span class="string">'blacklist'</span>, <span class="string">'user:2'</span>)</span><br><span class="line">    add_item(<span class="string">'blacklist'</span>, <span class="string">'user:3'</span>)</span><br><span class="line">    add_item(<span class="string">'blacklist'</span>, <span class="string">'user:4'</span>)</span><br><span class="line">    print(<span class="string">'user:1是否在黑名单-&gt; '</span>, get_item(<span class="string">'blacklist'</span>, <span class="string">'user:1'</span>))</span><br><span class="line">    print(<span class="string">'user:2是否在黑名单-&gt; '</span>, get_item(<span class="string">'blacklist'</span>, <span class="string">'user:2'</span>))</span><br><span class="line">    print(<span class="string">'user:6是否在黑名单-&gt; '</span>, get_item(<span class="string">'blacklist'</span>, <span class="string">'user:6'</span>))</span><br></pre></td></tr></table></figure><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>​ HyperLogLog是一种类似于布隆过滤器的算法。如果Google要计算用户执行的不同搜索的数量，或者Amazon要计算当天用户浏览的不同商品的数量，要回答这些问题，需要耗用大量的空间！对Google来说，必须有一个日志，其中包含用户执行的不同搜索。有用户执行搜索时，Google必须判断该搜索是否包含在日志中：如果答案是否定的，就必须将其加入到日志中。即便只记录一天的搜索，这种日志也大得不得了！<br>​ HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。<br>​ 面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>布隆过滤器</category>
        <category>python</category>
        <category>HyperLogLog</category>
        <category>搜索算法</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
        <tag>搜索算法</tag>
        <tag>HyperLogLog</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用教程</title>
    <url>/2020/06/18/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 15:09:17 GMT+0800 (GMT+08:00) --><h1 id="Git使用教程"><a href="#Git使用教程" class="headerlink" title="Git使用教程"></a>Git使用教程</h1><p>转载自: <a href="https://www.cnblogs.com/tugenhua0707/p/4050072.html" target="_blank" rel="noopener">git使用教程</a></p><h2 id="一：Git是什么？"><a href="#一：Git是什么？" class="headerlink" title="一：Git是什么？"></a><strong>一：Git是什么？</strong></h2><p>​ Git是目前世界上最先进的分布式版本控制系统。</p><p>​ 工作原理 / 流程：</p><p><img src="https://img.vim-cn.com/55/8c5b3217f5613b3d6fbb7b27aaf2e68427fde9.png" alt="git-1"></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="二：SVN与Git的最主要的区别？"><a href="#二：SVN与Git的最主要的区别？" class="headerlink" title="二：SVN与Git的最主要的区别？"></a><strong>二：SVN与Git的最主要的区别？</strong></h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h2 id="三：在windows上如何安装Git？"><a href="#三：在windows上如何安装Git？" class="headerlink" title="三：在windows上如何安装Git？"></a><strong>三：在windows上如何安装Git？</strong></h2><p>msysgit是 windows版的Git,如下：</p><p><img src="https://img.vim-cn.com/4f/7898dd99592a556b30f854e1d0d9e6227f50f1.jpg" alt="git-2"></p><p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下：</p><p><img src="https://img.vim-cn.com/19/37fe2646eedd98ef8b90da05f999e167caf4fc.jpg" alt="git-3"></p><p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：</p><p><img src="https://img.vim-cn.com/7b/4617c7c85dd552e3059b23b1bb132ebe4faf1b.jpg" alt="git-4"></p><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><p><img src="https://img.vim-cn.com/6a/882bdd3fcab7d2deaed09ff6bb94b546327627.jpg" alt="git-5"></p><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p><strong>注意：</strong>git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><h2 id="四：如何操作？"><a href="#四：如何操作？" class="headerlink" title="四：如何操作？"></a><strong>四：如何操作？</strong></h2><h3 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1. 创建版本库"></a>1. 创建版本库</h3><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><p>​ <img src="https://img.vim-cn.com/d3/b456182de26a6934cf8e3a0950f67ca630c23a.png" alt="git-6"></p><p>pwd 命令是用于显示当前的目录。</p><ol><li><p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><p>​ <img src="https://img.vim-cn.com/a1/7a4855e0bb8174d4a0aa404da893d1f9e78761.png" alt="git-7"></p><p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><p><img src="https://img.vim-cn.com/4f/a82ff42262a9c70a001ff92f01c8daef0e6081.png" alt="git-8"></p></li><li><p>把文件添加到版本库中。</p></li></ol><p>​ 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p><strong>下面先看下**</strong>demo<strong>**如下演示：</strong></p><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p>第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p><p>​ <img src="https://img.vim-cn.com/20/87cbae36cf3866ecc3259fd724ffc02f469d14.png" alt="git-9"></p><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p><p>第二步：用命令 git commit告诉Git，把文件提交到仓库。</p><p>​ <img src="https://img.vim-cn.com/23/fccc06cddc7e1e92caa1f14ac436de8e6c0195.png" alt="git-10"></p><p>现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p><p>​ <img src="https://img.vim-cn.com/d9/bab4ed448c85a0ebb239d00abeaa3d21d1a4b1.png" alt="git-11"></p><p>说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p><p>​ <img src="https://img.vim-cn.com/68/1a092ee19e672fa8f8e0003498d431b8e75470.png" alt="git-12"></p><p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：</p><p>git diff readme.txt 如下：</p><p>​ <img src="https://img.vim-cn.com/bb/ae4dbe881e3a072b77cc551459d4b3afe7b3f7.png" alt="git-13"></p><p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。</p><p>如下：</p><p><img src="https://img.vim-cn.com/7f/f6e7ad64f559c01c2e524130b0a8f80d88a66c.png" alt="git-14"></p><h3 id="2-版本回退："><a href="#2-版本回退：" class="headerlink" title="2. 版本回退："></a>2. 版本回退：</h3><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行</p><p>内容为33333333333333.继续执行命令如下：</p><p>​ <img src="https://img.vim-cn.com/bb/6fc932e36136c2b4708872b06958baf4f0583c.png" alt="git-15"></p><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p><p>​ <img src="https://img.vim-cn.com/5e/e4b4dddaf465d42a3247d322ba44ff1ad14de8.png" alt="git-16"></p><p>git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p><p>​ <img src="https://img.vim-cn.com/e8/47ceb37bb9125f969bb207a82e29ffb55c0e10.png" alt="git-17"></p><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p><p>​ <img src="https://img.vim-cn.com/5d/e6cf37d88899c789fd354c74896f6b0b16ed2d.png" alt="git-18"></p><p>如果想回退到上一个版本的命令如下操作：</p><p><img src="https://img.vim-cn.com/a8/9be2854e4470497ac60f096ecd60ff41488462.png" alt="git-19"></p><p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p><p><img src="https://img.vim-cn.com/75/5ead06cf8071a9b586f77d5a3877cd77487702.png" alt="git-20"></p><p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p><p><img src="https://img.vim-cn.com/31/438003880618107dbac6c103cbd1bd00997c5b.png" alt="git-21"></p><p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p><p>git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p><p><img src="https://img.vim-cn.com/f3/ea50f5869683cb9a7206401bac73d8e5ae6476.png" alt="git-22"></p><p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令</p><p>git reset –hard 6fcfc89来恢复了。演示如下：</p><p><img src="https://img.vim-cn.com/f1/17ebd76bf8065c2469c29a294d7838a38ea104.png" alt="git-23"></p><p>可以看到 目前已经是最新的版本了。</p><h3 id="3-理解工作区与暂存区的区别？"><a href="#3-理解工作区与暂存区的区别？" class="headerlink" title="3. 理解工作区与暂存区的区别？"></a>3. 理解工作区与暂存区的区别？</h3><p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</p><p><strong>版本库**</strong>(Repository)<strong>**：</strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p><p>我们前面说过使用Git提交文件到版本库有两步：</p><p>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p><p>第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p><p>我们继续使用demo来演示下：</p><p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p><p><img src="https://img.vim-cn.com/bd/f9df3cbf8162cbf7f79faecf7b3f8c371c67a9.png" alt="git-24"></p><p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p><p><img src="https://img.vim-cn.com/38/b414c940aae8db0cd3c0645c7764c678cd8cbc.png" alt="git-25"></p><p>接着我们可以使用git commit一次性提交到分支上，如下：</p><p><img src="https://img.vim-cn.com/a7/e0c1e6172d1f3f1666722cbce4405dc75f6c93.png" alt="git-26"></p><h3 id="4-Git撤销修改和删除文件操作。"><a href="#4-Git撤销修改和删除文件操作。" class="headerlink" title="4. Git撤销修改和删除文件操作。"></a>4. Git撤销修改和删除文件操作。</h3><h4 id="1-撤销修改："><a href="#1-撤销修改：" class="headerlink" title="1. 撤销修改："></a><strong>1. 撤销修改：</strong></h4><p>比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p><p><img src="https://img.vim-cn.com/57/c5600e1d75a21c66cbcad0e502373aaf8744a7.png" alt="git-27"></p><p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p><p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</p><p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^</p><p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p><p><img src="https://img.vim-cn.com/fc/2f07314d2e577d72daf340f82e734ca434ad54.png" alt="git-28"></p><p>可以发现，Git会告诉你，git checkout – file 可以丢弃工作区的修改，如下命令：</p><p>git checkout – readme.txt,如下所示：</p><p><img src="https://img.vim-cn.com/8f/b19b7f59f38a5e86b5f02c10d25ee13cfc49ca.png" alt="git-29"></p><p>命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p><ol><li>readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li><li>另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ol><p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><p>​ <img src="https://img.vim-cn.com/01/c8f55ed637c5d4134fd2a8c7f964ba03806b79.png" alt="git-30"></p><p><strong>注意：</strong>命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</p><h4 id="2-删除文件。"><a href="#2-删除文件。" class="headerlink" title="2. 删除文件。"></a><strong>2. 删除文件。</strong></h4><p>假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p><p>​ <img src="https://img.vim-cn.com/9c/309fce9f96a1923394b0789d3b32ff24007dfa.png" alt="git-31"></p><p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p><p>​ <img src="https://img.vim-cn.com/78/a4f0ce205fb1d206f78d6f93e40b5167d547a6.png" alt="git-32"></p><p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？</p><p>可以使用如下命令 git checkout – b.txt，如下所示：</p><p><img src="https://img.vim-cn.com/f2/06e342452030025b055f7cc0bb4cf3c7f01287.png" alt="git-33"></p><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><p><img src="https://img.vim-cn.com/a8/d864bd4b128f41b80b1186b6038282d3204b4c.png" alt="git-34"></p><h2 id="五：远程仓库。"><a href="#五：远程仓库。" class="headerlink" title="五：远程仓库。"></a>五：远程仓库。</h2><p>在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><p>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><p>ssh-keygen -t rsa –C “<a href="mailto:youremail@example.com">youremail@example.com</a>”, 由于我本地此前运行过一次，所以本地有，如下所示：</p><p><img src="https://img.vim-cn.com/95/648955904337a03588811633dcf1cf08e750aa.png" alt="git-35"></p><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p><p><img src="https://img.vim-cn.com/38/c1b1d1805e13f95503f3878736e0af6aa1863f.png" alt="git-36"></p><p>点击 Add Key，你就应该可以看到已经添加的key。</p><p><img src="https://img.vim-cn.com/7f/1428728699fa8397e71115eb8e8e682c9a7d5f.png" alt="git-37"></p><ol><li>如何添加远程库？</li></ol><p>​ 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p><p>首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><p><img src="https://img.vim-cn.com/87/2c9573020e7e29c604e780055e2f0008e9fb17.png" alt="git-38"></p><p>在Repository name填入<code>testgit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://img.vim-cn.com/1c/35e892f664f41c4ab632f4ceb02dbfdda6088d.png" alt="git-39"></p><p>目前，在GitHub上的这个<code>testgit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>testgit</code>仓库下运行命令：</p><p>git remote add origin <a href="https://github.com/tugenhua0707/testgit.git" target="_blank" rel="noopener">https://github.com/tugenhua0707/testgit.git</a></p><p>所有的如下：</p><p><img src="https://img.vim-cn.com/75/8b7a5c33f9f3234bc99f1a62bae4cc78c7bae6.png" alt="git-40"></p><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p><p><img src="https://img.vim-cn.com/8d/2fbafbafe3149690414b29b9c9c2c6c0eccf2c.png" alt="git-41"></p><p>从现在起，只要本地作了提交，就可以通过如下命令：</p><p>git push origin master</p><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p><p>\2. 如何从远程库克隆？</p><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p><p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p><p>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p><p><img src="https://img.vim-cn.com/f1/28d8f6728f176194c18ae427ce7672ed66204d.png" alt="git-42"></p><p>如下，我们看到：</p><p><img src="https://img.vim-cn.com/0b/0105602339f7a63b99cad7ff8fc7e14a51326b.png" alt="git-43"></p><p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p><p><img src="https://img.vim-cn.com/88/37b60b1940ea4314a82bc4e60cea35a82e49da.png" alt="git-44"></p><p>接着在我本地目录下 生成testgit2目录了，如下所示：</p><p><img src="https://img.vim-cn.com/2c/6af45fdd7c80dd7a78a7d3c4b0628f78451634.png" alt="git-45"></p><h2 id="六：创建与合并分支。"><a href="#六：创建与合并分支。" class="headerlink" title="六：创建与合并分支。"></a>六：创建与合并分支。</h2><p>在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p><p>​ <img src="https://img.vim-cn.com/c4/b1e17b04d4aa70af0742f860dc755b8bc99d7d.png" alt="git-46"></p><p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p><p>git branch dev</p><p>git checkout dev</p><p>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><p><img src="https://img.vim-cn.com/61/74e0fd9828a5530a5c2b80598ef95a56150630.png" alt="git-47"></p><p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p><p><img src="https://img.vim-cn.com/0f/9f901cabdb61019683d516d3de594a9792947a.png" alt="git-48"></p><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p><p><strong>在master分支下创建并转到分支dev ：git checkout -b dev</strong></p><p><strong>在dev分支（此时内容和master一毛一样）做一些修改</strong></p><p><strong>然后远程操作一般是先 git pull origin master使得master与origin远程先同步</strong></p><p><strong>然后git push origin dev将dev分支推到origin分支</strong></p><p><strong>再切换到master分支git checkout master 再合并分支git merge dev</strong></p><p><img src="https://img.vim-cn.com/ff/086018080710de0082910848670b2ed5581007.png" alt="git-49"></p><p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p><p>注意到上面的<em>Fast-forward</em>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>合并完成后，我们可以接着删除dev分支了，操作如下：</p><p><img src="https://img.vim-cn.com/c5/e353896106305a74a6b09cd8092b6fa1abc5fe.png" alt="git-50"></p><p>总结创建与合并分支命令如下：</p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><p>如何解决冲突？</p><p>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p><p><img src="https://img.vim-cn.com/84/7d8d0c1a6194e8e2020e1c67c10180d2d9a854.png" alt="git-51"></p><p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p><p><img src="https://img.vim-cn.com/51/e24702835f75d58af98b0f53c88f10f68b887d.png" alt="git-52"></p><p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p><p><img src="https://img.vim-cn.com/f1/b275dd4dddd145831ddcfa4f963b4be086a314.png" alt="git-53"></p><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p><p><img src="https://img.vim-cn.com/a8/fb7edd6ac4187d5ceb3a81ed911398af435177.png" alt="git-54"></p><p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p><p><img src="https://img.vim-cn.com/e7/a360ed1831a96877f7e79ec49ede5dab668da2.png" alt="git-55"></p><p>3.分支管理策略。</p><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p><ol><li>创建一个dev分支。</li><li>修改readme.txt内容。</li><li>添加到暂存区。</li><li>切换回主分支(master)。</li><li>合并dev分支，使用命令 git merge –no-ff -m “注释” dev</li><li>查看历史记录</li></ol><p>截图如下：</p><p>​ <img src="https://img.vim-cn.com/11/9008d317dc0a0d7889c0e7c03fef4f2359cb71.png" alt="git-56"></p><p><strong>分支策略：</strong>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h2 id="七：bug分支："><a href="#七：bug分支：" class="headerlink" title="七：bug分支："></a>七：bug分支：</h2><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p><p>​ <img src="https://img.vim-cn.com/86/e01e194fb3803e210486b1c486f263f84c4505.png" alt="git-57"></p><p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p><p><img src="https://img.vim-cn.com/bb/e8cbd78754734d5c86d6b34e808a2f64292f49.png" alt="git-58"></p><p>所以现在我可以通过创建issue-404分支来修复bug了。</p><p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p><p>​ <img src="https://img.vim-cn.com/ab/bbb6c49735bf98bcd72832b567e2dd3482bced.png" alt="git-59"></p><p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p><p><img src="https://img.vim-cn.com/25/0b85dc031690b5b0eac907650c735fc7b0bffc.png" alt="git-60"></p><p>现在，我们回到dev分支上干活了。</p><p><img src="https://img.vim-cn.com/01/8fa0c38b1d0b7accf71aa6fd6d6cda219138ac.png" alt="git-61"></p><p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p><p><img src="https://img.vim-cn.com/11/fc850a37a2b693a11ebd27564e1cf25bd7c0ac.png" alt="git-62"></p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p><ol><li>git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</li><li>另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</li></ol><p>​ 演示如下</p><p><img src="https://img.vim-cn.com/bb/87d905b61da33219d648b687d5586b1f1f3e05.png" alt="git-63"></p><h2 id="八：多人协作"><a href="#八：多人协作" class="headerlink" title="八：多人协作"></a>八：多人协作</h2><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p><ol><li>要查看远程库的信息 使用 git remote</li><li>要查看远程库的详细信息 使用 git remote –v</li></ol><p>如下演示：</p><p>​ <img src="https://img.vim-cn.com/7e/7fe36e8a6dfa09923ec2d8bc2b56e37f32a43d.png" alt="git-64"></p><h3 id="一：推送分支："><a href="#一：推送分支：" class="headerlink" title="一：推送分支："></a><strong>一：推送分支：</strong></h3><p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><p>使用命令 git push origin master</p><p>比如我现在的github上的readme.txt代码如下：</p><p><img src="https://img.vim-cn.com/15/61f82d44dde26ddd9dbd58d077a7dd4799734e.png" alt="git-65"></p><p>本地的readme.txt代码如下：</p><p>​ <img src="https://img.vim-cn.com/95/173a2a31be6ebeac67427bd8df32856f7a98ac.png" alt="git-66"></p><p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p><p><img src="https://img.vim-cn.com/29/c50d67ff0778751e70a4cbd2f51813322633c7.png" alt="git-67"></p><p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p><p><img src="https://img.vim-cn.com/74/b988491115c711c22bab5b9366e777091d518e.png" alt="git-68"></p><p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev</p><p>那么一般情况下，那些分支要推送呢？</p><ol><li>master分支是主分支，因此要时刻与远程同步。</li><li>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</li></ol><h3 id="二：抓取分支："><a href="#二：抓取分支：" class="headerlink" title="二：抓取分支："></a><strong>二：抓取分支：</strong></h3><p>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2</p><p>但是我首先要把dev分支也要推送到远程去，如下</p><p><img src="https://img.vim-cn.com/1f/8d9edf66ede77f034e7e5c12b97b1f236eca64.jpg" alt="git-69"></p><p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p><p><img src="https://img.vim-cn.com/01/979d865032561133cc0a4f2966509512844e90.png" alt="git-70"></p><p>现在目录下生成有如下所示：</p><p><img src="https://img.vim-cn.com/20/c45d0f325d551b44450bd8516803044d9b73ed.png" alt="git-71"></p><p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev</p><p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p><p>如下：</p><p><img src="https://img.vim-cn.com/cf/ac7389565ee9d78b5c3bf90c72019ef1e81e4d.png" alt="git-72"></p><p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p><p><img src="https://img.vim-cn.com/3b/fe9e1b65c30dea40d92884a3b07168560569ed.png" alt="git-73"></p><p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p><p><img src="https://img.vim-cn.com/24/882fe4235b1c8cb210be4f9972a739994d680f.png" alt="git-74"></p><p><em>git pull</em>也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p><p><img src="https://img.vim-cn.com/ec/818fce2318330df62c5c9e33d3ae138817b9a1.png" alt="git-75"></p><p>这回<em>git pull</em>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：</p><p>我们可以先来看看readme.txt内容了。</p><p><img src="https://img.vim-cn.com/80/fc74cd7cdd8ba25e95f36a11effbe056fb87c7.png" alt="git-76"></p><p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</p><p><img src="https://img.vim-cn.com/8d/53c7de472c5c3cc8c247e05a39f116c15010de.png" alt="git-77"></p><p>因此：多人协作工作模式一般是这样的：</p><ol><li>首先，可以试图用git push origin branch-name推送自己的修改.</li><li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li><li>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</li></ol><h2 id="九-Git基本常用命令如下："><a href="#九-Git基本常用命令如下：" class="headerlink" title="九. Git基本常用命令如下："></a>九. Git基本常用命令如下：</h2><p>mkdir： XX (创建一个空目录 XX指目录名)</p><p>pwd： 显示当前目录的路径。</p><p>git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</p><p>git add XX 把xx文件添加到暂存区去。</p><p>git commit –m “XX” 提交文件 –m 后面的是注释。</p><p>git status 查看仓库状态</p><p>git diff XX 查看XX文件修改了那些内容</p><p>git log 查看历史记录</p><p>git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本</p><p>​ (如果想回退到100个版本，使用git reset –hard HEAD~100 )</p><p>cat XX 查看XX文件内容</p><p>git reflog 查看历史记录的版本号id</p><p>git checkout – XX 把XX文件在工作区的修改全部撤销。</p><p>git rm XX 删除XX文件</p><p>git remote add origin <a href="https://github.com/tugenhua0707/testgit" target="_blank" rel="noopener">https://github.com/tugenhua0707/testgit</a> 关联一个远程库</p><p>git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库</p><p>git clone <a href="https://github.com/tugenhua0707/testgit" target="_blank" rel="noopener">https://github.com/tugenhua0707/testgit</a> 从远程库中克隆</p><p>git checkout –b dev 创建dev分支 并切换到dev分支上</p><p>git branch 查看当前所有的分支</p><p>git checkout master 切换回master分支</p><p>git merge dev 在当前的分支上合并dev分支</p><p>git branch –d dev 删除dev分支</p><p>git branch name 创建分支</p><p>git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作</p><p>git stash list 查看所有被隐藏的文件列表</p><p>git stash apply 恢复被隐藏的文件，但是内容不删除</p><p>git stash drop 删除文件</p><p>git stash pop 恢复文件的同时 也删除文件</p><p>git remote 查看远程库的信息</p><p>git remote –v 查看远程库的详细信息</p><p>git push origin master Git会把master分支推送到远程库对应的远程分支上</p><h2 id="十-Git分支练习平台-快速通道"><a href="#十-Git分支练习平台-快速通道" class="headerlink" title="十. Git分支练习平台    快速通道"></a>十. Git分支练习平台 <a href="https://learngitbranching.js.org/?demo=&locale=zh_CN" target="_blank" rel="noopener">快速通道</a></h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive内嵌安装、本地安装和常见属性配置</title>
    <url>/2020/06/18/Hive%E5%86%85%E5%B5%8C%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<!-- build time:Sun Jun 28 2020 13:49:03 GMT+0800 (GMT+08:00) --><h1 id="Hive内嵌模式安装"><a href="#Hive内嵌模式安装" class="headerlink" title="Hive内嵌模式安装"></a>Hive内嵌模式安装</h1><h3 id="一、-Hive-安装"><a href="#一、-Hive-安装" class="headerlink" title="一、 Hive 安装"></a>一、 Hive 安装</h3><h4 id="1-解压安装包"><a href="#1-解压安装包" class="headerlink" title="1. 解压安装包"></a>1. 解压安装包</h4><p>现在已经为大家下载好了 hive2.3.4 的安装包，存放在 /root/software 目录下，首先进入此目录下，使用如下命令进行解压即可使用：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-hive-2.3.4-bin.tar.gz</span><br></pre></td></tr></table></figure><p>将其<strong>解压到当前目录下</strong>，即 /root/software 中。</p><h4 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h4><p>（1）首先打开 /etc/profile 文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>（2）将以下内容添加到配置文件的底部，添加完成输入“:wq”保存退出：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置Hive的安装目录   </span></span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/root/software/apache-hive-2.3.4-bin  </span><br><span class="line"><span class="comment"># 在原PATH的基础上加入Hive的bin目录  </span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HIVE_HOME</span>/bin</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>export 是把这两个变量导出为全局变量。</li><li>大小写必须严格区分。</li></ul><p>（3）让<strong>配置文件立即生效</strong>，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>（4）检测 Hive 环境变量是否设置成功，使用如下命令<strong>查看 Hive 版本</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive --version</span><br></pre></td></tr></table></figure><p>执行此命令后，若是出现 Hive 版本信息说明配置成功：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200429/jyqngavd_zuGmJHeBbqJLBA0Dk23M" alt="img"></p><h3 id="二、内嵌模式安装"><a href="#二、内嵌模式安装" class="headerlink" title="二、内嵌模式安装"></a>二、内嵌模式安装</h3><h4 id="1-修改配置文件-hive-env-sh"><a href="#1-修改配置文件-hive-env-sh" class="headerlink" title="1. 修改配置文件 hive-env.sh"></a>1. 修改配置文件 hive-env.sh</h4><p>切换到 ${HIVE_HOME}/conf 目录下，将 hive-env.sh.template 文件<strong>复制一份并重命名</strong>为 hive-env.sh：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure><p>修改完成，使用 <strong>vi 编辑器</strong>进行编辑：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim hive-env.sh</span><br></pre></td></tr></table></figure><p>在文件中配置 <strong>HADOOP_HOME</strong>、<strong>HIVE_CONF_DIR</strong> 以及<strong>HIVE_AUX_JARS_PATH</strong> 参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置Hadoop安装路径  </span></span><br><span class="line">HADOOP_HOME=/root/software/hadoop-2.7.7  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 配置Hive配置文件存放路径  </span></span><br><span class="line"><span class="built_in">export</span> HIVE_CONF_DIR=/root/software/apache-hive-2.3.4-bin/conf  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 配置Hive运行资源库路径  </span></span><br><span class="line"><span class="built_in">export</span> HIVE_AUX_JARS_PATH=/root/software/apache-hive-2.3.4-bin/lib</span><br></pre></td></tr></table></figure><p>配置完成，输入“:wq”保存退出。</p><h4 id="2-初始化元数据库"><a href="#2-初始化元数据库" class="headerlink" title="2. 初始化元数据库"></a>2. 初始化元数据库</h4><p>注意：当使用的 Hive 是 2.x 之前的版本时，不做初始化也是 OK 的。Hive 第一次启动时会自动进行初始化，只不过不会生成足够多的元数据库的表，其它的在使用过程中会慢慢生成。<strong>如果使用的是 2.x 版本的 Hive，那么就必须手动初始化元数据库。</strong> 使用如下命令进行初始化，这里我们使用 <strong>Hive 默认的 db 类型 “derby”</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">schematool -dbType derby -initSchema</span><br></pre></td></tr></table></figure><p>若是出现“schemaTool completed”则初始化成功，如下图所示：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200429/jyqngavd_G8Xxnwsc5uQUpcoRyLde" alt="img"></p><p>初始化完成，会在当前目录下生成一个 <strong>derby.log 文件</strong>和一个 <strong>metastore_db 目录</strong>。</p><h4 id="3-Hive-连接"><a href="#3-Hive-连接" class="headerlink" title="3. Hive 连接"></a>3. Hive 连接</h4><p>在此目录下使用 Hive 的三种连接方式之一：<strong>CLI 启动 Hive</strong>。由于已经在环境变量中配置了 HIVE_HOME ，所以这里直接在命令行执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive  </span><br><span class="line">或者  </span><br><span class="line">hive --service cli</span><br></pre></td></tr></table></figure><p>效果如下图所示：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200429/jyqngavd_UqYh1yVMrVj1q3NtCxjg" alt="img"></p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><h4 id="Hive-内嵌模式安装，具体步骤如下："><a href="#Hive-内嵌模式安装，具体步骤如下：" class="headerlink" title="Hive 内嵌模式安装，具体步骤如下："></a>Hive 内嵌模式安装，具体步骤如下：</h4><p><strong>1. Hive安装</strong><br>（1）解压安装包<br>（2）配置环境变量</p><p><strong>2. 内嵌模式安装</strong><br>（1）修改配置文件hive-env.sh<br>（2）初始化元数据库<br>（3）Hive 连接</p><h1 id="Hive本地安装"><a href="#Hive本地安装" class="headerlink" title="Hive本地安装"></a>Hive本地安装</h1><h2 id="任务1：安装-MySQL"><a href="#任务1：安装-MySQL" class="headerlink" title="任务1：安装 MySQL"></a>任务1：安装 MySQL</h2><h3 id="1-1-解压安装包"><a href="#1-1-解压安装包" class="headerlink" title="1.1 解压安装包"></a>1.1 解压安装包</h3><p>现在已经为大家下载好了 MySQL 5.7.25 的安装包，存放在 /root/software 目录下，首先进入此目录下，使用如下命令进行解压即可使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure><p>将其解压到当前目录下，即 /root/software 中。</p><h3 id="1-2-安装-MySQL-组件"><a href="#1-2-安装-MySQL-组件" class="headerlink" title="1.2 安装 MySQL 组件"></a>1.2 安装 MySQL 组件</h3><p>使用 <code>rpm -ivh</code> 命令依次安装以下组件：</p><p>（1）首先安装mysql-community-common （服务器和客户端库的公共文件），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（2）其次安装mysql-community-libs（MySQL数据库客户端应用程序的共享库），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（3）之后安装 mysql-community-libs-compat（MySQL 之前版本的共享兼容库），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（4）之后安装 mysql-community-client（MySQL客户端应用程序和工具），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（5）最后安装 mysql-community-server（数据库服务器和相关工具），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="1-3-登录-MySQL"><a href="#1-3-登录-MySQL" class="headerlink" title="1.3 登录 MySQL"></a>1.3 登录 MySQL</h3><h4 id="1-初始化-MySQL-的数据库"><a href="#1-初始化-MySQL-的数据库" class="headerlink" title="1. 初始化 MySQL 的数据库"></a>1. 初始化 MySQL 的数据库</h4><p>安装好 MySQL 后，我们需要初始化数据库，初始化和启动数据库时最好不要使用root用户，而是使用mysql用户启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld --initialize-insecure --user&#x3D;mysql</span><br></pre></td></tr></table></figure><h4 id="2-启动-MySQL-服务"><a href="#2-启动-MySQL-服务" class="headerlink" title="2. 启动 MySQL 服务"></a>2. 启动 MySQL 服务</h4><p>使用如下命令<strong>开启 MySQL 服务</strong>，让其在后台运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld --user&#x3D;mysql &amp;</span><br></pre></td></tr></table></figure><p>说明：一定要加“&amp;”，才能脚本放到后台运行。</p><h4 id="3-登录-MySQL"><a href="#3-登录-MySQL" class="headerlink" title="3. 登录 MySQL"></a>3. 登录 MySQL</h4><p>使用root用户<strong>无密码登录 MySQL</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot</span><br></pre></td></tr></table></figure><h4 id="4-重置-MySQL-密码"><a href="#4-重置-MySQL-密码" class="headerlink" title="4. 重置 MySQL 密码"></a>4. 重置 MySQL 密码</h4><p>在 5.7 版本后，我们可以使用 <code>alter user...identified by</code>命令把root用户的密码修改为“123456”，具体命令如下所示：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user 'root'@'localhost' identified by '123456';</span><br></pre></td></tr></table></figure><p>修改完成，使用<code>exit</code>或者<code>quit</code>命令退出 MySQL，重新登录验证密码是否修改成功，具体命令如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure><p>效果如下图所示：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200511/jyqngavd_3Eid3eXK7Eff4emZXVoQ" alt="img"></p><h3 id="1-4-增加远程登录权限"><a href="#1-4-增加远程登录权限" class="headerlink" title="1.4 增加远程登录权限"></a>1.4 增加远程登录权限</h3><p>当我们的帐号不允许从远程登录，只能在localhost连接时。这个时候只要在 MySQL 服务器上，更改mysql 数据库里的 user 表里的 host 项，从localhost改成%即可实现用户远程登录。</p><h4 id="（1）首先我们来查看-mysql-数据库下的-user表信息："><a href="#（1）首先我们来查看-mysql-数据库下的-user表信息：" class="headerlink" title="（1）首先我们来查看 mysql 数据库下的 user表信息："></a>（1）首先我们来查看 mysql 数据库下的 user表信息：</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;  # 切换成mysql数据库</span><br><span class="line">mysql&gt; select user,host from user; # 查询用户信息</span><br></pre></td></tr></table></figure><p>可以看到在user表中已创建的root用户。host字段表示登录的主机，其值可以用IP地址，也可用主机名。</p><h4 id="（2）实现远程连接（授权法）"><a href="#（2）实现远程连接（授权法）" class="headerlink" title="（2）实现远程连接（授权法）"></a>（2）实现远程连接（授权法）</h4><p>将 host 字段的值改为%就表示在任何客户端机器上能以root用户登录到 MySQL 服务器，建议在开发时设为%。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置远程登录权限 </span></span><br><span class="line">mysql&gt; update user set host='%' where host='localhost';</span><br><span class="line"><span class="comment"># 刷新配置信息</span></span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>效果图如下所示：<br><img src="https://assets.qingjiaoclass.com/qingjiao-ppt/2020-5-11/42879f7cbc4f57d0" alt="null"></p><h2 id="任务2：Hive-安装部署"><a href="#任务2：Hive-安装部署" class="headerlink" title="任务2：Hive 安装部署"></a>任务2：Hive 安装部署</h2><h3 id="2-1-解压安装包"><a href="#2-1-解压安装包" class="headerlink" title="2.1 解压安装包"></a>2.1 解压安装包</h3><p>现在已经为大家下载好了 hive2.3.4 的安装包，存放在 /root/software 目录下，首先进入此目录下，使用如下命令进行解压即可使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-hive-2.3.4-bin.tar.gz</span><br></pre></td></tr></table></figure><p>将其<strong>解压到当前目录下</strong>，即 /root/software 中。</p><h3 id="2-2-配置环境变量"><a href="#2-2-配置环境变量" class="headerlink" title="2.2 配置环境变量"></a>2.2 配置环境变量</h3><h4 id="（1）首先打开-etc-profile-文件："><a href="#（1）首先打开-etc-profile-文件：" class="headerlink" title="（1）首先打开 /etc/profile 文件："></a>（1）首先打开 /etc/profile 文件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h4 id="（2）将以下内容添加到配置文件的底部，添加完成输入“-wq”保存退出："><a href="#（2）将以下内容添加到配置文件的底部，添加完成输入“-wq”保存退出：" class="headerlink" title="（2）将以下内容添加到配置文件的底部，添加完成输入“:wq”保存退出："></a>（2）将以下内容添加到配置文件的底部，添加完成输入“:wq”保存退出：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置Hive的安装目录   </span><br><span class="line">export HIVE_HOME&#x3D;&#x2F;root&#x2F;software&#x2F;apache-hive-2.3.4-bin  </span><br><span class="line"># 在原PATH的基础上加入Hive的bin目录  </span><br><span class="line">export PATH&#x3D;$PATH:$HIVE_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><h4 id="（3）让配置文件立即生效，使用如下命令："><a href="#（3）让配置文件立即生效，使用如下命令：" class="headerlink" title="（3）让配置文件立即生效，使用如下命令："></a>（3）让配置文件立即生效，使用如下命令：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h4 id="（4）检测-Hive-环境变量是否设置成功，使用如下命令查看-Hive-版本："><a href="#（4）检测-Hive-环境变量是否设置成功，使用如下命令查看-Hive-版本：" class="headerlink" title="（4）检测 Hive 环境变量是否设置成功，使用如下命令查看 Hive 版本："></a>（4）检测 Hive 环境变量是否设置成功，使用如下命令查看 Hive 版本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive --version</span><br></pre></td></tr></table></figure><p>执行此命令后，若是出现 Hive 版本信息说明配置成功：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200429/jyqngavd_zuGmJHeBbqJLBA0Dk23M" alt="img"></p><h3 id="2-3-修改配置文件-hive-env-sh"><a href="#2-3-修改配置文件-hive-env-sh" class="headerlink" title="2.3 修改配置文件 hive-env.sh"></a>2.3 修改配置文件 hive-env.sh</h3><p>切换到 ${HIVE_HOME}/conf 目录下，将 hive-env.sh.template 文件<strong>复制一份并重命名</strong>为 hive-env.sh：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure><p>修改完成，使用 <strong>vi 编辑器</strong>进行编辑：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim hive-env.sh</span><br></pre></td></tr></table></figure><p>在文件中配置 <strong>HADOOP_HOME</strong>、<strong>HIVE_CONF_DIR</strong> 以及<strong>HIVE_AUX_JARS_PATH</strong> 参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置Hadoop安装路径  </span><br><span class="line">HADOOP_HOME&#x3D;&#x2F;root&#x2F;software&#x2F;hadoop-2.7.7  </span><br><span class="line">  </span><br><span class="line"># 配置Hive配置文件存放路径  </span><br><span class="line">export HIVE_CONF_DIR&#x3D;&#x2F;root&#x2F;software&#x2F;apache-hive-2.3.4-bin&#x2F;conf  </span><br><span class="line">  </span><br><span class="line"># 配置Hive运行资源库路径  </span><br><span class="line">export HIVE_AUX_JARS_PATH&#x3D;&#x2F;root&#x2F;software&#x2F;apache-hive-2.3.4-bin&#x2F;lib</span><br></pre></td></tr></table></figure><p>配置完成，输入“:wq”保存退出。</p><h2 id="任务3：Hive元数据配置到MySQL"><a href="#任务3：Hive元数据配置到MySQL" class="headerlink" title="任务3：Hive元数据配置到MySQL"></a>任务3：Hive元数据配置到MySQL</h2><h3 id="3-1-驱动拷贝"><a href="#3-1-驱动拷贝" class="headerlink" title="3.1 驱动拷贝"></a>3.1 驱动拷贝</h3><p>将/root/software目录下的 MySQL 驱动包 mysql-connector-java-5.1.47-bin.jar 拷贝到 ${HIVE_HOME}/lib 目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;software&#x2F;  </span><br><span class="line">cp mysql-connector-java-5.1.47-bin.jar apache-hive-2.3.4-bin&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure><h3 id="3-2-配置-Metastore到MySQL"><a href="#3-2-配置-Metastore到MySQL" class="headerlink" title="3.2 配置 Metastore到MySQL"></a>3.2 配置 Metastore到MySQL</h3><p>（1）在${HIVE_HOME}/conf目录下创建一个名为hive-site.xml的文件，并使用vi编辑器进行编辑：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch hive-site.xml  </span><br><span class="line">vim hive-site.xml</span><br></pre></td></tr></table></figure><p>（2）根据官方文档配置参数（<a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+Administration），拷贝数据到" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+Administration），拷贝数据到</a> hive-site.xml 文件中：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--连接元数据库的链接信息 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/hivedb?createDatabaseIfNotExist=true<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--连接数据库驱动 --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--连接数据库用户名称 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--连接数据库用户密码 --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-初始化元数据库"><a href="#3-3-初始化元数据库" class="headerlink" title="3.3 初始化元数据库"></a>3.3 初始化元数据库</h3><p>注意：<strong>如果使用的是 2.x 版本的 Hive，那么就必须手动初始化元数据库。</strong> 使用 <code>schematool -dbType &lt;db type&gt; -initSchema</code> 命令进行初始化：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure><p>若是出现“schemaTool completed”则初始化成功。<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200511/jyqngavd_QVpiQafyvlP3yOFT7qU9" alt="img"></p><h3 id="3-4-Hive-连接"><a href="#3-4-Hive-连接" class="headerlink" title="3.4 Hive 连接"></a>3.4 Hive 连接</h3><p>在任意目录下使用 Hive 的三种连接方式之一：<strong>CLI 启动 Hive</strong>。由于已经在环境变量中配置了 HIVE_HOME ，所以这里直接在命令行执行如下命令即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive  </span><br><span class="line">或者  </span><br><span class="line">hive --service cli</span><br></pre></td></tr></table></figure><p>效果如下图所示：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200511/jyqngavd_AT3NDqcu6ViewnCOXmrK" alt="img"></p><p>可以使用如下命令退出 Hive 客户端：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; exit;</span><br><span class="line">或者</span><br><span class="line">hive&gt; quit;</span><br></pre></td></tr></table></figure><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><h3 id="Hive-本地模式安装，具体步骤如下："><a href="#Hive-本地模式安装，具体步骤如下：" class="headerlink" title="Hive 本地模式安装，具体步骤如下："></a>Hive 本地模式安装，具体步骤如下：</h3><h4 id="1-安装-MySQL"><a href="#1-安装-MySQL" class="headerlink" title="1. 安装 MySQL"></a>1. 安装 MySQL</h4><p><strong>（1）解压安装包</strong><br><strong>（2）安装 MySQL 组件</strong>，顺序为：<br>common——》libs——》libs-compat——》client——》server<br><strong>（3）登录 MySQL</strong></p><ul><li>初始化 MySQL 的数据库</li><li>启动 MySQL 服务</li><li>登录 MySQL</li><li>重置 MySQL 密码</li></ul><p><strong>（4）增加远程登录权限</strong></p><h4 id="2-Hive-安装部署"><a href="#2-Hive-安装部署" class="headerlink" title="2. Hive 安装部署"></a>2. Hive 安装部署</h4><p><strong>（1）解压安装包</strong><br><strong>（2）配置环境变量：/etc/profile 文件</strong><br><strong>（3）修改配置文件hive-env.sh</strong></p><h4 id="3-Hive元数据配置到MySQL"><a href="#3-Hive元数据配置到MySQL" class="headerlink" title="3. Hive元数据配置到MySQL"></a>3. Hive元数据配置到MySQL</h4><p><strong>（1）驱动拷贝</strong>：　将MySQL 驱动包 mysql-connector-java-5.1.47-bin.jar 拷贝到 ${HIVE_HOME}/lib 目录下。<br><strong>（2）配置 Metastore到MySQL</strong>：hive-site.xml<br><strong>（3）初始化元数据库</strong><br><strong>（4）Hive 连接</strong></p><h1 id="Hive常见属性配置"><a href="#Hive常见属性配置" class="headerlink" title="Hive常见属性配置"></a>Hive常见属性配置</h1><p>（1）首先，将 <code>${HIVE_HOME}/conf</code> 目录下的 hive-log4j2.properties.template 文件复制一份并重命名为 hive-log4j2.properties，具体命令如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp hive-log4j2.properties.template hive-log4j2.properties</span><br></pre></td></tr></table></figure><p>（2）之后使用 vi 编辑器进行编辑，将 Hive 日志配置到 /root/hive/logs/myhive.log 文件中。用到的两个参数是：</p><ul><li>property.hive.log.dir</li><li>property.hive.log.file</li></ul><p>（3）重新启动 Hive：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive</span><br><span class="line">或者</span><br><span class="line">hive --service cli</span><br></pre></td></tr></table></figure><p>（4）验证新的日志文件是否自动创建：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200512/jyqngavd_3PT4ljOT4r60QnvkTzfw" alt="img"></p><p>从上图可以看出，我们成功将 Hive 日志存放路径修改为 /root/hive/logs/myhive.log。</p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><h3 id="Hive-运行日志信息配置"><a href="#Hive-运行日志信息配置" class="headerlink" title="Hive 运行日志信息配置"></a>Hive 运行日志信息配置</h3><p>在Hive中，使用的是 Log4j 来输出日志，<strong>默认情况下，CLI 是不能将日志信息输出到控制台的。</strong></p><p>默认的日志存放在<code>/tmp/${user.name}</code>文件夹的<code>hive.log</code>文件中，全路径就是<code>/tmp/${user.name}/hive.log</code>。</p><p>现要求将 Hive 的日志存放路径修改为 <strong>/root/hive/logs</strong>，日志文件为<strong>myhive.log</strong>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>linux</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>基础环境搭建、HDFS|YARN伪分布式集群和Hadoop集群</title>
    <url>/2020/06/18/Hadoop%E5%92%8C%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<!-- build time:Sun Jun 28 2020 13:49:03 GMT+0800 (GMT+08:00) --><h1 id="1-基础环境搭建"><a href="#1-基础环境搭建" class="headerlink" title="1. 基础环境搭建"></a>1. 基础环境搭建</h1><h2 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h2><h4 id="（1）准备软件"><a href="#（1）准备软件" class="headerlink" title="（1）准备软件"></a>（1）准备软件</h4><p>JDK的安装包已经为大家准备好，在/root/software目录下。</p><h4 id="（2）解压压缩包"><a href="#（2）解压压缩包" class="headerlink" title="（2）解压压缩包"></a>（2）解压压缩包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u221-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="（3）在此处我们配置系统环境变量，使用命令："><a href="#（3）在此处我们配置系统环境变量，使用命令：" class="headerlink" title="（3）在此处我们配置系统环境变量，使用命令："></a>（3）在此处我们配置<strong>系统环境变量</strong>，使用命令：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><h4 id="（4）在最后加入以下两行内容："><a href="#（4）在最后加入以下两行内容：" class="headerlink" title="（4）在最后加入以下两行内容："></a>（4）在最后加入以下两行内容：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/root/software/jdk1.8.0_221  # 配置Java的安装目录</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin  # 在原PATH的基础上加入JDK的bin目录</span><br></pre></td></tr></table></figure><h4 id="（5）让配置文件立即生效，使用如下命令："><a href="#（5）让配置文件立即生效，使用如下命令：" class="headerlink" title="（5）让配置文件立即生效，使用如下命令："></a>（5）<strong>让配置文件立即生效</strong>，使用如下命令：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="（6）检测JDK是否安装成功，使用命令查看JDK版本："><a href="#（6）检测JDK是否安装成功，使用命令查看JDK版本：" class="headerlink" title="（6）检测JDK是否安装成功，使用命令查看JDK版本："></a>（6）检测JDK是否安装成功，使用命令查看JDK版本：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><hr><h2 id="2-配置SSH免密登录"><a href="#2-配置SSH免密登录" class="headerlink" title="2. 配置SSH免密登录"></a>2. 配置SSH免密登录</h2><h4 id="（1）下载SSH服务并启动"><a href="#（1）下载SSH服务并启动" class="headerlink" title="（1）下载SSH服务并启动"></a>（1）下载SSH服务并启动</h4><p>SSH服务（openssh-server和openssh-clients）已经为大家下载好，所以此处直接启动即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/sbin/sshd</span><br></pre></td></tr></table></figure><p>SSH服务启动成功后，默认开启<strong>22（SSH的默认端口）端口号</strong>，可以使用以下命令进行查看：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tnulp</span><br></pre></td></tr></table></figure><p>执行命令，可以看到<strong>22号端口</strong>已经开启，证明我们SSH服务启动成功：<br><img src="http://assets.qingjiaoclass.com/image/20200206/8PJXrFA1Ij1580965846.png" alt="image.png"></p><h4 id="（2）首先生成密钥对，使用命令："><a href="#（2）首先生成密钥对，使用命令：" class="headerlink" title="（2）首先生成密钥对，使用命令："></a>（2）<strong>首先生成密钥对，使用命令：</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或者</span></span></span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>上面一种是简写形式，提示要输入信息时不需要输入任何东西，<strong>直接回车三次即可</strong>。</p><h4 id="（3）将公钥放置到授权列表文件-authorized-keys中，使用命令："><a href="#（3）将公钥放置到授权列表文件-authorized-keys中，使用命令：" class="headerlink" title="（3）将公钥放置到授权列表文件 authorized_keys中，使用命令："></a>（3）将公钥放置到<strong>授权列表文件 authorized_keys</strong>中，使用命令：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp id_rsa.pub authorized_keys</span><br></pre></td></tr></table></figure><h4 id="（4）修改授权列表文件-authorized-keys-的权限，使用命令："><a href="#（4）修改授权列表文件-authorized-keys-的权限，使用命令：" class="headerlink" title="（4）修改授权列表文件 authorized_keys 的权限，使用命令："></a>（4）修改授权列表文件 authorized_keys 的权限，使用命令：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><h4 id="（5）验证免密登录是否配置成功，使用如下命令："><a href="#（5）验证免密登录是否配置成功，使用如下命令：" class="headerlink" title="（5）验证免密登录是否配置成功，使用如下命令："></a>（5）验证免密登录是否配置成功，使用如下命令：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh localhost  </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或者</span></span></span><br><span class="line">ssh e2d670ea9ad7</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或者</span></span></span><br><span class="line">ssh 10.141.0.42</span><br></pre></td></tr></table></figure><h4 id="（6）远程登录成功后，若想退出，可以使用exit命令。"><a href="#（6）远程登录成功后，若想退出，可以使用exit命令。" class="headerlink" title="（6）远程登录成功后，若想退出，可以使用exit命令。"></a>（6）远程登录成功后，若想退出，可以使用<strong>exit</strong>命令。</h4><h1 id="2-HDFS伪分布式集群搭建"><a href="#2-HDFS伪分布式集群搭建" class="headerlink" title="2. HDFS伪分布式集群搭建"></a>2. HDFS伪分布式集群搭建</h1><h2 id="2-1-解压hadoop2-7-7安装包"><a href="#2-1-解压hadoop2-7-7安装包" class="headerlink" title="2.1. 解压hadoop2.7.7安装包"></a>2.1. 解压hadoop2.7.7安装包</h2><p>使用<code>cd</code>命令进入/root/software目录下，使用如下命令解压hadoop2.7.7安装包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-2.7.7.tar.gz</span><br></pre></td></tr></table></figure><h2 id="2-2-配置环境变量hadoop-env-sh"><a href="#2-2-配置环境变量hadoop-env-sh" class="headerlink" title="2.2 配置环境变量hadoop-env.sh"></a>2.2 配置环境变量hadoop-env.sh</h2><p>打开hadoop-env.sh文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /root/software/hadoop-2.7.7/etc/hadoop/hadoop-env.sh</span><br></pre></td></tr></table></figure><p>找到JAVA_HOME参数位置，<strong>修改为本机安装的JDK的实际位置</strong>。</p><h2 id="2-3-配置核心组件core-site-xml"><a href="#2-3-配置核心组件core-site-xml" class="headerlink" title="2.3 配置核心组件core-site.xml"></a>2.3 配置核心组件core-site.xml</h2><p>使用如下命令<strong>打开“core-site.xml”文件</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /root/software/hadoop-2.7.7/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure><p>将下面的配置内容添加到 <code>&lt;configuration&gt;&lt;/configuration&gt;</code> 中间：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HDFS集群中NameNode的URI（包括协议、主机名称、端口号），默认为 file:/// --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于指定NameNode的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hadoop运行时产生文件的临时存储目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hadoopData/temp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4-配置文件系统hdfs-site-xml"><a href="#2-4-配置文件系统hdfs-site-xml" class="headerlink" title="2.4 配置文件系统hdfs-site.xml"></a>2.4 配置文件系统hdfs-site.xml</h2><p>使用如下命令<strong>打开“hdfs-site.xml”文件</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /root/software/hadoop-2.7.7/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure><p>将下面的配置内容添加到 <code>&lt;configuration&gt;&lt;/configuration&gt;</code> 中间：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- NameNode在本地文件系统中持久存储命名空间和事务日志的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hadoopData/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- DataNode在本地文件系统中存放块的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hadoopData/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据块副本的数量，默认为3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-5-配置Hadoop系统环境变量"><a href="#2-5-配置Hadoop系统环境变量" class="headerlink" title="2.5 配置Hadoop系统环境变量"></a>2.5 配置Hadoop系统环境变量</h2><h4 id="1-首先打开-etc-profile文件（系统环境变量：对所有用户有效）："><a href="#1-首先打开-etc-profile文件（系统环境变量：对所有用户有效）：" class="headerlink" title="(1) 首先打开/etc/profile文件（系统环境变量：对所有用户有效）："></a>(1) 首先打开/etc/profile文件（系统环境变量：对所有用户有效）：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><h4 id="2-在文件底部添加如下内容："><a href="#2-在文件底部添加如下内容：" class="headerlink" title="(2) 在文件底部添加如下内容："></a>(2) 在文件底部添加如下内容：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置Hadoop的安装目录</span></span><br><span class="line">export HADOOP_HOME=/root/software/hadoop-2.7.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在原PATH的基础上加入Hadoop的bin和sbin目录</span></span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><h4 id="3-让配置文件立即生效，使用如下命令："><a href="#3-让配置文件立即生效，使用如下命令：" class="headerlink" title="(3) 让配置文件立即生效，使用如下命令："></a>(3) 让配置文件立即生效，使用如下命令：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="4-检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本："><a href="#4-检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本：" class="headerlink" title="(4) 检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本："></a>(4) 检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop version</span><br></pre></td></tr></table></figure><h2 id="2-6-格式化文件系统"><a href="#2-6-格式化文件系统" class="headerlink" title="2.6 格式化文件系统"></a>2.6 格式化文件系统</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><h2 id="2-7-脚本一键启动HDFS集群"><a href="#2-7-脚本一键启动HDFS集群" class="headerlink" title="2.7 脚本一键启动HDFS集群"></a>2.7 脚本一键启动HDFS集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure><h2 id="2-8-查看进程启动情况"><a href="#2-8-查看进程启动情况" class="headerlink" title="2.8 查看进程启动情况"></a>2.8 查看进程启动情况</h2><p>在本机上执行 <code>jps</code> 命令查看进程启动情况。</p><h2 id="2-9-通过UI查看HDFS运行状态"><a href="#2-9-通过UI查看HDFS运行状态" class="headerlink" title="2.9 通过UI查看HDFS运行状态"></a>2.9 通过UI查看HDFS运行状态</h2><p>通过本机的浏览器访问<strong><a href="http://localhost:50070" target="_blank" rel="noopener">http://localhost:50070</a></strong>或<strong>http://本机IP地址:50070</strong>查看HDFS集群状态。</p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><p>成功搭建HDFS伪分布式集群，具体步骤如下：</p><ol><li>解压hadoop2.7.7安装包</li><li>配置环境变量hadoop-env.sh</li><li>配置核心组件core-site.xml</li><li>配置文件系统hdfs-site.xml</li><li>配置Hadoop系统环境变量</li><li>格式化文件系统</li><li>脚本一键启动HDFS集群</li><li>查看进程启动情况</li><li>通过UI查看HDFS运行状态</li></ol><h1 id="3-YARN伪分布式集群搭建"><a href="#3-YARN伪分布式集群搭建" class="headerlink" title="3. YARN伪分布式集群搭建"></a>3. YARN伪分布式集群搭建</h1><h2 id="3-1-配置环境变量yarn-env-sh"><a href="#3-1-配置环境变量yarn-env-sh" class="headerlink" title="3.1 配置环境变量yarn-env.sh"></a>3.1 配置环境变量yarn-env.sh</h2><p>使用如下命令打开“yarn-env.sh”文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /root/software/hadoop-2.7.7/etc/hadoop/yarn-env.sh</span><br></pre></td></tr></table></figure><p>找到JAVA_HOME参数位置，将前面的#去掉，将其值修改为本机安装的JDK的实际位置。</p><h2 id="3-2-配置计算框架mapred-site-xml"><a href="#3-2-配置计算框架mapred-site-xml" class="headerlink" title="3.2 配置计算框架mapred-site.xml"></a>3.2 配置计算框架mapred-site.xml</h2><p>在$HADOOP_HOME/etc/hadoop/目录中默认没有该文件，需要先通过如下命令将文件<strong>复制并重命名为“mapred-site.xml”</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><p>接着，打开“mapred-site.xml”文件进行修改：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /root/software/hadoop-2.7.7/etc/hadoop/mapred-site.xml</span><br></pre></td></tr></table></figure><p>将下面的配置内容添加到 中间：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定使用 YARN 运行 MapReduce 程序，默认为 local --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-配置YARN系统yarn-site-xml"><a href="#3-3-配置YARN系统yarn-site-xml" class="headerlink" title="3.3 配置YARN系统yarn-site.xml"></a>3.3 配置YARN系统yarn-site.xml</h2><p>使用如下命令打开该配置文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /root/software/hadoop-2.7.7/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure><p>将下面的配置内容加入 中间：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- NodeManager上运行的附属服务，也可以理解为 reduce 获取数据的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-脚本一键启动YARN集群"><a href="#3-4-脚本一键启动YARN集群" class="headerlink" title="3.4 脚本一键启动YARN集群"></a>3.4 脚本一键启动YARN集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure><h2 id="3-5-查看进程启动情况"><a href="#3-5-查看进程启动情况" class="headerlink" title="3.5 查看进程启动情况"></a>3.5 查看进程启动情况</h2><p>在本机上执行 <code>jps</code> 命令查看进程启动情况。</p><h2 id="3-6-通过UI查看YARN运行状态"><a href="#3-6-通过UI查看YARN运行状态" class="headerlink" title="3.6 通过UI查看YARN运行状态"></a>3.6 通过UI查看YARN运行状态</h2><p>通过本机的浏览器访问<strong><a href="http://localhost:8088" target="_blank" rel="noopener">http://localhost:8088</a></strong>或<strong>http://本机IP地址:8088</strong>查看YARN集群状态。</p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><p>成功搭建YARN伪分布式集群，具体步骤如下：</p><ol><li>配置环境变量yarn-env.sh</li><li>配置计算框架 mapred-site.xml</li><li>配置 YARN 系统 yarn-site.xml</li><li>脚本一键启动YARN集群</li><li>查看进程启动情况</li><li>通过UI查看YARN运行状态</li></ol><h1 id="4-Hadoop集群"><a href="#4-Hadoop集群" class="headerlink" title="4. Hadoop集群"></a>4. Hadoop集群</h1><h2 id="4-1-启动Hadoop集群"><a href="#4-1-启动Hadoop集群" class="headerlink" title="4.1 启动Hadoop集群"></a>4.1 启动Hadoop集群</h2><p><strong>（1）HDFS集群</strong><br>在本机上使用如下方式<strong>一键启动HDFS集群</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure><p><strong>（2）YARN集群</strong><br>在本机上使用如下方式<strong>一键启动YARN集群</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure><hr><h2 id="4-2-WordCount示例执行流程"><a href="#4-2-WordCount示例执行流程" class="headerlink" title="4.2 WordCount示例执行流程"></a>4.2 WordCount示例执行流程</h2><p>（1）在本机桌面（/headless/Desktop）上创建一个名为inputdata的文件夹，在此文件夹下新建一个名为word.txt的文本文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop jar hadoop mapreduce</span><br><span class="line">hadoop hdfs</span><br><span class="line">hdfs hadoop jar fs</span><br><span class="line">fs</span><br></pre></td></tr></table></figure><p>注意单词之间用<strong>空格</strong>进行分隔。</p><p>（2）接着，在HDFS上创建/wordcount/input目录，并将word.txt文件上传至该目录下，具体指令如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -mkdir -p /wordcount/input</span><br><span class="line">hadoop fs -put /headless/Desktop/word.txt /wordcount/input</span><br></pre></td></tr></table></figure><p>（3）进入<code>$HADOOP_HOME/share/hadoop/mapreduce/</code>目录下，使用hadoop-mapreduce-examples-2.7.7.jar示例包，对HDFS上的word.txt文件进行单词统计，在jar包位置执行如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar hadoop-mapreduce-examples-2.7.7.jar wordcount \ </span><br><span class="line">/headless/Desktop/word.txt /wordcount/output</span><br></pre></td></tr></table></figure><p><strong>注意：\为换行指令（可以写成一行，不使用换行符）</strong></p><p>（4）程序执行成功后，我们可以使用HDFS Shell的相关指令查看part-r-00000的内容，具体指令如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -cat /wordcount/output/part-r-00000</span><br></pre></td></tr></table></figure><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><p><strong>执行WordCount示例，要求如下：</strong></p><p>(1) 在本机桌面（/headless/Desktop）上创建一个名为inputdata的文件夹，在此文件夹下新建一个名为word.txt的文本文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop jar hadoop mapreduce</span><br><span class="line">hadoop hdfs</span><br><span class="line">hdfs hadoop jar fs</span><br><span class="line">fs</span><br></pre></td></tr></table></figure><p>(2) 将word.txt上传到HDFS的/wordcount/input（若没有则需手动创建） 目录下，作为WordCount示例的数据源。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>linux</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数参数</title>
    <url>/2020/06/16/python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><h1 id="Python函数参数"><a href="#Python函数参数" class="headerlink" title="Python函数参数"></a>Python函数参数</h1><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>我们以具体的例子来说明如何定义函数的默认参数。先写一个计算x^2的函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure><p>当我们调用<code>power</code>函数时，必须传入有且仅有的一个参数<code>x</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(15)</span><br><span class="line">225</span><br></pre></td></tr></table></figure><p>现在，如果我们要计算x^3怎么办？可以再定义一个<code>power3</code>函数，但是如果要计算x^4 x^5……怎么办？我们不可能定义无限多个函数。</p><p>你也许想到了，可以把<code>power(x)</code>修改为<code>power(x, n)</code>，用来计算x^n，说干就干：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><p>对于这个修改后的<code>power</code>函数，可以计算任意n次方：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 3)</span><br><span class="line">125</span><br></pre></td></tr></table></figure><p>但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码无法正常调用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: power() takes exactly 2 arguments (1 given)</span><br></pre></td></tr></table></figure><p>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n&#x3D;2):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>而对于<code>n &gt; 2</code>的其他情况，就必须明确地传入n，比如<code>power(5, 3)</code>。</p><p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</p><p>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</p><p>二是如何设置默认参数。</p><p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p><p>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p><p>举个例子，我们写个一年级小学生注册的函数，需要传入<code>name</code>和<code>gender</code>两个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enroll(name, gender):</span><br><span class="line">    print &#39;name:&#39;, name</span><br><span class="line">    print &#39;gender:&#39;, gender</span><br></pre></td></tr></table></figure><p>这样，调用<code>enroll()</code>函数只需要传入两个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&#39;Sarah&#39;, &#39;F&#39;)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br></pre></td></tr></table></figure><p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。</p><p>我们可以把年龄和城市设为默认参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enroll(name, gender, age&#x3D;6, city&#x3D;&#39;Beijing&#39;):</span><br><span class="line">    print &#39;name:&#39;, name</span><br><span class="line">    print &#39;gender:&#39;, gender</span><br><span class="line">    print &#39;age:&#39;, age</span><br><span class="line">    print &#39;city:&#39;, city</span><br></pre></td></tr></table></figure><p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&#39;Sarah&#39;, &#39;F&#39;)</span><br><span class="line">Student:</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br><span class="line">age: 6</span><br><span class="line">city: Beijing</span><br></pre></td></tr></table></figure><p>只有与默认参数不符的学生才需要提供额外的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enroll(&#39;Bob&#39;, &#39;M&#39;, 7)</span><br><span class="line">enroll(&#39;Adam&#39;, &#39;M&#39;, city&#x3D;&#39;Tianjin&#39;)</span><br></pre></td></tr></table></figure><p>可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p><p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll(&#39;Bob&#39;, &#39;M&#39;, 7)</code>，意思是，除了<code>name</code>，<code>gender</code>这两个参数外，最后1个参数应用在参数<code>age</code>上，<code>city</code>参数由于没有提供，仍然使用默认值。</p><p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)</code>，意思是，<code>city</code>参数用传进去的值，其他默认参数继续使用默认值。</p><p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：</p><p>先定义一个函数，传入一个list，添加一个<code>END</code>再返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add_end(L&#x3D;[]):</span><br><span class="line">    L.append(&#39;END&#39;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure><p>当你正常调用时，结果似乎不错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end([1, 2, 3])</span><br><span class="line">[1, 2, 3, &#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span><br><span class="line">[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;END&#39;]</span><br></pre></td></tr></table></figure><p>当你使用默认参数调用时，一开始结果也是对的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br></pre></td></tr></table></figure><p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;, &#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]</span><br></pre></td></tr></table></figure><p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了<code>&#39;END&#39;</code>后的list。</p><p>原因解释如下：</p><p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><p>所以，定义默认参数要牢记一点：默认参数必须指向不变对象！</p><p>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add_end(L&#x3D;None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L &#x3D; []</span><br><span class="line">    L.append(&#39;END&#39;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure><p>现在，无论调用多少次，都不会有问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br></pre></td></tr></table></figure><p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p><p>我们以数学题为例子，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……。</p><p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def calc(numbers):</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum &#x3D; sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>但是调用的时候，需要先组装出一个list或tuple：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br></pre></td></tr></table></figure><p>如果利用可变参数，调用函数的方式可以简化成这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2, 3)</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc(1, 3, 5, 7)</span><br><span class="line">84</span><br></pre></td></tr></table></figure><p>所以，我们把函数的参数改为可变参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum &#x3D; sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; calc()</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; nums &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; nums &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>这种写法相当有用，而且很常见。</p><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print &#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw</span><br></pre></td></tr></table></figure><p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#39;Michael&#39;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br></pre></td></tr></table></figure><p>也可以传入任意个数的关键字参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#39;Bob&#39;, 35, city&#x3D;&#39;Beijing&#39;)</span><br><span class="line">name: Bob age: 35 other: &#123;&#39;city&#39;: &#39;Beijing&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#39;Adam&#39;, 45, gender&#x3D;&#39;M&#39;, job&#x3D;&#39;Engineer&#39;)</span><br><span class="line">name: Adam age: 45 other: &#123;&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure><p>关键字参数有什么用？它可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; kw &#x3D; &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city&#x3D;kw[&#39;city&#39;], job&#x3D;kw[&#39;job&#39;])</span><br><span class="line">name: Jack age: 24 other: &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure><p>当然，上面复杂的调用可以用简化的写法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; kw &#x3D; &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, **kw)</span><br><span class="line">name: Jack age: 24 other: &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure><h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。</p><p>比如定义一个函数，包含上述4种参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(a, b, c&#x3D;0, *args, **kw):</span><br><span class="line">    print &#39;a &#x3D;&#39;, a, &#39;b &#x3D;&#39;, b, &#39;c &#x3D;&#39;, c, &#39;args &#x3D;&#39;, args, &#39;kw &#x3D;&#39;, kw</span><br></pre></td></tr></table></figure><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; func(1, 2)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 0 args &#x3D; () kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, c&#x3D;3)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; () kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3, &#39;a&#39;, &#39;b&#39;)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (&#39;a&#39;, &#39;b&#39;) kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3, &#39;a&#39;, &#39;b&#39;, x&#x3D;99)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (&#39;a&#39;, &#39;b&#39;) kw &#x3D; &#123;&#39;x&#39;: 99&#125;</span><br></pre></td></tr></table></figure><p>最神奇的是通过一个tuple和dict，你也可以调用该函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; args &#x3D; (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw &#x3D; &#123;&#39;x&#39;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; func(*args, **kw)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (4,) kw &#x3D; &#123;&#39;x&#39;: 99&#125;</span><br></pre></td></tr></table></figure><p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p><p>默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！</p><p>要注意定义可变参数和关键字参数的语法：</p><p><code>*args</code>是可变参数，args接收的是一个tuple；</p><p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p><p>以及调用函数时如何传入可变参数和关键字参数的语法：</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p><p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的GC机制</title>
    <url>/2020/06/15/Python%E7%9A%84GC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><h1 id="Python的GC机制"><a href="#Python的GC机制" class="headerlink" title="Python的GC机制"></a>Python的GC机制</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>python采用的是<strong>引用计数</strong>机制为主，<strong>标记-清除</strong>和<strong>分代收集</strong>两种机制为辅的策略。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ul><li>Python语言默认采用的垃圾收集机制是『引用计数法 <code>Reference Counting</code>』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用。</li><li>『引用计数法』的原理是：每个对象维护一个<code>ob_ref</code>字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数<code>ob_ref</code>加<code>1</code>，每当该对象的引用失效时计数<code>ob_ref</code>减<code>1</code>，一旦对象的引用计数为<code>0</code>，该对象立即被回收，对象占用的内存空间将被释放。</li><li>它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，也有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</li></ul><h3 id="引用计数案例"><a href="#引用计数案例" class="headerlink" title="引用计数案例"></a>引用计数案例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''初始化对象'''</span></span><br><span class="line">        print(<span class="string">'object born id:%s'</span> %str(hex(id(self))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''循环引用变量与删除变量'''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c1=A()</span><br><span class="line">        <span class="keyword">del</span> c1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(c)</span>:</span></span><br><span class="line">    print(<span class="string">'obejct refcount is: '</span>,sys.getrefcount(c)) <span class="comment">#getrefcount()方法用于返回对象的引用计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   <span class="comment">#生成对象</span></span><br><span class="line">    a=A()</span><br><span class="line">    func(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#增加引用</span></span><br><span class="line">    b=a</span><br><span class="line">    func(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#销毁引用对象b</span></span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    func(a)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">object born id:<span class="number">0x265c56a56d8</span></span><br><span class="line">obejct refcount <span class="keyword">is</span>:  <span class="number">4</span></span><br><span class="line">obejct refcount <span class="keyword">is</span>:  <span class="number">5</span></span><br><span class="line">obejct refcount <span class="keyword">is</span>:  <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="导致引用计数-1的情况"><a href="#导致引用计数-1的情况" class="headerlink" title="导致引用计数+1的情况"></a>导致引用计数+1的情况</h4><ul><li>对象被创建，例如a=23</li><li>对象被引用，例如b=a</li><li>对象被作为参数，传入到一个函数中，例如<code>func(a)</code></li><li>对象作为一个元素，存储在容器中，例如<code>list1=[a,a]</code></li></ul><h4 id="导致引用计数-1的情况-1"><a href="#导致引用计数-1的情况-1" class="headerlink" title="导致引用计数-1的情况"></a>导致引用计数-1的情况</h4><ul><li>对象的别名被显式销毁，例如<code>del a</code></li><li>对象的别名被赋予新的对象，例如<code>a=24</code></li><li>一个对象离开它的作用域，例如f函数执行完毕时，<code>func</code>函数中的局部变量（全局变量不会）</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ul><h3 id="循环引用导致内存泄露"><a href="#循环引用导致内存泄露" class="headerlink" title="循环引用导致内存泄露"></a>循环引用导致内存泄露</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''循环引用'''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c1=A()</span><br><span class="line">        c2=A()</span><br><span class="line">        c1.t=c2</span><br><span class="line">        c2.t=c1</span><br><span class="line">        <span class="keyword">del</span> c1</span><br><span class="line">        <span class="keyword">del</span> c2</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">id:<span class="number">0x1feb9f691d0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69438</span></span><br><span class="line">object born id:<span class="number">0x1feb9f690b8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69d68</span></span><br><span class="line">object born id:<span class="number">0x1feb9f690f0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f694e0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69f60</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69eb8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69128</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69c88</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69470</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69e48</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69ef0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69dd8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69e10</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69ac8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69198</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69cf8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69da0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69c18</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69d30</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69ba8</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>创建了<code>c1</code>，<code>c2</code>后，这两个对象的引用计数都是<code>1</code>，执行<code>c1.t=c2</code>和<code>c2.t=c1</code>后，引用计数变成<code>2</code>.</li><li>在<code>del c1</code>后，内存<code>c1</code>的对象的引用计数变为<code>1</code>，由于不是为<code>0</code>，所以<code>c1</code>的对象不会被销毁,同理，在<code>del c2</code>后也是一样的。</li><li>虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。</li></ul><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><ul><li>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。</li><li>新创建的对象都会分配在<strong>年轻代</strong>，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到<strong>中年代</strong>去，依此类推，<strong>老年代</strong>中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</li><li>同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>有三种情况会触发垃圾回收：</p><ol><li>调用<code>gc.collect()</code>,需要先导入<code>gc</code>模块。</li><li>当<code>gc</code>模块的计数器达到阀值的时候。</li><li>程序退出的时候。</li></ol><h4 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a>gc模块</h4><p>gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p><p><strong>常用函数</strong>：</p><ol><li><code>gc.set_debug(flags)</code> 设置gc的debug日志，一般设置为<code>gc.DEBUG_LEAK</code></li><li><code>gc.collect([generation])</code><br>显式进行垃圾回收，可以输入参数，<code>0</code>代表只检查第一代的对象，<code>1</code>代表检查一，二代的对象，<code>2</code>代表检查一，二，三代的对象，如果不传参数，执行一个<code>full collection</code>，也就是等于传2。返回不可达（unreachable objects）对象的数目。</li><li><code>gc.set_threshold(threshold0[, threshold1[, threshold2])</code><br>设置自动执行垃圾回收的频率。</li><li><code>gc.get_count()</code> 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</li></ol><p>扩展资料：<a href="https://docs.python.org/3.5/library/gc.html" target="_blank" rel="noopener">Garbage Collector interface</a></p><h4 id="gc实践案例"><a href="#gc实践案例" class="headerlink" title="gc实践案例"></a>gc实践案例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''循环引用'''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c1=A()</span><br><span class="line">        c2=A()</span><br><span class="line">        c1.t=c2</span><br><span class="line">        c2.t=c1</span><br><span class="line">        <span class="keyword">del</span> c1</span><br><span class="line">        <span class="keyword">del</span> c2</span><br><span class="line">        <span class="comment">#增加垃圾回收机制</span></span><br><span class="line">        print(gc.garbage)</span><br><span class="line">        print(gc.collect())</span><br><span class="line">        print(gc.garbage)</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">object born id:<span class="number">0x21d1a5dc470</span></span><br><span class="line">object born id:<span class="number">0x21d1a5dc9e8</span></span><br><span class="line">[]</span><br><span class="line"><span class="number">4</span></span><br><span class="line">gc: collectable &lt;A <span class="number">0x0000021D1A5DC470</span>&gt;</span><br><span class="line">[&lt;__main__.A object at <span class="number">0x0000021D1A5DC470</span>&gt;, &lt;__main__.A object at <span class="number">0x0000021D1A5DC9E8</span>&gt;, &#123;<span class="string">'t'</span>: &lt;__main__.A object at <span class="number">0x0000021D1A5DC9E8</span>&gt;&#125;, &#123;<span class="string">'t'</span>: &lt;__main__.A object at <span class="number">0x0000021D1A5DC470</span>&gt;&#125;]</span><br><span class="line">gc: collectable &lt;A <span class="number">0x0000021D1A5DC9E8</span>&gt;</span><br><span class="line">gc: collectable &lt;dict <span class="number">0x0000021D1A156C88</span>&gt;</span><br><span class="line">gc: collectable &lt;dict <span class="number">0x0000021D1A5CABC8</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="gc模块的自动垃圾回收机制"><a href="#gc模块的自动垃圾回收机制" class="headerlink" title="gc模块的自动垃圾回收机制"></a>gc模块的自动垃圾回收机制</h3><p>必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。<br>这个机制的主要作用就是发现并处理不可达的垃圾对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">垃圾回收&#x3D;垃圾检查+垃圾回收</span><br></pre></td></tr></table></figure><p>在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。</p><p>gc模块里面会有一个长度为3的列表的计数器，可以通过<code>gc.get_count()</code>获取。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f4</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''垃圾自动回收'''</span></span><br><span class="line">    print(gc.get_count())</span><br><span class="line">    a=A()</span><br><span class="line">    print(gc.get_count())</span><br><span class="line">    <span class="keyword">del</span> a</span><br><span class="line">    print(gc.get_count())</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">621</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">object born id:<span class="number">0x2ca32a8c588</span></span><br><span class="line">(<span class="number">624</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">623</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><code>621</code>指距离上一次<code>一代</code>垃圾检查，Python分配内存的数目减去释放内存的数目，注意:是内存分配，而不是引用计数的增加。</li><li><code>10</code>指距离上一次<code>二代</code>垃圾检查，<code>一代</code>垃圾检查的次数。</li><li><code>0</code>是指距离上一次<code>三代</code>垃圾检查，<code>二代</code>垃圾检查的次数。</li></ul><h3 id="自动回收阈值"><a href="#自动回收阈值" class="headerlink" title="自动回收阈值"></a>自动回收阈值</h3><p>gc模快有一个自动垃圾回收的阀值，即通过<code>gc.get_threshold</code>函数获取到的长度为3的元组，例如<code>(700,10,10)</code><br>每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器</p><p>注意：<br>如果循环引用中，两个对象都定义了<code>__del__</code>方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的<code>__del__</code>方法，所以为了安全起见，gc模块会把对象放到<code>gc.garbage</code>中，但是不会销毁对象。</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p><p><img src="https://wx2.sbimg.cn/2020/06/22/GC.png" alt></p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 mark-sweepg 在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p><p>标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的is 和 == 你真的搞对对象了吗？</title>
    <url>/2020/06/09/Python%E7%9A%84%20is%20%E5%92%8C%20==%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><p>首先我先放一张简单总结的图</p><p><img src="https://wx2.sbimg.cn/2020/06/09/image-20200608161408086.png" alt="image-20200608161408086"></p><p>下面是我做的一个题目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已知x &#x3D; [[]]*3 执行语句x[0].append(1)后x的值为_____  #[[1],[1],[1]]</span><br><span class="line">已知x &#x3D; [[] for in i range(3)] 执行语句x[0].append(1)后x的值为_____  # [[1],[],[]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;b&#x3D;[[]]*3</span><br><span class="line">&gt;&gt;&gt;b</span><br><span class="line">[[], [], []]</span><br><span class="line">&gt;&gt;&gt;[id(b[i]) for i in range(3)]		#查看地址</span><br><span class="line">[2637926546248, 2637926546248, 2637926546248]</span><br><span class="line">&gt;&gt;&gt;a &#x3D; [[] for i in range(3)]</span><br><span class="line">&gt;&gt;&gt;[id(a[i]) for i in range(3)]		#查看地址</span><br><span class="line">[2637624332232, 2637909035016, 2637926538824]</span><br></pre></td></tr></table></figure><h3 id="下面开始正文，在Python中一切都是对象"><a href="#下面开始正文，在Python中一切都是对象" class="headerlink" title="下面开始正文，在Python中一切都是对象"></a>下面开始正文，在Python中一切都是对象</h3><p>Python中对象包含的三个基本要素，分别是：</p><ul><li>id(身份标识)</li><li>type(数据类型)</li><li>value(值)</li></ul><p>对象之间比较是否相等可以用 == ，也可以用 is 。</p><p>is 和 == 都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。下面来看看具体区别在哪?</p><p>is 比较的是两个对象的id值是否相等，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址。</p><p>== 比较的是两个对象的内容是否相等，默认会调用对象的 <code>__eq__</code> 方法。</p><p>== 是python标准操作符中的比较操作符，用来比较判断两个对象的值是否相等。</p><p>先来看一个例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br><span class="line">&gt;&gt;&gt; b is a </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b &#x3D;&#x3D; a</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a[:]</span><br><span class="line">&gt;&gt;&gt; b is a</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; b &#x3D;&#x3D; a</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>is 也被叫做同一性运算符，也就是id是否相同。</p><p>看下面代码， a和b变量的id不同， 所以 b == a 是True， b is a 是False.</p><p>再来看一下他们的id：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4364243328</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4364202696</span><br></pre></td></tr></table></figure><p>哪些情况下 is 和 == 结果是完全相同的？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 256</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 256</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 10**3</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>所以数字类型不完全相同。</p><p>那为什么256时相同， 而1000时不同呢？</p><p>因为出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫 small_ints 的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。</p><p>Python把这些可能频繁使用的整数对象规定在范围 [-5, 256] 之间的小对象放在 small_ints 中，但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; c &#x3D; &#39;miracle.young&#39;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &#39;miracle.young&#39;</span><br><span class="line">&gt;&gt;&gt; c is d</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; c &#x3D;&#x3D; d</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &#39;miracleyoung&#39;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &#39;miracleyoung&#39;</span><br><span class="line">&gt;&gt;&gt; c is c</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D;&#x3D; d</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>所以字符串类型不完全相同，这个和解释器实现有关。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; (1,2,3) # a和b为元组类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; (1,2,3)</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1,2,3] # a和b为list类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; &#123;&#39;miracle&#39;:100,&#39;young&#39;:1&#125; # a和b为dict类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;miracle&#39;:100,&#39;young&#39;:1&#125;</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; set([1,2,3]) # a和b为set类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; set([1,2,3])</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>所以当变量是数字、字符串、元组，列表，字典时，is 和 == 都不相同， 不能互换使用！当比较值时，要使用 ==，比较是否是同一个内存地址时应该使用is。</p><p>当然，开发中比较值的情况比较多。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中深拷贝和浅拷贝</title>
    <url>/2020/06/09/%E8%B0%88%E8%B0%88python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><h1 id="Python中深拷贝和浅拷贝"><a href="#Python中深拷贝和浅拷贝" class="headerlink" title="Python中深拷贝和浅拷贝"></a>Python中深拷贝和浅拷贝</h1><p>python中深拷贝和浅拷贝的知识这里进行下总结，以便今后复习<br><code>python</code>中的深拷贝和浅拷贝和<code>java</code>里面的概念是一样的，所谓浅拷贝就是对引用的拷贝，所谓深拷贝就是对对象的资源的拷贝。<br>首先，对<strong>赋值</strong>操作我们要有以下认识：</p><ol><li>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址（ 旧瓶装旧酒 ）。</li><li>修改不可变对象（<code>str</code>、<code>tuple</code>）需要开辟新的空间</li><li>修改可变对象（<code>list</code>等）不需要开辟新的空间</li></ol><ul><li><strong>浅拷贝</strong>仅仅复制了容器中元素的地址</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">'hello'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">6444104</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">6444104</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="string">'world'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">[<span class="string">'hello'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>这里可以看出，未修改前，<code>a</code>和<code>b</code>中元素的地址都是相同的，不可变的<code>hello</code><br>和可变的<code>list</code>地址都一样，说明浅拷贝知识将容器内的元素的地址复制了一份。这可以通过修改后，<code>b</code>中字符串没改变，但是<code>list</code>元素随着<code>a</code>相应改变得到验证。</p><blockquote><p>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。</p></blockquote><ul><li><strong>深拷贝</strong>，完全拷贝了一个副本，容器内部元素地址都不一样</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">'hello'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">55645000</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">58338824</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="string">'world'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">[<span class="string">'hello'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>这里可以看出，深拷贝后，<code>a</code>和<code>b</code>的地址以及<code>a</code>和<code>b</code>中的元素地址均不同，这是完全拷贝的一个副本，修改<code>a</code>后，发现<code>b</code>没有发生任何改变，因为<code>b</code>是一个完全的副本，元素地址与<code>a</code>均不同，<code>a</code>修改不影响<code>b</code>。</p><blockquote><p>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说（ 新瓶装新酒 ）。</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你彻底掌握 shell 语言</title>
    <url>/2020/06/01/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Shell/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><h1 id="一篇文章让你彻底掌握-shell-语言"><a href="#一篇文章让你彻底掌握-shell-语言" class="headerlink" title="一篇文章让你彻底掌握 shell 语言"></a>一篇文章让你彻底掌握 shell 语言</h1><blockquote><p>由于 bash 是 Linux 标准默认的 shell 解释器，可以说 bash 是 shell 编程的基础。</p><p>本文主要介绍 bash 的语法，对于 linux 指令不做任何介绍。</p><p>📓 本文已归档到：<a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">notes</a><br>⌨️ 本文的源码已归档到 <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos" target="_blank" rel="noopener">os-tutorial</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">███████╗	██╗  ██╗	███████╗	██╗     	██╗</span><br><span class="line">██╔════╝	██║  ██║	██╔════╝	██║     	██║</span><br><span class="line">███████╗	███████║	█████╗  	██║     	██║</span><br><span class="line">╚════██║	██╔══██║	██╔══╝  	██║     	██║</span><br><span class="line">███████║	██║  ██║	███████╗	███████╗	███████╗</span><br></pre></td></tr></table></figure><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-什么是-shell"><a href="#1-1-什么是-shell" class="headerlink" title="1.1. 什么是 shell"></a>1.1. 什么是 shell</h3><ul><li>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li><li>Shell 既是一种命令语言，又是一种程序设计语言。</li><li>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。</li></ul><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h3 id="1-2-什么是-shell-脚本"><a href="#1-2-什么是-shell-脚本" class="headerlink" title="1.2. 什么是 shell 脚本"></a>1.2. 什么是 shell 脚本</h3><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 <code>.sh</code>。</p><p>业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。</p><h3 id="1-3-Shell-环境"><a href="#1-3-Shell-环境" class="headerlink" title="1.3. Shell 环境"></a>1.3. Shell 环境</h3><p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Shell 的解释器种类众多，常见的有：</p><ul><li><a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">sh</a> - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。</li><li><a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">bash</a> - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。</li><li><a href="https://fishshell.com/" target="_blank" rel="noopener">fish</a> - 智能和用户友好的命令行 shell。</li><li><a href="http://xiki.org/" target="_blank" rel="noopener">xiki</a> - 使 shell 控制台更友好，更强大。</li><li><a href="http://www.zsh.org/" target="_blank" rel="noopener">zsh</a> - 功能强大的 shell 与脚本语言。</li></ul><h4 id="指定脚本解释器"><a href="#指定脚本解释器" class="headerlink" title="指定脚本解释器"></a>指定脚本解释器</h4><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang（也称为 Hashbang ）</a>。</p><p>所以，你应该会在 shell 中，见到诸如以下的注释：</p><ul><li>指定 sh 解释器</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure><ul><li>指定 bash 解释器</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure><p>这样做的好处是，系统会自动在 <code>PATH</code> 环境变量中查找你指定的程序（本例中的<code>bash</code>）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的<code>PATH</code>变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的<code>bash</code>，我们可能将其路径添加到<code>PATH</code>中，来“隐藏”老版本。如果直接用<code>#!/bin/bash</code>，那么系统会选择老版本的<code>bash</code>来执行脚本，如果用<code>#!/usr/bin/env bash</code>，则会使用新版本。</p></blockquote><h3 id="1-4-模式"><a href="#1-4-模式" class="headerlink" title="1.4. 模式"></a>1.4. 模式</h3><p>shell 有交互和非交互两种模式。</p><h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><blockquote><p>简单来说，你可以将 shell 的交互模式理解为执行命令行。</p></blockquote><p>看到形如下面的东西，说明 shell 处于交互模式下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user@host:~$</span><br></pre></td></tr></table></figure><p>接着，便可以输入一系列 Linux 命令，比如 <code>ls</code>，<code>grep</code>，<code>cd</code>，<code>mkdir</code>，<code>rm</code> 等等。</p><h4 id="非交互模式"><a href="#非交互模式" class="headerlink" title="非交互模式"></a>非交互模式</h4><blockquote><p>简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。</p></blockquote><p>在非交互模式下，shell 从文件或者管道中读取命令并执行。</p><p>当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。</p><p>可以使用下面的命令让 shell 以非交互模式运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh /path/to/script.sh</span><br><span class="line">bash /path/to/script.sh</span><br><span class="line"><span class="built_in">source</span> /path/to/script.sh</span><br><span class="line">./path/to/script.sh</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>script.sh</code>是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，<code>sh</code>和<code>bash</code>是 shell 解释器程序。你可以使用任何喜欢的编辑器创建<code>script.sh</code>（vim，nano，Sublime Text, Atom 等等）。</p><p>其中，<code>source /path/to/script.sh</code> 和 <code>./path/to/script.sh</code> 是等价的。</p><p>除此之外，你还可以通过<code>chmod</code>命令给文件添加可执行的权限，来直接执行脚本文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /path/to/script.sh <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">/path/to/test.sh</span><br></pre></td></tr></table></figure><p>这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如：</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/helloworld.sh" target="_blank" rel="noopener">helloworld.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们使用了一个很有用的命令<code>echo</code>来输出字符串到屏幕上。</p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="2-1-解释器"><a href="#2-1-解释器" class="headerlink" title="2.1. 解释器"></a>2.1. 解释器</h3><p>前面虽然两次提到了<code>#!</code> ，但是本着重要的事情说三遍的精神，这里再强调一遍：</p><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang（也称为 Hashbang ）</a>。</p><p><code>#!</code> 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入<code>sh</code>, <code>bash</code>, <code>python</code>, <code>php</code>等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure><h3 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2. 注释"></a>2.2. 注释</h3><p>注释可以说明你的代码是什么作用，以及为什么这样写。</p><p>shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。</p><ul><li>单行注释 - 以 <code>#</code> 开头，到行尾结束。</li><li>多行注释 - 以 <code>:&lt;&lt;EOF</code> 开头，到 <code>EOF</code> 结束。</li></ul><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/comment-demo.sh" target="_blank" rel="noopener">comment-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment"># shell 注释示例</span></span><br><span class="line"><span class="comment"># author：zp</span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo '这是单行注释'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## 这是分割线 ##########</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-3-echo"><a href="#2-3-echo" class="headerlink" title="2.3. echo"></a>2.3. echo</h3><p>echo 用于字符串的输出。</p><p>输出普通字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello, world"</span></span><br><span class="line"><span class="comment"># Output: hello, world</span></span><br></pre></td></tr></table></figure><p>输出含变量的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment"># Output: hello, "zp"</span></span><br></pre></td></tr></table></figure><p>输出含变量的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=zp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"<span class="variable">$&#123;name&#125;</span>\""</span></span><br><span class="line"><span class="comment"># Output: hello, "zp"</span></span><br></pre></td></tr></table></figure><p>输出含换行符的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出含换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"YES\nNO"</span></span><br><span class="line"><span class="comment">#  Output: YES\nNO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\nNO"</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br></pre></td></tr></table></figure><p>输出含不换行符的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"YES"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\c"</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YESNO</span></span><br></pre></td></tr></table></figure><p>输出重定向至文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; test.txt</span><br></pre></td></tr></table></figure><p>输出执行结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#  Output:(当前目录路径)</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/echo-demo.sh" target="_blank" rel="noopener">echo-demo.sh</a></p><h3 id="2-4-printf"><a href="#2-4-printf" class="headerlink" title="2.4. printf"></a>2.4. printf</h3><p>printf 用于格式化输出字符串。</p><p>默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 <code>\n</code>。</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/printf-demo.sh" target="_blank" rel="noopener">printf-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'%d %s\n'</span> 1 <span class="string">"abc"</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%d %s\n"</span> 1 <span class="string">"abc"</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无引号</span></span><br><span class="line"><span class="built_in">printf</span> %s abcdef</span><br><span class="line"><span class="comment">#  Output: abcdef(并不会换行)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> abc def</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  abc</span></span><br><span class="line"><span class="comment">#  def</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s\n"</span> a b c d e f g h i j</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  a b c</span></span><br><span class="line"><span class="comment">#  d e f</span></span><br><span class="line"><span class="comment">#  g h i</span></span><br><span class="line"><span class="comment">#  j</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s and %d \n"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#   and 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4s\n"</span> 姓名 性别 体重kg</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭靖 男 66.1234</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 杨过 男 48.6543</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭芙 女 47.9876</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  姓名     性别   体重kg</span></span><br><span class="line"><span class="comment">#  郭靖     男      66.12</span></span><br><span class="line"><span class="comment">#  杨过     男      48.65</span></span><br><span class="line"><span class="comment">#  郭芙     女      47.99</span></span><br></pre></td></tr></table></figure><h4 id="printf-的转义符"><a href="#printf-的转义符" class="headerlink" title="printf 的转义符"></a>printf 的转义符</h4><table><thead><tr><th>序列</th><th>说明</th></tr></thead><tbody><tr><td><code>\a</code></td><td>警告字符，通常为 ASCII 的 BEL 字符</td></tr><tr><td><code>\b</code></td><td>后退</td></tr><tr><td><code>\c</code></td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td><code>\f</code></td><td>换页（formfeed）</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车（Carriage return）</td></tr><tr><td><code>\t</code></td><td>水平制表符</td></tr><tr><td><code>\v</code></td><td>垂直制表符</td></tr><tr><td><code>\\</code></td><td>一个字面上的反斜杠字符</td></tr><tr><td><code>\ddd</code></td><td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td><code>\0ddd</code></td><td>表示 1 到 3 位的八进制值字符</td></tr></tbody></table><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p>跟许多程序设计语言一样，你可以在 bash 中创建变量。</p><p>Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。</p><h3 id="3-1-变量命名原则"><a href="#3-1-变量命名原则" class="headerlink" title="3.1. 变量命名原则"></a>3.1. 变量命名原则</h3><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li></ul><h3 id="3-2-声明变量"><a href="#3-2-声明变量" class="headerlink" title="3.2. 声明变量"></a>3.2. 声明变量</h3><p>访问变量的语法形式为：<code>${var}</code> 和 <code>$var</code> 。</p><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">word=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;word&#125;</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br></pre></td></tr></table></figure><h3 id="3-3-只读变量"><a href="#3-3-只读变量" class="headerlink" title="3.3. 只读变量"></a>3.3. 只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rword=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;rword&#125;</span></span><br><span class="line"><span class="built_in">readonly</span> rword</span><br><span class="line"><span class="comment"># rword="bye"  # 如果放开注释，执行时会报错</span></span><br></pre></td></tr></table></figure><h3 id="3-4-删除变量"><a href="#3-4-删除变量" class="headerlink" title="3.4. 删除变量"></a>3.4. 删除变量</h3><p>使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dword=<span class="string">"hello"</span>  <span class="comment"># 声明变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span>  <span class="comment"># 输出变量值</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> dword    <span class="comment"># 删除变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span></span><br><span class="line"><span class="comment"># Output: （空）</span></span><br></pre></td></tr></table></figure><h3 id="3-5-变量类型"><a href="#3-5-变量类型" class="headerlink" title="3.5. 变量类型"></a>3.5. 变量类型</h3><ul><li><strong>局部变量</strong> - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。</li><li><strong>环境变量</strong> - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 <code>export</code> 关键字，shell 脚本也可以定义环境变量。</li></ul><p>常见的环境变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$HOME</code></td><td>当前用户的用户目录</td></tr><tr><td><code>$PATH</code></td><td>用分号分隔的目录列表，shell 会到这些目录中查找命令</td></tr><tr><td><code>$PWD</code></td><td>当前工作目录</td></tr><tr><td><code>$RANDOM</code></td><td>0 到 32767 之间的整数</td></tr><tr><td><code>$UID</code></td><td>数值类型，当前用户的用户 ID</td></tr><tr><td><code>$PS1</code></td><td>主要系统输入提示符</td></tr><tr><td><code>$PS2</code></td><td>次要系统输入提示符</td></tr></tbody></table><p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html###sect_03_02_04" target="_blank" rel="noopener">这里</a> 有一张更全面的 Bash 环境变量列表。</p><h3 id="3-6-变量示例源码"><a href="#3-6-变量示例源码" class="headerlink" title="3.6. 变量示例源码"></a>3.6. 变量示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/variable-demo.sh" target="_blank" rel="noopener">variable-demo.sh</a></p><h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><h3 id="4-1-单引号和双引号"><a href="#4-1-单引号和双引号" class="headerlink" title="4.1. 单引号和双引号"></a>4.1. 单引号和双引号</h3><p>shell 字符串可以用单引号 <code>&#39;&#39;</code>，也可以用双引号 <code>“”</code>，也可以不用引号。</p><ul><li>单引号的特点<ul><li>单引号里不识别变量</li><li>单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。</li></ul></li><li>双引号的特点<ul><li>双引号里识别变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><p>综上，推荐使用双引号。</p><h3 id="4-2-拼接字符串"><a href="#4-2-拼接字符串" class="headerlink" title="4.2. 拼接字符串"></a>4.2. 拼接字符串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">name1=<span class="string">'white'</span></span><br><span class="line">str1=<span class="string">'hello, '</span><span class="variable">$&#123;name1&#125;</span><span class="string">''</span></span><br><span class="line">str2=<span class="string">'hello, $&#123;name1&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str1&#125;</span>_<span class="variable">$&#123;str2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, white_hello, $&#123;name1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">name2=<span class="string">"black"</span></span><br><span class="line">str3=<span class="string">"hello, "</span><span class="variable">$&#123;name2&#125;</span><span class="string">""</span></span><br><span class="line">str4=<span class="string">"hello, <span class="variable">$&#123;name2&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str3&#125;</span>_<span class="variable">$&#123;str4&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, black_hello, black</span></span><br></pre></td></tr></table></figure><h3 id="4-3-获取字符串长度"><a href="#4-3-获取字符串长度" class="headerlink" title="4.3. 获取字符串长度"></a>4.3. 获取字符串长度</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#text&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h3 id="4-4-截取子字符串"><a href="#4-4-截取子字符串" class="headerlink" title="4.4. 截取子字符串"></a>4.4. 截取子字符串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;text:2:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 34</span></span><br></pre></td></tr></table></figure><p>从第 3 个字符开始，截取 2 个字符</p><h3 id="4-5-查找子字符串"><a href="#4-5-查找子字符串" class="headerlink" title="4.5. 查找子字符串"></a>4.5. 查找子字符串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">text=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$&#123;text&#125;</span>"</span> ll`</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute: ./str-demo5.sh</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>查找 <code>ll</code> 子字符在 <code>hello</code> 字符串中的起始位置。</p><h3 id="4-6-字符串示例源码"><a href="#4-6-字符串示例源码" class="headerlink" title="4.6. 字符串示例源码"></a>4.6. 字符串示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/string-demo.sh" target="_blank" rel="noopener">string-demo.sh</a></p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><p>bash 只支持一维数组。</p><p>数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h3 id="5-1-创建数组"><a href="#5-1-创建数组" class="headerlink" title="5.1. 创建数组"></a>5.1. 创建数组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数组的不同方式</span></span><br><span class="line">nums=([2]=2 [0]=0 [1]=1)</span><br><span class="line">colors=(red yellow <span class="string">"dark blue"</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-访问数组元素"><a href="#5-2-访问数组元素" class="headerlink" title="5.2. 访问数组元素"></a>5.2. 访问数组元素</h3><ul><li><strong>访问数组的单个元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[1]&#125;</span></span><br><span class="line"><span class="comment"># Output: 1</span></span><br></pre></td></tr></table></figure><ul><li><strong>访问数组的所有元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br></pre></td></tr></table></figure><p>上面两行有很重要（也很微妙）的区别：</p><p>为了将数组中每个元素单独一行输出，我们用 <code>printf</code> 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark</span></span><br><span class="line"><span class="comment"># + blue</span></span><br></pre></td></tr></table></figure><p>为什么<code>dark</code>和<code>blue</code>各占了一行？尝试用引号包起来：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[*]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red yellow dark blue</span></span><br></pre></td></tr></table></figure><p>现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试<code>${colors[@]}</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark blue</span></span><br></pre></td></tr></table></figure><p>在引号内，<code>${colors[@]}</code>将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。</p><ul><li><strong>访问数组的部分元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]:0:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 0 1</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>${array[@]}</code> 扩展为整个数组，<code>:0:2</code>取出了数组中从 0 开始，长度为 2 的元素。</p><h3 id="5-3-访问数组长度"><a href="#5-3-访问数组长度" class="headerlink" title="5.3. 访问数组长度"></a>5.3. 访问数组长度</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#nums[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="5-4-向数组中添加元素"><a href="#5-4-向数组中添加元素" class="headerlink" title="5.4. 向数组中添加元素"></a>5.4. 向数组中添加元素</h3><p>向数组中添加元素也非常简单：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colors=(white <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span> green black)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># white red yellow dark blue green black</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>${colors[@]}</code> 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组<code>colors</code>的赋值覆盖了它原来的值。</p><h3 id="5-5-从数组中删除元素"><a href="#5-5-从数组中删除元素" class="headerlink" title="5.5. 从数组中删除元素"></a>5.5. 从数组中删除元素</h3><p>用<code>unset</code>命令来从数组中删除一个元素：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> nums[0]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure><h3 id="5-6-数组示例源码"><a href="#5-6-数组示例源码" class="headerlink" title="5.6. 数组示例源码"></a>5.6. 数组示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/array-demo.sh" target="_blank" rel="noopener">array-demo.sh</a></p><h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h2><h3 id="6-1-算术运算符"><a href="#6-1-算术运算符" class="headerlink" title="6.1. 算术运算符"></a>6.1. 算术运算符</h3><p>下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $x + $y</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr $x - $y</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr $x * $y</code> 结果为 200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr $y / $x</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr $y % $x</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td><code>x=$y</code> 将把变量 y 的值赋给 x。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true。</td><td><code>[ $x == $y ]</code> 返回 false。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td><code>[ $x != $y ]</code> 返回 true。</td></tr></tbody></table><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <code>[$x==$y]</code> 是错误的，必须写成 <code>[ $x == $y ]</code>。</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo.sh" target="_blank" rel="noopener">operator-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> == <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 + 20 = 30</span></span><br><span class="line"><span class="comment">#  10 - 20 = -10</span></span><br><span class="line"><span class="comment">#  10 * 20 = 200</span></span><br><span class="line"><span class="comment">#  20 / 10 = 2</span></span><br><span class="line"><span class="comment">#  20 % 10 = 0</span></span><br><span class="line"><span class="comment">#  10 != 20</span></span><br></pre></td></tr></table></figure><h3 id="6-2-关系运算符"><a href="#6-2-关系运算符" class="headerlink" title="6.2. 关系运算符"></a>6.2. 关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>检测两个数是否相等，相等返回 true。</td><td><code>[ $a -eq $b ]</code>返回 false。</td></tr><tr><td><code>-ne</code></td><td>检测两个数是否相等，不相等返回 true。</td><td><code>[ $a -ne $b ]</code> 返回 true。</td></tr><tr><td><code>-gt</code></td><td>检测左边的数是否大于右边的，如果是，则返回 true。</td><td><code>[ $a -gt $b ]</code> 返回 false。</td></tr><tr><td><code>-lt</code></td><td>检测左边的数是否小于右边的，如果是，则返回 true。</td><td><code>[ $a -lt $b ]</code> 返回 true。</td></tr><tr><td><code>-ge</code></td><td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td><code>[ $a -ge $b ]</code> 返回 false。</td></tr><tr><td><code>-le</code></td><td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td><code>[ $a -le $b ]</code>返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo2.sh" target="_blank" rel="noopener">operator-demo2.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> : x 等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 大于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 不大于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 小于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 不小于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 大于或等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 小于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 小于或等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 大于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo2.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -eq 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -ne 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -gt 20: x 不大于 y</span></span><br><span class="line"><span class="comment">#  10 -lt 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -ge 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -le 20: x 小于或等于 y</span></span><br></pre></td></tr></table></figure><h3 id="6-3-布尔运算符"><a href="#6-3-布尔运算符" class="headerlink" title="6.3. 布尔运算符"></a>6.3. 布尔运算符</h3><p>下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>!</code></td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td><code>[ ! false ]</code> 返回 true。</td></tr><tr><td><code>-o</code></td><td>或运算，有一个表达式为 true 则返回 true。</td><td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td></tr><tr><td><code>-a</code></td><td>与运算，两个表达式都为 true 才返回 true。</td><td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo3.sh" target="_blank" rel="noopener">operator-demo3.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 15 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 5 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo3.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 != 20 : x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 小于 100 且 20 大于 15 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 100 或 20 大于 100 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 5 或 20 大于 100 : 返回 false</span></span><br></pre></td></tr></table></figure><h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4. 逻辑运算符"></a>6.4. 逻辑运算符</h3><p>以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20:</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑的 AND</td><td><code>[[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]]</code> 返回 false</td></tr><tr><td>`</td><td></td><td>`</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo4.sh" target="_blank" rel="noopener">operator-demo4.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo4.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -lt 100 &amp;&amp; 20 -gt 100 返回 false</span></span><br><span class="line"><span class="comment">#  10 -lt 100 || 20 -gt 100 返回 true</span></span><br></pre></td></tr></table></figure><h3 id="6-5-字符串运算符"><a href="#6-5-字符串运算符" class="headerlink" title="6.5. 字符串运算符"></a>6.5. 字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>=</code></td><td>检测两个字符串是否相等，相等返回 true。</td><td><code>[ $a = $b ]</code> 返回 false。</td></tr><tr><td><code>!=</code></td><td>检测两个字符串是否相等，不相等返回 true。</td><td><code>[ $a != $b ]</code> 返回 true。</td></tr><tr><td><code>-z</code></td><td>检测字符串长度是否为 0，为 0 返回 true。</td><td><code>[ -z $a ]</code> 返回 false。</td></tr><tr><td><code>-n</code></td><td>检测字符串长度是否为 0，不为 0 返回 true。</td><td><code>[ -n $a ]</code> 返回 true。</td></tr><tr><td><code>str</code></td><td>检测字符串是否为空，不为空返回 true。</td><td><code>[ $a ]</code> 返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo5.sh" target="_blank" rel="noopener">operator-demo5.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=<span class="string">"abc"</span></span><br><span class="line">y=<span class="string">"xyz"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> : x 等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$&#123;x&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> : 字符串不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> : 字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo5.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=abc, y=xyz</span></span><br><span class="line"><span class="comment">#  abc = xyz: x 不等于 y</span></span><br><span class="line"><span class="comment">#  abc != xyz : x 不等于 y</span></span><br><span class="line"><span class="comment">#  -z abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  -n abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  abc : 字符串不为空</span></span><br></pre></td></tr></table></figure><h3 id="6-6-文件测试运算符"><a href="#6-6-文件测试运算符" class="headerlink" title="6.6. 文件测试运算符"></a>6.6. 文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td><code>[ -b $file ]</code> 返回 false。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td><code>[ -c $file ]</code> 返回 false。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td><td><code>[ -d $file ]</code> 返回 false。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td><code>[ -f $file ]</code> 返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td><code>[ -g $file ]</code> 返回 false。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td><code>[ -k $file ]</code>返回 false。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td><code>[ -p $file ]</code> 返回 false。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td><code>[ -u $file ]</code> 返回 false。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td><td><code>[ -r $file ]</code> 返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td><td><code>[ -w $file ]</code> 返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td><td><code>[ -x $file ]</code> 返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td><td><code>[ -s $file ]</code> 返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td><td><code>[ -e $file ]</code> 返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo6.sh" target="_blank" rel="noopener">operator-demo6.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file=<span class="string">"/etc/hosts"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -r <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可读"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可读"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -w <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可写"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可写"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -x <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可执行"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可执行"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为普通文件"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为特殊文件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件是个目录"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不是个目录"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -s <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -e <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo6.sh</span></span><br><span class="line"><span class="comment">#  Output:(根据文件的实际情况，输出结果可能不同)</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可读</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可写</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不可执行</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件为普通文件</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不是个目录</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不为空</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件存在</span></span><br></pre></td></tr></table></figure><h2 id="7-控制语句"><a href="#7-控制语句" class="headerlink" title="7. 控制语句"></a>7. 控制语句</h2><h3 id="7-1-条件语句"><a href="#7-1-条件语句" class="headerlink" title="7.1. 条件语句"></a>7.1. 条件语句</h3><p>跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在<code>[[ ]]</code>里的表达式。</p><p>由<code>[[ ]]</code>（<code>sh</code>中是<code>[ ]</code>）包起来的表达式被称作 <strong>检测命令</strong> 或 <strong>基元</strong>。这些表达式帮助我们检测一个条件的结果。这里可以找到有关<a href="http://serverfault.com/a/52050" target="_blank" rel="noopener">bash 中单双中括号区别</a>的答案。</p><p>共有两个不同的条件表达式：<code>if</code>和<code>case</code>。</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h4><p>（1）<code>if</code> 语句</p><p><code>if</code>在使用上跟其它语言相同。如果中括号里的表达式为真，那么<code>then</code>和<code>fi</code>之间的代码会被执行。<code>fi</code>标志着条件代码块的结束。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写成一行</span></span><br><span class="line"><span class="keyword">if</span> [[ 1 -eq 1 ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"1 -eq 1 result is: true"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 1 -eq 1 result is: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写成多行</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"abc"</span> -eq <span class="string">"abc"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">""</span>abc<span class="string">" -eq "</span>abc<span class="string">" result is: true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: abc -eq abc result is: true</span></span><br></pre></td></tr></table></figure><p>（2）<code>if else</code> 语句</p><p>同样，我们可以使用<code>if..else</code>语句，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 2 -ne 1 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: true</span></span><br></pre></td></tr></table></figure><p>（3）<code>if elif else</code> 语句</p><p>有些时候，<code>if..else</code>不能满足我们的要求。别忘了<code>if..elif..else</code>，使用起来也很方便。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 10 &lt; 20</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/if-demo.sh" target="_blank" rel="noopener">if-demo.sh</a></p><h4 id="case"><a href="#case" class="headerlink" title="case"></a><code>case</code></h4><p>如果你需要面对很多情况，分别要采取不同的措施，那么使用<code>case</code>会比嵌套的<code>if</code>更有用。使用<code>case</code>来解决复杂的条件判断，看起来像下面这样：</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/case-demo.sh" target="_blank" rel="noopener">case-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">"+"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"-"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"*"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"/"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unknown oper!"</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>每种情况都是匹配了某个模式的表达式。<code>|</code>用来分割多个模式，<code>)</code>用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。<code>*</code>代表任何不匹配以上给定模式的模式。命令块儿之间要用<code>;;</code>分隔。</p><h3 id="7-2-循环语句"><a href="#7-2-循环语句" class="headerlink" title="7.2. 循环语句"></a>7.2. 循环语句</h3><p>循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。</p><p>Bash 中有四种循环：<code>for</code>，<code>while</code>，<code>until</code>和<code>select</code>。</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><p><code>for</code>与它在 C 语言中的姊妹非常像。看起来是这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>在每次循环的过程中，<code>arg</code>依次被赋值为从<code>elem1</code>到<code>elemN</code>。这些值还可以是通配符或者<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#大括号扩展" target="_blank" rel="noopener">大括号扩展</a>。</p><p>当然，我们还可以把<code>for</code>循环写在一行，但这要求<code>do</code>之前要有一个分号，就像下面这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>还有，如果你觉得<code>for..in..do</code>对你来说有点奇怪，那么你也可以像 C 语言那样使用<code>for</code>，比如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 10; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>当我们想对一个目录下的所有文件做同样的操作时，<code>for</code>就很方便了。举个例子，如果我们想把所有的<code>.bash</code>文件移动到<code>script</code>文件夹中，并给它们可执行权限，我们的脚本可以这样写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DIR=/home/zp</span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$&#123;DIR&#125;</span>/*.sh; <span class="keyword">do</span></span><br><span class="line">  mv <span class="string">"<span class="variable">$FILE</span>"</span> <span class="string">"<span class="variable">$&#123;DIR&#125;</span>/scripts"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/for-demo.sh" target="_blank" rel="noopener">for-demo.sh</a></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h4><p><code>while</code>循环检测一个条件，只要这个条件为 <em>真</em>，就执行一段命令。被检测的条件跟<code>if..then</code>中使用的<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#基元和组合表达式" target="_blank" rel="noopener">基元</a>并无二异。因此一个<code>while</code>循环看起来会是这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [[ condition ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>跟<code>for</code>循环一样，如果我们把<code>do</code>和被检测的条件写到一行，那么必须要在<code>do</code>之前加一个分号。</p><p>比如下面这个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 0到9之间每个数的平方</span></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> $((x * x))</span><br><span class="line">  x=$((x + 1))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  4</span></span><br><span class="line"><span class="comment">#  9</span></span><br><span class="line"><span class="comment">#  16</span></span><br><span class="line"><span class="comment">#  25</span></span><br><span class="line"><span class="comment">#  36</span></span><br><span class="line"><span class="comment">#  49</span></span><br><span class="line"><span class="comment">#  64</span></span><br><span class="line"><span class="comment">#  81</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/while-demo.sh" target="_blank" rel="noopener">while-demo.sh</a></p><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a><code>until</code>循环</h4><p><code>until</code>循环跟<code>while</code>循环正好相反。它跟<code>while</code>一样也需要检测一个测试条件，但不同的是，只要该条件为 <em>假</em> 就一直执行循环：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=0</span><br><span class="line">until [[ <span class="variable">$&#123;x&#125;</span> -ge 5 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span></span><br><span class="line">  x=`expr <span class="variable">$&#123;x&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  2</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  4</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/until-demo.sh" target="_blank" rel="noopener">until-demo.sh</a></p><h4 id="select循环"><a href="#select循环" class="headerlink" title="select循环"></a><code>select</code>循环</h4><p><code>select</code>循环帮助我们组织一个用户菜单。它的语法几乎跟<code>for</code>循环一致：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select answer <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>select</code>会打印<code>elem1..elemN</code>以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是<code>$?</code>（<code>PS3</code>变量）。用户的选择结果会被保存到<code>answer</code>中。如果<code>answer</code>是一个在<code>1..N</code>之间的数字，那么<code>语句</code>会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用<code>break</code>语句。</p><p>一个可能的实例可能会是这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">PS3=<span class="string">"Choose the package manager: "</span></span><br><span class="line">select ITEM <span class="keyword">in</span> bower npm gem pip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Enter the package name: "</span> &amp;&amp; <span class="built_in">read</span> PACKAGE</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;ITEM&#125;</span> <span class="keyword">in</span></span><br><span class="line">  bower) bower install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  npm) npm install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  gem) gem install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  pip) pip install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">break</span> <span class="comment"># 避免无限循环</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。</p><p>运行这个脚本，会得到如下输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">1) bower</span><br><span class="line">2) npm</span><br><span class="line">3) gem</span><br><span class="line">4) pip</span><br><span class="line">Choose the package manager: 2</span><br><span class="line">Enter the package name: gitbook-cli</span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/select-demo.sh" target="_blank" rel="noopener">select-demo.sh</a></p><h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a><code>break</code> 和 <code>continue</code></h4><p>如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的<code>break</code>和<code>continue</code>语句来实现。它们可以在任何循环中使用。</p><blockquote><p><code>break</code>语句用来提前结束当前循环。</p><p><code>continue</code>语句用来跳过某次迭代。</p></blockquote><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/break-demo.sh" target="_blank" rel="noopener">break-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找 10 以内第一个能整除 2 和 3 的正整数</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;i&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % 3)) -eq 0 ]] &amp;&amp; [[ $((i % 2)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  i=`expr <span class="variable">$&#123;i&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># Output: 6</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/continue-demo.sh" target="_blank" rel="noopener">continue-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印10以内的奇数</span></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 10; i ++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % 2)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  5</span></span><br><span class="line"><span class="comment">#  7</span></span><br><span class="line"><span class="comment">#  9</span></span><br></pre></td></tr></table></figure><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><p>bash 函数定义语法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()] &#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 说明：</p><ol><li>函数定义时，<code>function</code> 关键字可有可无。</li><li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。</li><li>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</li><li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li></ol></blockquote><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo.sh" target="_blank" rel="noopener">function-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">calc</span></span>()&#123;</span><br><span class="line">  PS3=<span class="string">"choose the oper: "</span></span><br><span class="line">  select oper <span class="keyword">in</span> + - \* / <span class="comment"># 生成操作符选择菜单</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"enter first num: "</span> &amp;&amp; <span class="built_in">read</span> x <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"enter second num: "</span> &amp;&amp; <span class="built_in">read</span> y <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">exec</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"+"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"-"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"*"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"/"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;oper&#125;</span> is not support!"</span></span><br><span class="line">      <span class="built_in">return</span> 0</span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">calc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the result is: $?"</span> <span class="comment"># $? 获取 calc 函数返回值</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./<span class="keyword">function</span>-demo.sh</span><br><span class="line">1) +</span><br><span class="line">2) -</span><br><span class="line">3) *</span><br><span class="line">4) /</span><br><span class="line">choose the oper: 3</span><br><span class="line">enter first num: 10</span><br><span class="line">enter second num: 10</span><br><span class="line">the result is: 100</span><br></pre></td></tr></table></figure><h3 id="8-1-位置参数"><a href="#8-1-位置参数" class="headerlink" title="8.1. 位置参数"></a>8.1. 位置参数</h3><p><strong>位置参数</strong>是在调用一个函数并传给它参数时创建的变量。</p><p>位置参数变量表：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本名称</td></tr><tr><td><code>$1 … $9</code></td><td>第 1 个到第 9 个参数列表</td></tr><tr><td><code>${10} … ${N}</code></td><td>第 10 个到 N 个参数列表</td></tr><tr><td><code>$*</code> or <code>$@</code></td><td>除了<code>$0</code>外的所有位置参数</td></tr><tr><td><code>$#</code></td><td>不包括<code>$0</code>在内的位置参数的个数</td></tr><tr><td><code>$FUNCNAME</code></td><td>函数名称（仅在函数内部有值）</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo2.sh" target="_blank" rel="noopener">function-demo2.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span></span><br><span class="line">  x=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第一个参数为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">y=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$2</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第二个参数为：<span class="variable">$2</span>"</span></span><br><span class="line">  y=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第二个参数为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第一个入参：<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第二个入参：<span class="variable">$2</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction <span class="variable">$&#123;x&#125;</span> <span class="variable">$&#123;y&#125;</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./<span class="keyword">function</span>-demo2.sh</span><br><span class="line">第一个参数为空</span><br><span class="line">第二个参数为空</span><br><span class="line">函数第一个入参：0</span><br><span class="line">函数第二个入参：0</span><br><span class="line"></span><br><span class="line">$ ./<span class="keyword">function</span>-demo2.sh 10 20</span><br><span class="line">第一个参数为：10</span><br><span class="line">第二个参数为：20</span><br><span class="line">函数第一个入参：10</span><br><span class="line">函数第二个入参：20</span><br></pre></td></tr></table></figure><p>执行 <code>./variable-demo4.sh hello world</code> ，然后在脚本中通过 <code>$1</code>、<code>$2</code> … 读取第 1 个参数、第 2 个参数。。。</p><h3 id="8-2-函数处理参数"><a href="#8-2-函数处理参数" class="headerlink" title="8.2. 函数处理参数"></a>8.2. 函数处理参数</h3><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>返回参数个数</td></tr><tr><td><code>$*</code></td><td>返回所有参数</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程 ID 号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的 ID 号</td></tr><tr><td><code>$@</code></td><td>返回所有参数</td></tr><tr><td><code>$-</code></td><td>返回 Shell 使用的当前选项，与 set 命令功能相同。</td></tr><tr><td><code>$?</code></td><td>函数返回值</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo3.sh" target="_blank" rel="noopener">function-demo3.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">runner</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name=zp</span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第一个入参：<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第二个入参：<span class="variable">$2</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"传递到脚本的参数个数：<span class="variable">$#</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数："</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"$*"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"脚本运行的当前进程 ID 号：$$"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"后台运行的最后一个进程的 ID 号：$!"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数："</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Shell 使用的当前选项：$-"</span></span><br><span class="line">  runner</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"runner 函数的返回值：$?"</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction 1 <span class="string">"abc"</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  函数第一个入参：1</span></span><br><span class="line"><span class="comment">#  函数第二个入参：abc</span></span><br><span class="line"><span class="comment">#  传递到脚本的参数个数：3</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1 abc hello, "zp"</span></span><br><span class="line"><span class="comment">#  脚本运行的当前进程 ID 号：26400</span></span><br><span class="line"><span class="comment">#  后台运行的最后一个进程的 ID 号：</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1</span></span><br><span class="line"><span class="comment">#  + abc</span></span><br><span class="line"><span class="comment">#  + hello, "zp"</span></span><br><span class="line"><span class="comment">#  Shell 使用的当前选项：hB</span></span><br><span class="line"><span class="comment">#  runner 函数的返回值：0</span></span><br></pre></td></tr></table></figure><h2 id="9-Shell-扩展"><a href="#9-Shell-扩展" class="headerlink" title="9. Shell 扩展"></a>9. Shell 扩展</h2><p><em>扩展</em> 发生在一行命令被分成一个个的 <em>记号（tokens）</em> 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。</p><p>感兴趣的话可以阅读<a href="https://www.gnu.org/software/bash/manual/bash.html###Shell-Expansions" target="_blank" rel="noopener">关于 shell 扩展的更多细节</a>。</p><h4 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h4><p>大括号扩展让生成任意的字符串成为可能。它跟 <em>文件名扩展</em> 很类似，举个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> beg&#123;i,a,u&#125;n <span class="comment">### begin began begun</span></span><br></pre></td></tr></table></figure><p>大括号扩展还可以用来创建一个可被循环迭代的区间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;0..5&#125; <span class="comment">### 0 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">echo</span> &#123;00..8..2&#125; <span class="comment">### 00 02 04 06 08</span></span><br></pre></td></tr></table></figure><h4 id="命令置换"><a href="#命令置换" class="headerlink" title="命令置换"></a>命令置换</h4><p>命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或<code>$()</code>包围时，命令置换将会执行。举个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">now=`date +%T`</span><br><span class="line"><span class="comment">### or</span></span><br><span class="line">now=$(date +%T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$now</span> <span class="comment">### 19:08:26</span></span><br></pre></td></tr></table></figure><h4 id="算数扩展"><a href="#算数扩展" class="headerlink" title="算数扩展"></a>算数扩展</h4><p>在 bash 中，执行算数运算是非常方便的。算数表达式必须包在<code>$(( ))</code>中。算数扩展的格式为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">result=$(( ((10 + 5*3) - 7) / 2 ))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span> <span class="comment">### 9</span></span><br></pre></td></tr></table></figure><p>在算数表达式中，使用变量无需带上<code>$</code>前缀：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=4</span><br><span class="line">y=7</span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 11</span></span><br><span class="line"><span class="built_in">echo</span> $(( ++x + y++ )) <span class="comment">### 12</span></span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 13</span></span><br></pre></td></tr></table></figure><h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Your home: <span class="variable">$HOME</span>"</span> <span class="comment">### Your home: /Users/&lt;username&gt;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Your home: $HOME'</span> <span class="comment">### Your home: $HOME</span></span><br></pre></td></tr></table></figure><p>当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用<code>echo</code>来输出用户的输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INPUT=<span class="string">"A string  with   strange    whitespace."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$INPUT</span>   <span class="comment">### A string with strange whitespace.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$INPUT</span>"</span> <span class="comment">### A string  with   strange    whitespace.</span></span><br></pre></td></tr></table></figure><p>调用第一个<code>echo</code>时给了它 5 个单独的参数 —— <code>$INPUT</code> 被分成了单独的词，<code>echo</code>在每个词之间打印了一个空格。第二种情况，调用<code>echo</code>时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。</p><p>来看一个更严肃的例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FILE=<span class="string">"Favorite Things.txt"</span></span><br><span class="line">cat <span class="variable">$FILE</span>   <span class="comment">### 尝试输出两个文件: `Favorite` 和 `Things.txt`</span></span><br><span class="line">cat <span class="string">"<span class="variable">$FILE</span>"</span> <span class="comment">### 输出一个文件: `Favorite Things.txt`</span></span><br></pre></td></tr></table></figure><p>尽管这个问题可以通过把 FILE 重命名成<code>Favorite-Things.txt</code>来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（<code>find</code>, <code>cat</code>, 等等）呢。因此，如果输入 <em>可能</em> 包含空格，务必要用引号把表达式包起来。</p><h2 id="10-流和重定向"><a href="#10-流和重定向" class="headerlink" title="10. 流和重定向"></a>10. 流和重定向</h2><p>Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。</p><p>管道给了我们创建传送带的机会，控制程序的执行成为可能。</p><p>学习如何使用这些强大的、高级的工具是非常非常重要的。</p><h3 id="10-1-输入、输出流"><a href="#10-1-输入、输出流" class="headerlink" title="10.1. 输入、输出流"></a>10.1. 输入、输出流</h3><p>Bash 接收输入，并以字符序列或 <strong>字符流</strong> 的形式产生输出。这些流能被重定向到文件或另一个流中。</p><p>有三个文件描述符：</p><table><thead><tr><th>代码</th><th>描述符</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>stdin</code></td><td>标准输入</td></tr><tr><td><code>1</code></td><td><code>stdout</code></td><td>标准输出</td></tr><tr><td><code>2</code></td><td><code>stderr</code></td><td>标准错误输出</td></tr></tbody></table><h3 id="10-2-重定向"><a href="#10-2-重定向" class="headerlink" title="10.2. 重定向"></a>10.2. 重定向</h3><p>重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>重定向输出</td></tr><tr><td><code>&amp;&gt;</code></td><td>重定向输出和错误输出</td></tr><tr><td><code>&amp;&gt;&gt;</code></td><td>以附加的形式重定向输出和错误输出</td></tr><tr><td><code>&lt;</code></td><td>重定向输入</td></tr><tr><td><code>&lt;&lt;</code></td><td><a href="http://tldp.org/LDP/abs/html/here-docs.html" target="_blank" rel="noopener">Here 文档</a> 语法</td></tr><tr><td><code>&lt;&lt;&lt;</code></td><td><a href="http://www.tldp.org/LDP/abs/html/x17837.html" target="_blank" rel="noopener">Here 字符串</a></td></tr></tbody></table><p>以下是一些使用重定向的例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### ls的结果将会被写到list.txt中</span></span><br><span class="line">ls -l &gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 将输出附加到list.txt中</span></span><br><span class="line">ls -a &gt;&gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 所有的错误信息会被写到errors.txt中</span></span><br><span class="line">grep da * 2&gt; errors.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从errors.txt中读取输入</span></span><br><span class="line">less &lt; errors.txt</span><br></pre></td></tr></table></figure><h3 id="10-3-dev-null-文件"><a href="#10-3-dev-null-文件" class="headerlink" title="10.3. /dev/null 文件"></a>10.3. <code>/dev/null</code> 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null</span><br></pre></td></tr></table></figure><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="11-Debug"><a href="#11-Debug" class="headerlink" title="11. Debug"></a>11. Debug</h2><p>shell 提供了用于 debug 脚本的工具。</p><p>如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash options</span><br></pre></td></tr></table></figure><p>options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：</p><table><thead><tr><th>Short</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>-f</code></td><td>noglob</td><td>禁止文件名展开（globbing）</td></tr><tr><td><code>-i</code></td><td>interactive</td><td>让脚本以 <em>交互</em> 模式运行</td></tr><tr><td><code>-n</code></td><td>noexec</td><td>读取命令，但不执行（语法检查）</td></tr><tr><td><code>-t</code></td><td>—</td><td>执行完第一条命令后退出</td></tr><tr><td><code>-v</code></td><td>verbose</td><td>在执行每条命令前，向<code>stderr</code>输出该命令</td></tr><tr><td><code>-x</code></td><td>xtrace</td><td>在执行每条命令前，向<code>stderr</code>输出该命令以及该命令的扩展参数</td></tr></tbody></table><p>举个例子，如果我们在脚本中指定了<code>-x</code>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 3; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这会向<code>stdout</code>打印出变量的值和一些其它有用的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">+ (( i = 0 ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 0</span><br><span class="line">0</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 1</span><br><span class="line">1</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 2</span><br><span class="line">2</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br></pre></td></tr></table></figure><p>有时我们值需要 debug 脚本的一部分。这种情况下，使用<code>set</code>命令会很方便。这个命令可以启用或禁用选项。使用<code>-</code>启用选项，<code>+</code>禁用选项：</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/debug-demo.sh" target="_blank" rel="noopener">debug-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启 debug</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 3; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 关闭 debug</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  + (( i = 0 ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 0</span></span><br><span class="line"><span class="comment">#  0+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 1</span></span><br><span class="line"><span class="comment">#  1+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 2</span></span><br><span class="line"><span class="comment">#  2+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + set +x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span>; <span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\n"</span></span><br><span class="line"><span class="comment">#  Output: 12345</span></span><br></pre></td></tr></table></figure><h2 id="12-更多内容"><a href="#12-更多内容" class="headerlink" title="12. 更多内容"></a>12. 更多内容</h2><blockquote><p>📓 本文已归档到：<a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">notes</a></p></blockquote><ul><li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="noopener">awesome-shell</a>，shell 资源列表</li><li><a href="https://github.com/awesome-lists/awesome-bash" target="_blank" rel="noopener">awesome-bash</a>，bash 资源列表</li><li><a href="https://github.com/denysdovhan/bash-handbook" target="_blank" rel="noopener">bash-handbook</a></li><li><a href="https://github.com/vuuihc/bash-guide" target="_blank" rel="noopener">bash-guide</a> ，bash 基本用法指南</li><li><a href="https://github.com/Bash-it/bash-it" target="_blank" rel="noopener">bash-it</a>，为你日常使用，开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架</li><li><a href="http://dotfiles.github.io/" target="_blank" rel="noopener">dotfiles.github.io</a>，上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接</li><li><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Runoob Shell 教程</a></li><li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">shellcheck</a> 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li></ul><p>最后，Stack Overflow 上 <a href="https://stackoverflow.com/questions/tagged/bash" target="_blank" rel="noopener">bash 标签下</a>有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。</p><p><strong>作者原文链接: <a href="https://www.cnblogs.com/jingmoxukong/p/7867397.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingmoxukong/p/7867397.html</a></strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Stay hungry. Stay Foolish.</title>
    <url>/2020/03/18/Stay-hungry-Stay-Foolish/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><div id="article_content" class="article_content clearfix"><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css"><div id="content_views" class="markdown_views prism-atom-one-light"><svg xmlns="http://www.w3.org/2000/svg" style="display:none"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color:transparent"/></svg><p>Thank you. I am honored to be with you today at your commencement from one of the finest universities in the world. Truth be told, I never graduated from college. This is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.</p><p>很荣幸和大家一道参加这所世界上最好的一座大学的毕业典礼。我大学没毕业，说实话，这是我第一次离大学毕业典礼这么近。今天我想给大家讲三个我自己的故事，不讲别的，也不讲大道理，就讲三个故事。</p><p>The first story is about connecting the dots. I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?</p><p>第一个故事讲的是点与点之间的关系。我在里德学院(Reed College)只读了六个月就退学了，此后便在学校里旁听，又过了大约一年半，我彻底离开。那么，我为什么退学呢?</p><p>It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife.</p><p>这得从我出生前讲起。我的生母是一名年轻的未婚在校研究生，她决定将我送给别人收养。她非常希望收养我的是有大学学历的人，所以把一切都安排好了，我一出生就交给一对律师夫妇收养。</p><p>Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.”</p><p>没想到我落地的霎那间，那对夫妇却决定收养一名女孩。就这样，我的养父母─当时他们还在登记册上排队等着呢─半夜三更接到一个电话: “我们这儿有一个没人要的男婴，你们要么?”“当然要”他们回答。</p><p>My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.</p><p>但是，我的生母后来发现我的养母不是大学毕业生，我的养父甚至连中学都没有毕业，所以她拒绝在最后的收养文件上签字。不过，没过几个月她就心软了，因为我的养父母许诺日后一定送我上大学。</p><p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition.</p><p>17 年后，我真的进了大学。当时我很天真，选了一所学费几乎和斯坦福大学一样昂贵的学校，当工人的养父母倾其所有的积蓄为我支付了大学学费。</p><p>After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life.</p><p>读了六个月后，我却看不出上学有什么意义。我既不知道自己这一生想干什么，也不知道大学是否能够帮我弄明白自己想干什么。这时，我就要花光父母一辈子节省下来的钱了。</p><p>So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting。</p><p>所以，我决定退学，并且坚信日后会证明我这样做是对的。当年做出这个决定时心里直打鼓，但现在回想起来，这还真是我有生以来做出的最好的决定之一。从退学那一刻起，我就可以不再选那些我毫无兴趣的必修课，开始旁听一些看上去有意思的课。</p><p>It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5? deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p><p>那些日子一点儿都不浪漫。我没有宿舍，只能睡在朋友房间的地板上。我去退还可乐瓶，用那五分钱的押金来买吃的。每个星期天晚上我都要走七英里，到城那头的黑尔-科里施纳礼拜堂去，吃每周才能享用一次的美餐。我喜欢这样。我凭著好奇心和直觉所干的这些事情，有许多后来都证明是无价之宝。我给大家举个例子:</p><p>Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.</p><p>当时，里德学院的书法课大概是全国最好的。校园里所有的公告栏和每个抽屉标签上的字都写得非常漂亮。当时我已经退学，不用正常上课，所以我决定选一门书法课，学学怎么写好字。</p><p>I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.</p><p>我学习写带短截线和不带短截线的印刷字体，根据不同字母组合调整其间距，以及怎样把版式调整得好上加好。这门课太棒了，既有历史价值，又有艺术造诣，这一点科学就做不到，而我觉得它妙不可言。</p><p>None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac.</p><p>当时我并不指望书法在以后的生活中能有什么实用价值。但是，十年之后，我们在设计第一台 Macintosh 计算机时，它一下子浮现在我眼前。于是，我们把这些东西全都设计进了计算机中。</p><p>It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, its likely that no personal computer would have them.</p><p>这是第一台有这么漂亮的文字版式的计算机。要不是我当初在大学里偶然选了这么一门课，Macintosh 计算机绝不会有那么多种印刷字体或间距安排合理的字号。要不是 Windows 照搬了 Macintosh，个人电脑可能不会有这些字体和字号。</p><p>If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.</p><p>要不是退了学，我决不会碰巧选了这门书法课，个人电脑也可能不会有现在这些漂亮的版式了。当然，我在大学里不可能从这一点上看到它与将来的关系。十年之后再回头看，两者之间的关系就非常、非常清楚了。</p><p>Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something — your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.</p><p>你们同样不可能从现在这个点上看到将来；只有回头看时，才会发现它们之间的关系。所以，要相信这些点迟早会连接到一起。你们必须信赖某些东西─直觉、归宿、生命，还有业力，等等。这样做从来没有让我的希望落空过，而且还彻底改变了我的生活。</p><p>My second story is about love and loss. I was lucky — I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees.</p><p>我的第二个故事是关于好恶与得失。幸运的是，我在很小的时候就发现自己喜欢做什么。我在 20 岁时和沃兹在我父母的车库里办起了苹果公司。我们干得很卖力，十年后，苹果公司就从车库里我们两个人发展成为一个拥有 20 亿元资产、4,000 名员工的大企业。</p><p>We had just released our finest creation — the Macintosh — a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well.</p><p>那时，我们刚刚推出了我们最好的产品─ Macintosh 电脑─那是在第 9 年，我刚满 30 岁。可后来，我被解雇了。你怎么会被自己办的公司解雇呢?是这样，随著苹果公司越做越大，我们聘了一位我认为非常有才华的人与我一道管理公司。在开始的一年多里，一切都很顺利。</p><p>But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.</p><p>可是，随后我俩对公司前景的看法开始出现分歧，最后我俩反目了。这时，董事会站在了他那一边，所以在 30 岁那年，我离开了公司，而且这件事闹得满城风雨。我成年后的整个生活重心都没有了，这使我心力交瘁。</p><p>I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley.</p><p>一连几个月，我真的不知道应该怎么办。我感到自己给老一代的创业者丢了脸─因为我扔掉了交到自己手里的接力棒。我去见了戴维帕卡德和鲍勃.诺伊斯，想为把事情搞得这么糟糕说声道歉。这次失败弄得沸沸扬扬的，我甚至想过逃离硅谷。</p><p>But something slowly began to dawn on me — I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.</p><p>但是，渐渐地，我开始有了一个想法─我仍然热爱我过去做的一切。在苹果公司发生的这些风波丝毫没有改变这一点。我虽然被拒之门外，但我仍然深爱我的事业。于是，我决定从头开始。</p><p>I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.</p><p>虽然当时我并没有意识到，但事实证明，被苹果公司炒鱿鱼是我一生中碰到的最好的事情。尽管前景未卜，但从头开始的轻松感取代了保持成功的沉重感。这使我进入了一生中最富有创造力的时期之一。</p><p>During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.</p><p>在此后的五年里，我开了一家名叫 NeXT 的公司和一家叫皮克斯的公司，我还爱上一位了不起的女人，后来娶了她。皮克斯公司推出了世界上第一部用电脑制作的动画片《玩具总动员》(Toy Story)，它现在是全球最成功的动画制作室。</p><p>In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.</p><p>世道轮回，苹果公司买下 NeXT 后，我又回到了苹果公司，我们在 NeXT 公司开发的技术成了苹果公司这次重新崛起的核心。我和劳伦娜(Laurene)也建立了美满的家庭。</p><p>I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did.</p><p>我确信，如果不是被苹果公司解雇，这一切决不可能发生。这是一剂苦药，可我认为苦药利于病。有时生活会当头给你一棒，但不要灰心。我坚信让我一往无前的唯一力量就是我热爱我所做的一切。</p><p>You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do.</p><p>所以，一定得知道自己喜欢什么，选择爱人时如此，选择工作时同样如此。工作将是生活中的一大部分，让自己真正满意的唯一办法，是做自己认为是有意义的工作;做有意义的工作的唯一办法，是热爱自己的工作。</p><p>If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.</p><p>你们如果还没有发现自己喜欢什么，那就不断地去寻找，不要急于做出决定。就像一切要凭着感觉去做的事情一样，一旦找到了自己喜欢的事，感觉就会告诉你。就像任何一种美妙的东西，历久弥新。所以说，要不断地寻找，直到找到自己喜欢的东西。不要半途而废。</p><p>My third story is about death. When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something.</p><p>我的第三个故事与死亡有关。17 岁那年，我读到过这样一段话，大意是:“如果把每一天都当作生命的最后一天，总有一天你会如愿以偿。”我记住了这句话，从那时起，33 年过去了，我每天早晨都对着镜子自问: “假如今天是生命的最后一天，我还会去做今天要做的事吗?”如果一连许多天我的回答都是“不”，我知道自己应该有所改变了。</p><p>Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything — all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.</p><p>让我能够做出人生重大抉择的最主要办法是，记住生命随时都有可能结束。因为几乎所有的东西─所有对自身之外的希求、所有的尊严、所有对困窘和失败的恐惧─在死亡来临时都将不复存在，只剩下真正重要的东西。记住自己随时都会死去，这是我所知道的防止患得患失的最好方法。你已经一无所有了，还有什么理由不跟着自己的感觉走呢。</p><p>About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months.</p><p>大约一年前，我被诊断患了癌症。那天早上七点半，我做了一次扫描检查，结果清楚地表明我的胰腺上长了一个瘤子，可那时我连胰腺是什么还不知道呢!医生告诉我说，几乎可以确诊这是一种无法治愈的恶性肿瘤，我最多还能活 3 到 6 个月。</p><p>My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.</p><p>医生建议我回去把一切都安排好，其实这是在暗示“准备后事”。也就是说，把今后十年要跟孩子们说的事情在这几个月内嘱咐完;也就是说，把一切都安排妥当，尽可能不给家人留麻烦；也就是说，去跟大家诀别。</p><p>I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now.</p><p>那一整天里，我的脑子一直没离开这个诊断。到了晚上，我做了一次组织切片检查，他们把一个内窥镜通过喉咙穿过我的胃进入肠子，用针头在胰腺的瘤子上取了一些细胞组织。当时我用了麻醉剂，陪在一旁的妻子后来告诉我，医生在显微镜里看了细胞之后叫了起来，原来这是一种少见的可以通过外科手术治愈的恶性肿瘤。我做了手术，现在好了。</p><p>This was the closest I’ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share.</p><p>这是我和死神离得最近的一次，我希望也是今后几十年里最近的一次。有了这次经历之后，现在我可以更加实在地和你们谈论死亡，而不是纯粹纸上谈兵，那就是: 谁都不愿意死。就是那些想进天堂的人也不愿意死后再进。然而，死亡是我们共同的归宿，没人能摆脱。</p><p>No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.</p><p>我们注定会死，因为死亡很可能是生命最好的一项发明。它推进生命的变迁，旧的不去，新的不来。现在，你们就是新的，但在不久的将来，你们也会逐渐成为旧的，也会被淘汰。对不起，话说得太过分了，不过这是千真万确的。</p><p>Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.</p><p>你们的时间都有限，所以不要按照别人的意愿去活，这是浪费时间。不要囿于成见，那是在按照别人设想的结果而活。不要让别人观点的聒噪声淹没自己的心声。最主要的是，要有跟着自己感觉和直觉走的勇气。无论如何，感觉和直觉早就知道你到底想成为什么样的人，其他都是次要的。</p><p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch.</p><p>我年轻时有一本非常好的刊物，叫《全球概览》，这是我那代人的宝书之一，创办人名叫斯图尔特布兰德，就住在离这儿不远的门洛帕克市。他用诗一般的语言把刊物办得生动活泼。</p><p>This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.</p><p>那是 20 世纪 60 年代末，还没有个人电脑和桌面印刷系统，全靠打字机、剪刀和宝丽莱照相机。它就像一种纸质的 Google，却比 Google 早问世了 35 年。这份刊物太完美了，查阅手段齐备、构思不凡。</p><p>Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age.</p><p>斯图尔特和他的同事们出了好几期《全球概览》，到最后办不下去时，他们出了最后一期。那是 20 世纪 70 年代中期，我也就是你们现在的年纪。</p><p>On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself.</p><p>最后一期的封底上是一张清晨乡间小路的照片，就是那种爱冒险的人等在那儿搭便车的那种小路。照片下面写道: 求知若饥、虚心若愚。那是他们停刊前的告别语。求知若渴，大智若愚。这也是我一直想做到的。</p><p>And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish.</p><p>眼下正值诸位大学毕业、开始新生活之际，我同样愿大家：求知若饥、虚心若愚。</p><p><img src="https://img-blog.csdnimg.cn/20190922204331298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>TED</category>
      </categories>
      <tags>
        <tag>TED</tag>
      </tags>
  </entry>
  <entry>
    <title>python列表生成式</title>
    <url>/2020/03/05/python%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>举个例子，要生成list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>可以用<code>list(range(1, 11))</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>但如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>   L.append(x * x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure><p>三层和三层以上的循环就很少用到了。</p><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></span><br><span class="line">[<span class="string">'.emacs.d'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'Adlm'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, <span class="string">'Documents'</span>, <span class="string">'Downloads'</span>, <span class="string">'Library'</span>, <span class="string">'Movies'</span>, <span class="string">'Music'</span>, <span class="string">'Pictures'</span>, <span class="string">'Public'</span>, <span class="string">'VirtualBox VMs'</span>, <span class="string">'Workspace'</span>, <span class="string">'XCode'</span>]</span><br></pre></td></tr></table></figure><p><code>for</code>循环其实可以同时使用两个甚至多个变量，比如<code>dict</code>的<code>items()</code>可以同时迭代key和value：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span>    print(k, <span class="string">'='</span>, v)</span><br><span class="line">...</span><br><span class="line">y = B</span><br><span class="line">x = A</span><br><span class="line">z = C</span><br></pre></td></tr></table></figure><p>因此，列表生成式也可以使用两个变量来生成list：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br></pre></td></tr></table></figure><p>最后把一个list中所有的字符串变成小写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</span><br></pre></td></tr></table></figure><h3 id="if-…-else"><a href="#if-…-else" class="headerlink" title="if … else"></a>if … else</h3><p>使用列表生成式的时候，有些童鞋经常搞不清楚<code>if...else</code>的用法。</p><p>例如，以下代码正常输出偶数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>但是，我们不能在最后的<code>if</code>加上<code>else</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">                                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这是因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code>，否则如何筛选？</p><p>另一些童鞋发现把<code>if</code>写在<code>for</code>前面必须加<code>else</code>，否则报错：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">                       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这是因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">-7</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>上述<code>for</code>前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。</p><p>可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>git上传大文件或者PDF或者二进制文件无法上传</title>
    <url>/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><p><span style="color:red;background:#fff;font-size:15;font-family:字体">提醒：git commit –hard commit_id 会把commit对应的文件从本地库删除！谨慎使用此命令！</span></p><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>​ push大文件失败，在将大文件删除之后，其余小文件仍然受到之前大文件push失败的影响，无法正常push。</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><p>​ 需要将之前含有大文件的commit记录删除（全部删除）</p><h2 id="3-详细过程"><a href="#3-详细过程" class="headerlink" title="3. 详细过程"></a>3. 详细过程</h2><ol><li><p>将git切换到之前提交的git项目所在目录</p></li><li><p>使用<code>git log</code>命令查看commit的历史记录及其对应的commit_id，查看结果如图：</p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/1.JPG" alt="1.JPG"></p></li><li><p>复制commit_id，使用Ctrl+C退出log查看页面，进入正常git可输入命令界面，输入下面命令，使git回退到commit_id的状态。 <code>git reset --hard //前面3个单词不需改变，将改成对应的commit_id的值</code></p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/2.JPG" alt="2.JPG"></p></li><li><p>使用下列命令使本地和远程的内容都回退到commit_id对应的状态。 <code>git push origin HEAD --force //固定模式，不需要改变单词</code></p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/3.JPG" alt="3.JPG"></p></li></ol><h2 id="4-参数解释"><a href="#4-参数解释" class="headerlink" title="4. 参数解释"></a>4. 参数解释</h2><p>根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:</p><ul><li><p>git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息。</p></li><li><p>git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可。</p></li><li><p>git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容。</p></li><li><p>git status :查看未被传送到远程代码库的提交状态</p></li><li><p>git cherry -v 查看未被传送到远程代码库的提交描述和说明</p></li><li><p>git reset commit_id 撤销未被传送到远程代码库的提交</p></li><li><p>HEAD 最近一个提交</p></li><li><p>HEAD^ 上一次提交</p></li><li><p>每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到。</p></li></ul><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.douban.com/note/189603387/" target="_blank" rel="noopener">git 删除错误提交的commit</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>图解算法</title>
    <url>/2020/03/01/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><h1 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h1><h2 id="1-第一章-算法简介"><a href="#1-第一章-算法简介" class="headerlink" title="1. 第一章 算法简介"></a><strong>1. 第一章 算法简介</strong></h2><p>1.2 二分查找<br>二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。使用二分查找时，每次都排除一半的数字。<br>一般而言，对于包含n个元素的列表，用二分查找最多需要<strong>log2n</strong>步，而简单查找最多需要<strong>n</strong>步。仅当列表是有序的时候，二分查找才管用。<br>二分法代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list)—<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high: <span class="comment">#只要范围没有缩小到只包含一个元素，就检查中间的元素</span></span><br><span class="line">        mid = (low + high)</span><br><span class="line">        guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == item:  <span class="comment">#找到了元素</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:  <span class="comment">#猜的数字大了</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:            <span class="comment">#猜的数字小了</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>   <span class="comment">#没有指定的元素</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">3</span>)  <span class="comment"># =&gt; 1</span></span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">-1</span>)  <span class="comment"># =&gt; None</span></span><br></pre></td></tr></table></figure><p>1.2.2 运行时间<br>二分查找的运行时间为对数时间（或log时间）。简单查找的运行时间为线性时间。</p><p>1.3 大 O表示法<br>算法的运行时间以不同的速度增加。<br>大O表示法指出了算法有多快，大O表示法指的并非以秒为单位的速度。 大O表示法让你能够比较操作数，它指出了算法运行时间的增速。二分查找需要执行log n次操作，使用大O表示法，O(log n)。简单查找的运行时间为O(n)。大O表示法说的是最糟的情形。</p><p>1.3.4 一些常见的大 O 运行时间（“阶指幂对”）<br>O(log n)，也叫对数时间，这样的算法包括二分查找。<br>O(n)，也叫线性时间，这样的算法包括简单查找。<br>O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。<br>O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。<br>O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</p><blockquote><p>小结：<br>\1. 算法的速度指的并非时间，而是操作数的增速。谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。<br>\2. 算法的运行时间用大O表示法表示。 O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。 算法运行时间并不以秒为单位。<br>\3. 算法运行时间是从其增速的角度度量的。</p></blockquote><h2 id="2-第二章-选择排序"><a href="#2-第二章-选择排序" class="headerlink" title="2. 第二章 选择排序"></a><strong>2. 第二章 选择排序</strong></h2><p>2.1 内存的工作原理<br>计算机就像是很多抽屉的集合体，每个抽屉都有地址。<br>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——<strong>数组和链表</strong>。<br>2.2 数组和链表<br>使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。<br>需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。<br>需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。<br>2.2.3 术语<br>元素的位置称为索引。<br><img src="https://img-blog.csdn.net/20180702203705464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>2.2.4 在中间插入<br>需要在中间插入元素时，数组和链表哪个更好呢？使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。</p><p>2.3 选择排序<br>需要的总时间为 O(n × n)，即O(n2)。<br>代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSmallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ar</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    newArr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        smallest = findSmallest(arr)</span><br><span class="line">        newArr.append(arr.pop(smallest))</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line"><span class="keyword">print</span> selectionSort([<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><h2 id="3-第三章-递归"><a href="#3-第三章-递归" class="headerlink" title="3. 第三章 递归"></a><strong>3. 第三章 递归</strong></h2><p>3.2 基线条件和递归条件<br>编写递归函数时，必须告诉它何时停止递归。正因为如此， 每个递归函数都有两部分：基线条件（ base case）和递归条件（ recursive case） 。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br>代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">0</span>:   <span class="comment">#基线条件</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:    <span class="comment">#递归条件</span></span><br><span class="line">        countdown(i<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>3.3 栈<br>栈是一种简单的数据结构，栈有两种操作：压入（插入）和弹出（删除并读取）。<br>每当调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。这个栈用于存储多个函数的变量，被称为调用栈。 调用栈可能很长，这将占用大量的内存。所有函数调用都进入调用栈。</p><h2 id="4-第四章-快速排序"><a href="#4-第四章-快速排序" class="headerlink" title="4. 第四章 快速排序"></a><strong>4. 第四章 快速排序</strong></h2><p>4.1 分而治之<br>D&amp;C算法包括两个步骤：<br>(1) 找出基线条件，这种条件必须尽可能简单。<br>(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。<br>D&amp;C的工作原理：<br>(1) 找出简单的基线条件；<br>(2) 确定如何缩小问题的规模，使其符合基线条件。</p><p>快速排序的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"><span class="keyword">print</span> quicksort([<span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>4.3 再谈大 O 表示法<br>快速排序的独特之处在于，其速度取决于选择的基准值。选择排序，其运行时间为O(n2)，速度非常慢。<br><img src="https://img-blog.csdn.net/20180703205638308?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>合并排序（ merge sort） 的排序算法，其运行时间为O(n log n)。比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。<br>4.4 小结<br>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。<br>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。<br>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， O(log n)的速度比O(n)快得多。</p><h2 id="5-第五章-散列表"><a href="#5-第五章-散列表" class="headerlink" title="5. 第五章 散列表"></a><strong>5. 第五章 散列表</strong></h2><p>运行时间O(n)和O(log n)之间有天壤之别！</p><ol><li>散列函数总是将同样的输入映射到相同的索引。</li><li>散列函数将不同的输入映射到不同的索引。</li><li>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。</li></ol><p>散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。</p><p>5.2.3 将散列表用作缓存<br>缓存的工作原理：网站将数据记住，而不再重新计算。<br>缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！</p><blockquote><p>散列表适合用于：</p><ol><li>模拟映射关系；</li><li>防止重复；</li><li>缓存/记住数据，以免服务器再通过处理来生成它们。</li></ol></blockquote><p>5.3 冲突<br>冲突（ collision） ：给两个键分配的位置相同。<br>处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。<br>散列函数很重要，好的散列函数很少导致冲突。</p><p>5.4 性能<br>在平均情况下，散列表执行各种操作的时间都为O(1)。 O(1)被称为常量时间。简单查找的运行时间为线性时间。二分查找的速度更快，所需时间为对数时间。在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。<br>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。<br>因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：<br> 较低的填装因子；<br> 良好的散列函数。</p><h2 id="6-第六章-广度优先搜索（-breadth-first-search，-BFS）"><a href="#6-第六章-广度优先搜索（-breadth-first-search，-BFS）" class="headerlink" title="6. 第六章 广度优先搜索（ breadth-first search， BFS）"></a><strong>6. 第六章 广度优先搜索（ breadth-first search， BFS）</strong></h2><p>广度优先搜索让你能够找出两样东西之间的最短距离，广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。<br>第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？）<br>第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？）<br>使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。<br><strong>广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。</strong></p><p>6.3.2 队列<br>队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作： 入队和出队。<br><strong>队列是一种先进先出（ First In First Out， FIFO）的数据结构，而栈是一种后进先出（ Last InFirst Out， LIFO）的数据结构。</strong><br>运行时间<br>如果你在你的整个人际关系网中搜索芒果销售商，就意味着你将沿每条边前行（记住，边是从一个人到另一个人的箭头或连接），因此运行时间至少为O(边数)。<br>你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（ vertice）数， E为边数。<br>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。</p><h2 id="7-第七章-狄克斯特拉算法"><a href="#7-第七章-狄克斯特拉算法" class="headerlink" title="7. 第七章 狄克斯特拉算法"></a><strong>7. 第七章 狄克斯特拉算法</strong></h2><p>应用场景：路由协议选路<br>广度优先搜索，它找出的是段数最少的路径，狄克斯特拉算法（ Dijkstra’s algorithm）找的是最快的路径。广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是段数最少。<strong>在狄克斯特拉算法中，你给每段都分配了一个数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。</strong><br>狄克斯特拉算法包含4个步骤。<br>(1) 找出“代价最低”的节点，即可在最短时间内到达的节点。<br>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。<br>(3) 重复这个过程，直到对图中的每个节点都这样做了。<br>(4) 计算最终路径。<br>带权重的图称为加权图（ weighted graph），不带权重的图称为非加权图（unweighted graph）。<br>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。<strong>狄克斯特拉算法只适用于有向无环图</strong>。<br>最短路径指的并不一定是物理距离，也可能是让某种度量指标最小。如果有负权边，就不能使用狄克斯特拉算法。因为负权边会导致这种算法不管用。</p><blockquote><p>7.6 小结</p><ol><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径。</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ol></blockquote><h2 id="8-第八章-贪婪算法"><a href="#8-第八章-贪婪算法" class="headerlink" title="8. 第八章 贪婪算法"></a><strong>8. 第八章 贪婪算法</strong></h2><p>贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。<br>8.2 背包问题<br>在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。<br>背包问题就是有若干物品，每个物品有自己的价值和重量。背包有总重量。问题就是怎样将背包装的最大价值。背包问题也分很多种，贪心算法解决的是物品可以拆分的背包问题（就是物品可以分成几份装入）。这个问题用贪心还是比较好解决的。贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。此问题就是将每次的放入看成每一步，要想解决问题，就是将每一步都放入最优解。也就是说，每一次的放入都要放入最佳的选择。讲到这里，就要说一说最佳的选择，每一次的放入的最佳的选择就是每次放入的物品都是剩余的物品中价值最大且质量最小的，这里就要引入一个物品的属性，物品的权重值。物品的权重值就是指物品的价值除以物品的质量。所以，本问题的每一次的最佳选择就是每次都选出权重值最大的物品。<br>近似算法<br>在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：<br> 速度有多快；<br> 得到的近似解与最优解的接近程度。</p><p>8.4 NP 完全问题(Non-deterministic Polynomial多项式的不确定性)<br>NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。<br>如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。</p><p> 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。<br> 涉及“所有组合”的问题通常是NP完全问题。<br> 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。<br> 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。<br> 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。<br> 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</p><blockquote><p>8.5 小结</p><ol><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。</li><li>对于NP完全问题，还没有找到快速解决方案。</li><li>面临NP完全问题时，最佳的做法是使用近似算法。</li><li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li></ol></blockquote><h2 id="9-第九章-动态规划"><a href="#9-第九章-动态规划" class="headerlink" title="9. 第九章 动态规划"></a><strong>9. 第九章 动态规划</strong></h2><p>9.1.2 动态规划<br>动态规划先解决子问题，再逐步解决大问题。<br>对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。<br>每个动态规划算法都从一个网格开始，网格的各行为商品，各列为不同容量（ 1～4磅）的背包。所有这些列你都需要，因为它们将帮助你计算子背包的价值。<br>动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。 但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。</p><blockquote><ol><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。</li><li>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。要设计出动态规划解决方案可能很难，这正是本节要介绍的。下面是一些通用的小贴士。</li><li>每种动态规划解决方案都涉及网格。</li></ol></blockquote><p>9.3.1 绘制网格<br>对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。</p><blockquote><p>9.4 小结</p><ol><li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li><li>问题可分解为离散子问题时，可使用动态规划来解决。</li><li>每种动态规划解决方案都涉及网格。</li><li>单元格中的值通常就是你要优化的值。</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li><li>没有放之四海皆准的计算动态规划解决方案的公式。</li></ol></blockquote><h2 id="10-第十章-K最近邻算法"><a href="#10-第十章-K最近邻算法" class="headerlink" title="10. 第十章 K最近邻算法"></a><strong>10. 第十章 K最近邻算法</strong></h2><p>KNN可以用来做两项基本工作——分类和回归：</p><ol><li>分类就是编组；</li><li>回归就是预测结果（如一个数字）。</li></ol><p><strong>余弦相似度（ cosine similarity）</strong><br>余弦相似度不计算两个矢量的距离，而比较它们的角度。<br>余弦相似度。余弦相似度被广泛用于协同过滤算法中，尤其是Item-base的协同过滤。<br>余弦相似度衡量的是两个向量间的夹角大小，通过夹角的余弦值表示结果，假设A向量是（x1, y1），B向量是(x2, y2)，那么两个向量的余弦相似度为：</p><p>分子为向量A与向量B的点乘，分母为二者各自的L2相乘，即将所有维度值的平方相加后开方。 余弦相似度的取值为[-1,1]，值越大表示越相似。</p><p>10.3.1 OCR<br>OCR指的是光学字符识别（ optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。 一般而言， OCR算法提取线段、点和曲线等特征。<br>OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（ training）。大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。</p><p>10.3.2 创建垃圾邮件过滤器<br>垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（ Naive Bayes classifier）。</p><blockquote><p>10.4 小结</p><ol><li>KNN用于分类和回归，需要考虑最近的邻居。</li><li>分类就是编组。</li><li>回归就是预测结果（如数字）。</li><li>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。</li><li>能否挑选合适的特征事关KNN算法的成败。</li></ol></blockquote><h2 id="11-第十一章-接下来如何做"><a href="#11-第十一章-接下来如何做" class="headerlink" title="11. 第十一章 接下来如何做"></a><strong>11. 第十一章 接下来如何做</strong></h2><p>二叉查找树（ binary search tree）<br>在二叉查找树中查找节点时，平均运行时间为O(log n)，但在最糟的情况下所需时间为O(n)；而在有序数组中查找时，即便是在最糟情况下所需的时间也只有O(log n)，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。<br><img src="https://img-blog.csdn.net/2018070419575199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>二叉查找树也存在一些缺点，例如，不能随机访问，在二叉查找树处于平衡状态时，平均访问时间也为O(log n)。</p><p>11.2 反向索引<br>一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（ inverted index），常用于创建搜索引擎。</p><p>11.4 并行算法<br>并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。<br>并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。<br>负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易， 10秒钟就完成了，而分配给内核B的任务都很难， 1分钟才完成。这意味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？</p><p>11.5 MapReduce<br>MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（ map）函数和归并（ reduce）函数。<br>11.5.2 映射函数<br>映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。<br>11.5.3 归并函数<br>归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。<br>MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。<br>11.6 布隆过滤器和 HyperLogLog<br>布隆过滤器是一种概率型数据结构，布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况，前面所有的示例都是这样的。<br>HyperLogLog是一种类似于布隆过滤器的算法。<br>HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。<br>面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！</p><p>11.7 SHA 算法<br>另一种散列函数是安全散列算法（ secure hash algorithm， SHA）函数。给定一个字符串， SHA返回其散列值。<br>SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。对于每个不同的字符串， SHA生成的散列值都不同。<br>你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。</p><p><strong>斐波那契数列</strong><br>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p><p>递归方式实现斐波那契数列 前n项:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归方式实现 生成前20项</span></span><br><span class="line">lis =[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">0</span> <span class="keyword">or</span> i ==<span class="number">1</span>:<span class="comment">#第1,2项 都为1</span></span><br><span class="line">        lis.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lis.append(lis[i<span class="number">-2</span>]+lis[i<span class="number">-1</span>])<span class="comment">#从第3项开始每项值为前两项值之和</span></span><br><span class="line">print(lis)<span class="number">12345678</span></span><br><span class="line"> <span class="comment">#递归函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_function_tool</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Fibonacci_function_tool(n - <span class="number">1</span>) + Fibonacci_function_tool(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_function</span><span class="params">(n)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>): result_list.append(Fibonacci_function_tool(i))</span><br><span class="line">    <span class="keyword">return</span> result_list</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>学生管理系统</title>
    <url>/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><h1 id="学生管理系统"><a href="#学生管理系统" class="headerlink" title="学生管理系统"></a>学生管理系统</h1><h2 id="（第1阶段）学生信息管理系统部分截图"><a href="#（第1阶段）学生信息管理系统部分截图" class="headerlink" title="（第1阶段）学生信息管理系统部分截图"></a>（第1阶段）学生信息管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1-1.JPG" alt="1-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1-2.JPG" alt="1-2.JPG"></p><h2 id="（第2阶段）学生选课管理系统部分截图"><a href="#（第2阶段）学生选课管理系统部分截图" class="headerlink" title="（第2阶段）学生选课管理系统部分截图"></a>（第2阶段）学生选课管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-1.JPG" alt="2-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-2.JPG" alt="2-2.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-3.JPG" alt="2-3.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-4.JPG" alt="2-4.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-5.JPG" alt="2-5.JPG"></p><h2 id="（第3阶段）学生签到考勤系统截图-略"><a href="#（第3阶段）学生签到考勤系统截图-略" class="headerlink" title="（第3阶段）学生签到考勤系统截图(略)"></a>（第3阶段）学生签到考勤系统截图(略)</h2><h2 id="（第4阶段）学生成绩管理系统部分截图"><a href="#（第4阶段）学生成绩管理系统部分截图" class="headerlink" title="（第4阶段）学生成绩管理系统部分截图"></a>（第4阶段）学生成绩管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-1.JPG" alt="4-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-2.JPG" alt="4-2.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-3.JPG" alt="4-3.JPG"></p><h4 id="完整源代码和视频教学资源：百度云链接-百度网盘，提取码：3jbh"><a href="#完整源代码和视频教学资源：百度云链接-百度网盘，提取码：3jbh" class="headerlink" title="完整源代码和视频教学资源：百度云链接:百度网盘，提取码：3jbh"></a><strong><em>完整源代码和视频教学资源：百度云链接:<a href="https://pan.baidu.com/s/1vwebuzdVTBmSc-bHdbEnSg" target="_blank" rel="noopener">百度网盘</a>，提取码：3jbh</em></strong></h4><!-- rebuild by neat -->]]></content>
      <categories>
        <category>学生管理系统</category>
      </categories>
      <tags>
        <tag>学生管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, I am</title>
    <url>/2020/01/07/hello-world/</url>
    <content><![CDATA[<!-- build time:Mon Jun 22 2020 11:12:58 GMT+0800 (GMT+08:00) --><p>Welcome to Qing-Bei’s blog!</p><p>I am Qing-Bei, a contemporary college student and future programmer who loves programming and mining various technologies.I hope to find the answer in my heart through my own efforts.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hello World！</tag>
      </tags>
  </entry>
</search>
