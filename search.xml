<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基础环境搭建、HDFS|YARN伪分布式集群和Hadoop集群</title>
    <url>/2020/06/18/Hadoop%E5%92%8C%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<!-- build time:Wed Sep 16 2020 19:56:26 GMT+0800 (GMT+08:00) --><h1 id="1-基础环境搭建"><a href="#1-基础环境搭建" class="headerlink" title="1. 基础环境搭建"></a>1. 基础环境搭建</h1><h2 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h2><h4 id="（1）准备软件"><a href="#（1）准备软件" class="headerlink" title="（1）准备软件"></a>（1）准备软件</h4><p>JDK的安装包已经为大家准备好，在/root/software目录下。</p><h4 id="（2）解压压缩包"><a href="#（2）解压压缩包" class="headerlink" title="（2）解压压缩包"></a>（2）解压压缩包</h4><pre class=" language-shell">tar -zxvf jdk-8u221-linux-x64.tar.gz</code></pre><h4 id="（3）在此处我们配置系统环境变量，使用命令："><a href="#（3）在此处我们配置系统环境变量，使用命令：" class="headerlink" title="（3）在此处我们配置系统环境变量，使用命令："></a>（3）在此处我们配置<strong>系统环境变量</strong>，使用命令：</h4><pre><code class="shell">vim /etc/profile</code></pre><h4 id="（4）在最后加入以下两行内容："><a href="#（4）在最后加入以下两行内容：" class="headerlink" title="（4）在最后加入以下两行内容："></a>（4）在最后加入以下两行内容：</h4><pre><code class="shell"><code class="language-shell">tar -zxvf jdk-8u221-linux-x64.tar.gz</code></pre><h4 id="（3）在此处我们配置系统环境变量，使用命令："><a href="#（3）在此处我们配置系统环境变量，使用命令：" class="headerlink" title="（3）在此处我们配置系统环境变量，使用命令："></a>（3）在此处我们配置<strong>系统环境变量</strong>，使用命令：</h4><pre><code class="shell">vim /etc/profile</code></pre><h4 id="（4）在最后加入以下两行内容："><a href="#（4）在最后加入以下两行内容：" class="headerlink" title="（4）在最后加入以下两行内容："></a>（4）在最后加入以下两行内容：</h4><pre><code class="shell">export JAVA_HOME=/root/software/jdk1.8.0_221  # 配置Java的安装目录
export PATH=$PATH:$JAVA_HOME/bin  # 在原PATH的基础上加入JDK的bin目录</code></pre><h4 id="（5）让配置文件立即生效，使用如下命令："><a href="#（5）让配置文件立即生效，使用如下命令：" class="headerlink" title="（5）让配置文件立即生效，使用如下命令："></a>（5）<strong>让配置文件立即生效</strong>，使用如下命令：</h4><pre class=" language-shell">source /etc/profile</code></pre><h4 id="（6）检测JDK是否安装成功，使用命令查看JDK版本："><a href="#（6）检测JDK是否安装成功，使用命令查看JDK版本：" class="headerlink" title="（6）检测JDK是否安装成功，使用命令查看JDK版本："></a>（6）检测JDK是否安装成功，使用命令查看JDK版本：</h4><pre><code class="shell">java -version</code></pre><hr><h2 id="2-配置SSH免密登录"><a href="#2-配置SSH免密登录" class="headerlink" title="2. 配置SSH免密登录"></a>2. 配置SSH免密登录</h2><h4 id="（1）下载SSH服务并启动"><a href="#（1）下载SSH服务并启动" class="headerlink" title="（1）下载SSH服务并启动"></a>（1）下载SSH服务并启动</h4><p>SSH服务（openssh-server和openssh-clients）已经为大家下载好，所以此处直接启动即可：</p><pre><code class="shell">/usr/sbin/sshd</code></pre><p>SSH服务启动成功后，默认开启<strong>22（SSH的默认端口）端口号</strong>，可以使用以下命令进行查看：</p><pre><code class="shell">netstat -tnulp</code></pre><p>执行命令，可以看到<strong>22号端口</strong>已经开启，证明我们SSH服务启动成功：<br><img src="/images/load.png" data-original="http://assets.qingjiaoclass.com/image/20200206/8PJXrFA1Ij1580965846.png" alt="image.png"></p><h4 id="（2）首先生成密钥对，使用命令："><a href="#（2）首先生成密钥对，使用命令：" class="headerlink" title="（2）首先生成密钥对，使用命令："></a>（2）<strong>首先生成密钥对，使用命令：</strong></h4><pre><code class="shell"><code class="language-shell">source /etc/profile</code></pre><h4 id="（6）检测JDK是否安装成功，使用命令查看JDK版本："><a href="#（6）检测JDK是否安装成功，使用命令查看JDK版本：" class="headerlink" title="（6）检测JDK是否安装成功，使用命令查看JDK版本："></a>（6）检测JDK是否安装成功，使用命令查看JDK版本：</h4><pre><code class="shell">java -version</code></pre><hr><h2 id="2-配置SSH免密登录"><a href="#2-配置SSH免密登录" class="headerlink" title="2. 配置SSH免密登录"></a>2. 配置SSH免密登录</h2><h4 id="（1）下载SSH服务并启动"><a href="#（1）下载SSH服务并启动" class="headerlink" title="（1）下载SSH服务并启动"></a>（1）下载SSH服务并启动</h4><p>SSH服务（openssh-server和openssh-clients）已经为大家下载好，所以此处直接启动即可：</p><pre><code class="shell">/usr/sbin/sshd</code></pre><p>SSH服务启动成功后，默认开启<strong>22（SSH的默认端口）端口号</strong>，可以使用以下命令进行查看：</p><pre><code class="shell">netstat -tnulp</code></pre><p>执行命令，可以看到<strong>22号端口</strong>已经开启，证明我们SSH服务启动成功：<br><img src="/images/load.png" data-original="http://assets.qingjiaoclass.com/image/20200206/8PJXrFA1Ij1580965846.png" alt="image.png"></p><h4 id="（2）首先生成密钥对，使用命令："><a href="#（2）首先生成密钥对，使用命令：" class="headerlink" title="（2）首先生成密钥对，使用命令："></a>（2）<strong>首先生成密钥对，使用命令：</strong></h4><pre><code class="shell">ssh-keygen
## 或者
ssh-keygen -t rsa</code></pre><p>上面一种是简写形式，提示要输入信息时不需要输入任何东西，<strong>直接回车三次即可</strong>。</p><h4 id="（3）将公钥放置到授权列表文件-authorized-keys中，使用命令："><a href="#（3）将公钥放置到授权列表文件-authorized-keys中，使用命令：" class="headerlink" title="（3）将公钥放置到授权列表文件 authorized_keys中，使用命令："></a>（3）将公钥放置到<strong>授权列表文件 authorized_keys</strong>中，使用命令：</h4><pre class=" language-shell">cp id_rsa.pub authorized_keys</code></pre><h4 id="（4）修改授权列表文件-authorized-keys-的权限，使用命令："><a href="#（4）修改授权列表文件-authorized-keys-的权限，使用命令：" class="headerlink" title="（4）修改授权列表文件 authorized_keys 的权限，使用命令："></a>（4）修改授权列表文件 authorized_keys 的权限，使用命令：</h4><pre><code class="shell">chmod 600 authorized_keys</code></pre><h4 id="（5）验证免密登录是否配置成功，使用如下命令："><a href="#（5）验证免密登录是否配置成功，使用如下命令：" class="headerlink" title="（5）验证免密登录是否配置成功，使用如下命令："></a>（5）验证免密登录是否配置成功，使用如下命令：</h4><pre><code class="shell"><code class="language-shell">cp id_rsa.pub authorized_keys</code></pre><h4 id="（4）修改授权列表文件-authorized-keys-的权限，使用命令："><a href="#（4）修改授权列表文件-authorized-keys-的权限，使用命令：" class="headerlink" title="（4）修改授权列表文件 authorized_keys 的权限，使用命令："></a>（4）修改授权列表文件 authorized_keys 的权限，使用命令：</h4><pre><code class="shell">chmod 600 authorized_keys</code></pre><h4 id="（5）验证免密登录是否配置成功，使用如下命令："><a href="#（5）验证免密登录是否配置成功，使用如下命令：" class="headerlink" title="（5）验证免密登录是否配置成功，使用如下命令："></a>（5）验证免密登录是否配置成功，使用如下命令：</h4><pre><code class="shell">ssh localhost  
## 或者
ssh e2d670ea9ad7
## 或者
ssh 10.141.0.42</code></pre><h4 id="（6）远程登录成功后，若想退出，可以使用exit命令。"><a href="#（6）远程登录成功后，若想退出，可以使用exit命令。" class="headerlink" title="（6）远程登录成功后，若想退出，可以使用exit命令。"></a>（6）远程登录成功后，若想退出，可以使用<strong>exit</strong>命令。</h4><h1 id="2-HDFS伪分布式集群搭建"><a href="#2-HDFS伪分布式集群搭建" class="headerlink" title="2. HDFS伪分布式集群搭建"></a>2. HDFS伪分布式集群搭建</h1><h2 id="2-1-解压hadoop2-7-7安装包"><a href="#2-1-解压hadoop2-7-7安装包" class="headerlink" title="2.1. 解压hadoop2.7.7安装包"></a>2.1. 解压hadoop2.7.7安装包</h2><p>使用<code>cd</code>命令进入/root/software目录下，使用如下命令解压hadoop2.7.7安装包：</p><pre class=" language-shell">tar -zxvf hadoop-2.7.7.tar.gz</code></pre><h2 id="2-2-配置环境变量hadoop-env-sh"><a href="#2-2-配置环境变量hadoop-env-sh" class="headerlink" title="2.2 配置环境变量hadoop-env.sh"></a>2.2 配置环境变量hadoop-env.sh</h2><p>打开hadoop-env.sh文件：</p><pre><code class="shell">vim /root/software/hadoop-2.7.7/etc/hadoop/hadoop-env.sh</code></pre><p>找到JAVA_HOME参数位置，<strong>修改为本机安装的JDK的实际位置</strong>。</p><h2 id="2-3-配置核心组件core-site-xml"><a href="#2-3-配置核心组件core-site-xml" class="headerlink" title="2.3 配置核心组件core-site.xml"></a>2.3 配置核心组件core-site.xml</h2><p>使用如下命令<strong>打开“core-site.xml”文件</strong>：</p><pre><code class="shell">vim /root/software/hadoop-2.7.7/etc/hadoop/core-site.xml</code></pre><p>将下面的配置内容添加到 <code>&lt;configuration&gt;&lt;/configuration&gt;</code> 中间：</p><pre><code class="xml"><code class="language-shell">tar -zxvf hadoop-2.7.7.tar.gz</code></pre><h2 id="2-2-配置环境变量hadoop-env-sh"><a href="#2-2-配置环境变量hadoop-env-sh" class="headerlink" title="2.2 配置环境变量hadoop-env.sh"></a>2.2 配置环境变量hadoop-env.sh</h2><p>打开hadoop-env.sh文件：</p><pre><code class="shell">vim /root/software/hadoop-2.7.7/etc/hadoop/hadoop-env.sh</code></pre><p>找到JAVA_HOME参数位置，<strong>修改为本机安装的JDK的实际位置</strong>。</p><h2 id="2-3-配置核心组件core-site-xml"><a href="#2-3-配置核心组件core-site-xml" class="headerlink" title="2.3 配置核心组件core-site.xml"></a>2.3 配置核心组件core-site.xml</h2><p>使用如下命令<strong>打开“core-site.xml”文件</strong>：</p><pre><code class="shell">vim /root/software/hadoop-2.7.7/etc/hadoop/core-site.xml</code></pre><p>将下面的配置内容添加到 <code>&lt;configuration&gt;&lt;/configuration&gt;</code> 中间：</p><pre><code class="xml"><!-- HDFS集群中NameNode的URI（包括协议、主机名称、端口号），默认为 file:/// -->
<property>
<name>fs.defaultFS</name>
<!-- 用于指定NameNode的地址 -->
<value>hdfs://localhost:9000</value>
</property>
<!-- Hadoop运行时产生文件的临时存储目录 -->
<property>
<name>hadoop.tmp.dir</name>
<value>/root/hadoopData/temp</value>
</property></code></pre><h2 id="2-4-配置文件系统hdfs-site-xml"><a href="#2-4-配置文件系统hdfs-site-xml" class="headerlink" title="2.4 配置文件系统hdfs-site.xml"></a>2.4 配置文件系统hdfs-site.xml</h2><p>使用如下命令<strong>打开“hdfs-site.xml”文件</strong>：</p><pre class=" language-shell">vim /root/software/hadoop-2.7.7/etc/hadoop/hdfs-site.xml</code></pre><p>将下面的配置内容添加到 <code>&lt;configuration&gt;&lt;/configuration&gt;</code> 中间：</p><pre><code class="xml"><code class="language-shell">vim /root/software/hadoop-2.7.7/etc/hadoop/hdfs-site.xml</code></pre><p>将下面的配置内容添加到 <code>&lt;configuration&gt;&lt;/configuration&gt;</code> 中间：</p><pre><code class="xml"><!-- NameNode在本地文件系统中持久存储命名空间和事务日志的路径 -->
<property>
<name>dfs.namenode.name.dir</name>
<value>/root/hadoopData/name</value>
</property>
<!-- DataNode在本地文件系统中存放块的路径 -->
<property>
<name>dfs.datanode.data.dir</name>
<value>/root/hadoopData/data</value>
</property>
<!-- 数据块副本的数量，默认为3 -->
<property>
<name>dfs.replication</name>
<value>1</value>
</property></code></pre><h2 id="2-5-配置Hadoop系统环境变量"><a href="#2-5-配置Hadoop系统环境变量" class="headerlink" title="2.5 配置Hadoop系统环境变量"></a>2.5 配置Hadoop系统环境变量</h2><h4 id="1-首先打开-etc-profile文件（系统环境变量：对所有用户有效）："><a href="#1-首先打开-etc-profile文件（系统环境变量：对所有用户有效）：" class="headerlink" title="(1) 首先打开/etc/profile文件（系统环境变量：对所有用户有效）："></a>(1) 首先打开/etc/profile文件（系统环境变量：对所有用户有效）：</h4><pre class=" language-shell">vim /etc/profile</code></pre><h4 id="2-在文件底部添加如下内容："><a href="#2-在文件底部添加如下内容：" class="headerlink" title="(2) 在文件底部添加如下内容："></a>(2) 在文件底部添加如下内容：</h4><pre><code class="shell"><code class="language-shell">vim /etc/profile</code></pre><h4 id="2-在文件底部添加如下内容："><a href="#2-在文件底部添加如下内容：" class="headerlink" title="(2) 在文件底部添加如下内容："></a>(2) 在文件底部添加如下内容：</h4><pre><code class="shell"># 配置Hadoop的安装目录
export HADOOP_HOME=/root/software/hadoop-2.7.7
# 在原PATH的基础上加入Hadoop的bin和sbin目录
export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</code></pre><h4 id="3-让配置文件立即生效，使用如下命令："><a href="#3-让配置文件立即生效，使用如下命令：" class="headerlink" title="(3) 让配置文件立即生效，使用如下命令："></a>(3) 让配置文件立即生效，使用如下命令：</h4><pre class=" language-shell">source /etc/profile</code></pre><h4 id="4-检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本："><a href="#4-检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本：" class="headerlink" title="(4) 检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本："></a>(4) 检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本：</h4><pre><code class="shell">hadoop version</code></pre><h2 id="2-6-格式化文件系统"><a href="#2-6-格式化文件系统" class="headerlink" title="2.6 格式化文件系统"></a>2.6 格式化文件系统</h2><pre><code class="shell">hdfs namenode -format</code></pre><h2 id="2-7-脚本一键启动HDFS集群"><a href="#2-7-脚本一键启动HDFS集群" class="headerlink" title="2.7 脚本一键启动HDFS集群"></a>2.7 脚本一键启动HDFS集群</h2><pre><code class="shell">start-dfs.sh</code></pre><h2 id="2-8-查看进程启动情况"><a href="#2-8-查看进程启动情况" class="headerlink" title="2.8 查看进程启动情况"></a>2.8 查看进程启动情况</h2><p>在本机上执行 <code>jps</code> 命令查看进程启动情况。</p><h2 id="2-9-通过UI查看HDFS运行状态"><a href="#2-9-通过UI查看HDFS运行状态" class="headerlink" title="2.9 通过UI查看HDFS运行状态"></a>2.9 通过UI查看HDFS运行状态</h2><p>通过本机的浏览器访问<strong><a href="http://localhost:50070" target="_blank" rel="noopener">http://localhost:50070</a></strong>或<strong>http://本机IP地址:50070</strong>查看HDFS集群状态。</p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><p>成功搭建HDFS伪分布式集群，具体步骤如下：</p><ol><li>解压hadoop2.7.7安装包</li><li>配置环境变量hadoop-env.sh</li><li>配置核心组件core-site.xml</li><li>配置文件系统hdfs-site.xml</li><li>配置Hadoop系统环境变量</li><li>格式化文件系统</li><li>脚本一键启动HDFS集群</li><li>查看进程启动情况</li><li>通过UI查看HDFS运行状态</li></ol><h1 id="3-YARN伪分布式集群搭建"><a href="#3-YARN伪分布式集群搭建" class="headerlink" title="3. YARN伪分布式集群搭建"></a>3. YARN伪分布式集群搭建</h1><h2 id="3-1-配置环境变量yarn-env-sh"><a href="#3-1-配置环境变量yarn-env-sh" class="headerlink" title="3.1 配置环境变量yarn-env.sh"></a>3.1 配置环境变量yarn-env.sh</h2><p>使用如下命令打开“yarn-env.sh”文件：</p><pre><code class="shell">vim /root/software/hadoop-2.7.7/etc/hadoop/yarn-env.sh</code></pre><p>找到JAVA_HOME参数位置，将前面的#去掉，将其值修改为本机安装的JDK的实际位置。</p><h2 id="3-2-配置计算框架mapred-site-xml"><a href="#3-2-配置计算框架mapred-site-xml" class="headerlink" title="3.2 配置计算框架mapred-site.xml"></a>3.2 配置计算框架mapred-site.xml</h2><p>在$HADOOP_HOME/etc/hadoop/目录中默认没有该文件，需要先通过如下命令将文件<strong>复制并重命名为“mapred-site.xml”</strong>：</p><pre><code class="shell">cp mapred-site.xml.template mapred-site.xml</code></pre><p>接着，打开“mapred-site.xml”文件进行修改：</p><pre><code class="shell">vim /root/software/hadoop-2.7.7/etc/hadoop/mapred-site.xml</code></pre><p>将下面的配置内容添加到 中间：</p><pre><code class="xml"><code class="language-shell">source /etc/profile</code></pre><h4 id="4-检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本："><a href="#4-检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本：" class="headerlink" title="(4) 检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本："></a>(4) 检测Hadoop环境变量是否设置成功，使用如下命令查看Hadoop版本：</h4><pre><code class="shell">hadoop version</code></pre><h2 id="2-6-格式化文件系统"><a href="#2-6-格式化文件系统" class="headerlink" title="2.6 格式化文件系统"></a>2.6 格式化文件系统</h2><pre><code class="shell">hdfs namenode -format</code></pre><h2 id="2-7-脚本一键启动HDFS集群"><a href="#2-7-脚本一键启动HDFS集群" class="headerlink" title="2.7 脚本一键启动HDFS集群"></a>2.7 脚本一键启动HDFS集群</h2><pre><code class="shell">start-dfs.sh</code></pre><h2 id="2-8-查看进程启动情况"><a href="#2-8-查看进程启动情况" class="headerlink" title="2.8 查看进程启动情况"></a>2.8 查看进程启动情况</h2><p>在本机上执行 <code>jps</code> 命令查看进程启动情况。</p><h2 id="2-9-通过UI查看HDFS运行状态"><a href="#2-9-通过UI查看HDFS运行状态" class="headerlink" title="2.9 通过UI查看HDFS运行状态"></a>2.9 通过UI查看HDFS运行状态</h2><p>通过本机的浏览器访问<strong><a href="http://localhost:50070" target="_blank" rel="noopener">http://localhost:50070</a></strong>或<strong>http://本机IP地址:50070</strong>查看HDFS集群状态。</p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><p>成功搭建HDFS伪分布式集群，具体步骤如下：</p><ol><li>解压hadoop2.7.7安装包</li><li>配置环境变量hadoop-env.sh</li><li>配置核心组件core-site.xml</li><li>配置文件系统hdfs-site.xml</li><li>配置Hadoop系统环境变量</li><li>格式化文件系统</li><li>脚本一键启动HDFS集群</li><li>查看进程启动情况</li><li>通过UI查看HDFS运行状态</li></ol><h1 id="3-YARN伪分布式集群搭建"><a href="#3-YARN伪分布式集群搭建" class="headerlink" title="3. YARN伪分布式集群搭建"></a>3. YARN伪分布式集群搭建</h1><h2 id="3-1-配置环境变量yarn-env-sh"><a href="#3-1-配置环境变量yarn-env-sh" class="headerlink" title="3.1 配置环境变量yarn-env.sh"></a>3.1 配置环境变量yarn-env.sh</h2><p>使用如下命令打开“yarn-env.sh”文件：</p><pre><code class="shell">vim /root/software/hadoop-2.7.7/etc/hadoop/yarn-env.sh</code></pre><p>找到JAVA_HOME参数位置，将前面的#去掉，将其值修改为本机安装的JDK的实际位置。</p><h2 id="3-2-配置计算框架mapred-site-xml"><a href="#3-2-配置计算框架mapred-site-xml" class="headerlink" title="3.2 配置计算框架mapred-site.xml"></a>3.2 配置计算框架mapred-site.xml</h2><p>在$HADOOP_HOME/etc/hadoop/目录中默认没有该文件，需要先通过如下命令将文件<strong>复制并重命名为“mapred-site.xml”</strong>：</p><pre><code class="shell">cp mapred-site.xml.template mapred-site.xml</code></pre><p>接着，打开“mapred-site.xml”文件进行修改：</p><pre><code class="shell">vim /root/software/hadoop-2.7.7/etc/hadoop/mapred-site.xml</code></pre><p>将下面的配置内容添加到 中间：</p><pre><code class="xml"><!-- 指定使用 YARN 运行 MapReduce 程序，默认为 local -->
<property>
<name>mapreduce.framework.name</name>
<value>yarn</value>
</property></code></pre><h2 id="3-3-配置YARN系统yarn-site-xml"><a href="#3-3-配置YARN系统yarn-site-xml" class="headerlink" title="3.3 配置YARN系统yarn-site.xml"></a>3.3 配置YARN系统yarn-site.xml</h2><p>使用如下命令打开该配置文件：</p><pre class=" language-shell">vim /root/software/hadoop-2.7.7/etc/hadoop/yarn-site.xml</code></pre><p>将下面的配置内容加入 中间：</p><pre><code class="xml"><code class="language-shell">vim /root/software/hadoop-2.7.7/etc/hadoop/yarn-site.xml</code></pre><p>将下面的配置内容加入 中间：</p><pre><code class="xml"><!-- NodeManager上运行的附属服务，也可以理解为 reduce 获取数据的方式 -->
<property>
<name>yarn.nodemanager.aux-services</name>
<value>mapreduce_shuffle</value>
</property></code></pre><h2 id="3-4-脚本一键启动YARN集群"><a href="#3-4-脚本一键启动YARN集群" class="headerlink" title="3.4 脚本一键启动YARN集群"></a>3.4 脚本一键启动YARN集群</h2><pre class=" language-shell">start-yarn.sh</code></pre><h2 id="3-5-查看进程启动情况"><a href="#3-5-查看进程启动情况" class="headerlink" title="3.5 查看进程启动情况"></a>3.5 查看进程启动情况</h2><p>在本机上执行 <code>jps</code> 命令查看进程启动情况。</p><h2 id="3-6-通过UI查看YARN运行状态"><a href="#3-6-通过UI查看YARN运行状态" class="headerlink" title="3.6 通过UI查看YARN运行状态"></a>3.6 通过UI查看YARN运行状态</h2><p>通过本机的浏览器访问<strong><a href="http://localhost:8088" target="_blank" rel="noopener">http://localhost:8088</a></strong>或<strong>http://本机IP地址:8088</strong>查看YARN集群状态。</p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><p>成功搭建YARN伪分布式集群，具体步骤如下：</p><ol><li>配置环境变量yarn-env.sh</li><li>配置计算框架 mapred-site.xml</li><li>配置 YARN 系统 yarn-site.xml</li><li>脚本一键启动YARN集群</li><li>查看进程启动情况</li><li>通过UI查看YARN运行状态</li></ol><h1 id="4-Hadoop集群"><a href="#4-Hadoop集群" class="headerlink" title="4. Hadoop集群"></a>4. Hadoop集群</h1><h2 id="4-1-启动Hadoop集群"><a href="#4-1-启动Hadoop集群" class="headerlink" title="4.1 启动Hadoop集群"></a>4.1 启动Hadoop集群</h2><p><strong>（1）HDFS集群</strong><br>在本机上使用如下方式<strong>一键启动HDFS集群</strong>：</p><pre><code class="shell">start-dfs.sh</code></pre><p><strong>（2）YARN集群</strong><br>在本机上使用如下方式<strong>一键启动YARN集群</strong>：</p><pre><code class="shell">start-yarn.sh</code></pre><hr><h2 id="4-2-WordCount示例执行流程"><a href="#4-2-WordCount示例执行流程" class="headerlink" title="4.2 WordCount示例执行流程"><code class="language-shell">start-yarn.sh</code></pre><h2 id="3-5-查看进程启动情况"><a href="#3-5-查看进程启动情况" class="headerlink" title="3.5 查看进程启动情况"></a>3.5 查看进程启动情况</h2><p>在本机上执行 <code>jps</code> 命令查看进程启动情况。</p><h2 id="3-6-通过UI查看YARN运行状态"><a href="#3-6-通过UI查看YARN运行状态" class="headerlink" title="3.6 通过UI查看YARN运行状态"></a>3.6 通过UI查看YARN运行状态</h2><p>通过本机的浏览器访问<strong><a href="http://localhost:8088" target="_blank" rel="noopener">http://localhost:8088</a></strong>或<strong>http://本机IP地址:8088</strong>查看YARN集群状态。</p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><p>成功搭建YARN伪分布式集群，具体步骤如下：</p><ol><li>配置环境变量yarn-env.sh</li><li>配置计算框架 mapred-site.xml</li><li>配置 YARN 系统 yarn-site.xml</li><li>脚本一键启动YARN集群</li><li>查看进程启动情况</li><li>通过UI查看YARN运行状态</li></ol><h1 id="4-Hadoop集群"><a href="#4-Hadoop集群" class="headerlink" title="4. Hadoop集群"></a>4. Hadoop集群</h1><h2 id="4-1-启动Hadoop集群"><a href="#4-1-启动Hadoop集群" class="headerlink" title="4.1 启动Hadoop集群"></a>4.1 启动Hadoop集群</h2><p><strong>（1）HDFS集群</strong><br>在本机上使用如下方式<strong>一键启动HDFS集群</strong>：</p><pre><code class="shell">start-dfs.sh</code></pre><p><strong>（2）YARN集群</strong><br>在本机上使用如下方式<strong>一键启动YARN集群</strong>：</p><pre><code class="shell">start-yarn.sh</code></pre><hr><h2 id="4-2-WordCount示例执行流程"><a href="#4-2-WordCount示例执行流程" class="headerlink" title="4.2 WordCount示例执行流程"></a>4.2 WordCount示例执行流程</h2><p>（1）在本机桌面（/headless/Desktop）上创建一个名为inputdata的文件夹，在此文件夹下新建一个名为word.txt的文本文件，内容如下：</p><pre><code>hadoop jar hadoop mapreduce
hadoop hdfs
hdfs hadoop jar fs
fs</code></pre><p>注意单词之间用<strong>空格</strong>进行分隔。</p><p>（2）接着，在HDFS上创建/wordcount/input目录，并将word.txt文件上传至该目录下，具体指令如下所示：</p><pre class=" language-shell"><code class="language-shell"> hadoop fs -mkdir -p /wordcount/input
 hadoop fs -put /headless/Desktop/word.txt /wordcount/input</code></pre><p>（3）进入<code>$HADOOP_HOME/share/hadoop/mapreduce/</code>目录下，使用hadoop-mapreduce-examples-2.7.7.jar示例包，对HDFS上的word.txt文件进行单词统计，在jar包位置执行如下命令：</p><pre class=" language-shell"><code class="language-shell">hadoop jar hadoop-mapreduce-examples-2.7.7.jar wordcount \ 
/headless/Desktop/word.txt /wordcount/output</code></pre><p><strong>注意：\为换行指令（可以写成一行，不使用换行符）</strong></p><p>（4）程序执行成功后，我们可以使用HDFS Shell的相关指令查看part-r-00000的内容，具体指令如下所示：</p><pre class=" language-shell">hadoop fs -cat /wordcount/output/part-r-00000</code></pre><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"><code class="language-shell">hadoop fs -cat /wordcount/output/part-r-00000</code></pre><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><p><strong>执行WordCount示例，要求如下：</strong></p><p>(1) 在本机桌面（/headless/Desktop）上创建一个名为inputdata的文件夹，在此文件夹下新建一个名为word.txt的文本文件，内容如下：</p><pre><code>hadoop jar hadoop mapreduce
hadoop hdfs
hdfs hadoop jar fs
fs</code></pre><p>(2) 将word.txt上传到HDFS的/wordcount/input（若没有则需手动创建） 目录下，作为WordCount示例的数据源。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>linux</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Python bcrypy模块</title>
    <url>/2020/07/10/Python%20bcrypt%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="Python-bcrypt模块"><a href="#Python-bcrypt模块" class="headerlink" title="Python bcrypt模块"></a>Python bcrypt模块</h1><p>bcrypt 库：对 Python 中的密码进行哈希处理。 它定义了基本术语，包括加密，哈希和盐。</p><p>Python <code>bcrypt</code>模块是一个用于在 Python 中生成强哈希值的库。 它通过<code>pip install bcrypt</code>命令安装。</p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>加密是对消息或信息进行编码的过程，以使只有授权人员才能使用相应的键读取消息或信息，而未经授权的人员则不能。 预期的信息或消息，称为纯文本，使用加密算法-密码-加密，生成密文，只有解密后才能读取。 加密是一种双向功能。 当我们加密某些东西时，我们这样做是为了以后对其进行解密。 加密用于传输时保护数据； 例如 在邮件通讯中。</p><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>哈希是使用算法将任意大小的数据映射到固定长度的过程。 这称为哈希值。 加密是一种双向功能，而散列是一种单向功能。 尽管在技术上可以反向散列值，但所需的计算能力使其不可行。 加密是为了保护传输中的数据，而散列是为了验证数据没有被更改并且是真实的。</p><blockquote><p><strong>注意:</strong> 哈希不限于安全性，它还用于比较大量数据或快速键查找。</p></blockquote><p>密码不是以纯文本格式存储在数据库中，而是以散列值存储。</p><h2 id="盐"><a href="#盐" class="headerlink" title="盐"></a>盐</h2><p>盐是固定长度的加密强度强的随机值，将其添加到哈希函数的输入中以为每个输入创建唯一的哈希。 添加盐可以使密码哈希输出唯一，即使对于采用通用密码的用户也是如此。</p><h2 id="bcrypt-哈希函数"><a href="#bcrypt-哈希函数" class="headerlink" title="bcrypt 哈希函数"></a>bcrypt 哈希函数</h2><p>bcrypt 是 Niels Provos 和 DavidMazières 基于 Blowfish 密码设计的密码哈希功能。 bcrypt 函数是 OpenBSD 的默认密码哈希算法。 有针对 C，C++ ，C# ，Java，JavaScript，PHP，Python 和其他语言的 bcrypt 实现。</p><p>bcrypt 算法使用强大的加密技术为我们创建哈希并加盐。 该算法的计算成本是参数化的，因此随着计算机变得越来越快，它可能会增加。 计算成本被称为工作因子或成本因子。 它减慢了散列的速度，使暴力破解的尝试越来越难。 随着计算机变得越来越快，最佳成本因数会随着时间而变化。 高成本因素的缺点是增加了系统资源的负载并影响了用户体验。</p><h2 id="Python-bcrypt-创建哈希密码"><a href="#Python-bcrypt-创建哈希密码" class="headerlink" title="Python bcrypt 创建哈希密码"></a>Python bcrypt 创建哈希密码</h2><p>在下一个示例中，我们创建一个哈希密码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create_hashed_password.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">b's$cret12'</span></span><br><span class="line"></span><br><span class="line">salt = bcrypt.gensalt()</span><br><span class="line">hashed = bcrypt.hashpw(passwd, salt)</span><br><span class="line"></span><br><span class="line">print(salt)</span><br><span class="line">print(hashed)</span><br></pre></td></tr></table></figure><p>该示例使用 bcrypt 创建一个 salt 和一个哈希密码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bcrypt</span><br></pre></td></tr></table></figure><p>我们导入<code>bcrypt</code>模块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">salt = bcrypt.gensalt()</span><br></pre></td></tr></table></figure><p>用<code>gensalt()</code>功能生成盐。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hashed = bcrypt.hashpw(passwd, salt)</span><br></pre></td></tr></table></figure><p>使用<code>hashpw()</code>函数创建一个哈希值，该函数将明文值和盐作为参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python first.py</span><br><span class="line"><span class="string">b'$2b$12$mwSIOyxLJid1jFLgnU0s0.'</span></span><br><span class="line"><span class="string">b'$2b$12$mwSIOyxLJid1jFLgnU0s0.7pmzp8Mtx.GEO30x0AbI2v8r2sb98Cy'</span></span><br><span class="line">$ python first.py</span><br><span class="line"><span class="string">b'$2b$12$MgGs11HIXGkg1Bm1Epw0Du'</span></span><br><span class="line"><span class="string">b'$2b$12$MgGs11HIXGkg1Bm1Epw0Du20TV8ppi2Latgq7kKng8UjM5ZFWKKeS'</span></span><br></pre></td></tr></table></figure><p>请注意，盐是生成的哈希值的第一部分。 还要注意，每次生成唯一的 salt 和哈希值。</p><h2 id="Python-bcrypt-检查密码"><a href="#Python-bcrypt-检查密码" class="headerlink" title="Python bcrypt 检查密码"></a>Python bcrypt 检查密码</h2><p>下面的示例根据哈希值检查密码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">check_passwd.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">b's$cret12'</span></span><br><span class="line"></span><br><span class="line">salt = bcrypt.gensalt()</span><br><span class="line">hashed = bcrypt.hashpw(passwd, salt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bcrypt.checkpw(passwd, hashed):</span><br><span class="line">    print(<span class="string">"match"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"does not match"</span>)</span><br></pre></td></tr></table></figure><p>使用<code>checkpw()</code>功能检查密码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python check_passwd.py</span><br><span class="line">match</span><br></pre></td></tr></table></figure><h2 id="Python-bcrypt-成本因子"><a href="#Python-bcrypt-成本因子" class="headerlink" title="Python bcrypt 成本因子"></a>Python bcrypt 成本因子</h2><p>成本因子通过减慢散列来提高安全性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cost_factor.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">b's$cret12'</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">salt = bcrypt.gensalt(rounds=<span class="number">16</span>)</span><br><span class="line">hashed = bcrypt.hashpw(passwd, salt)</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">print(end - start)</span><br><span class="line"></span><br><span class="line">print(hashed)</span><br></pre></td></tr></table></figure><p>我们使用<code>rounds</code>参数将成本因子设置为 16。 我们测量生成 passowrd 哈希的时间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ cost_factor.py</span><br><span class="line"><span class="number">4.268407821655273</span></span><br><span class="line"><span class="string">b'$2b$16$.1FczuSNl2iXHmLojhwBZO9vCfA5HIqrONkefhvn2qLQpth3r7Jwe'</span></span><br></pre></td></tr></table></figure><p>花费超过四秒钟的时间来生成具有指定成本因子的哈希值。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python 模块</category>
        <category>加密</category>
      </categories>
      <tags>
        <tag>bcrypt</tag>
        <tag>加密</tag>
        <tag>python模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive内嵌安装、本地安装和常见属性配置</title>
    <url>/2020/06/18/Hive%E5%86%85%E5%B5%8C%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="Hive内嵌模式安装"><a href="#Hive内嵌模式安装" class="headerlink" title="Hive内嵌模式安装"></a>Hive内嵌模式安装</h1><h3 id="一、-Hive-安装"><a href="#一、-Hive-安装" class="headerlink" title="一、 Hive 安装"></a>一、 Hive 安装</h3><h4 id="1-解压安装包"><a href="#1-解压安装包" class="headerlink" title="1. 解压安装包"></a>1. 解压安装包</h4><p>现在已经为大家下载好了 hive2.3.4 的安装包，存放在 /root/software 目录下，首先进入此目录下，使用如下命令进行解压即可使用：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-hive-2.3.4-bin.tar.gz</span><br></pre></td></tr></table></figure><p>将其<strong>解压到当前目录下</strong>，即 /root/software 中。</p><h4 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h4><p>（1）首先打开 /etc/profile 文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>（2）将以下内容添加到配置文件的底部，添加完成输入“:wq”保存退出：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置Hive的安装目录   </span></span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/root/software/apache-hive-2.3.4-bin  </span><br><span class="line"><span class="comment"># 在原PATH的基础上加入Hive的bin目录  </span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HIVE_HOME</span>/bin</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>export 是把这两个变量导出为全局变量。</li><li>大小写必须严格区分。</li></ul><p>（3）让<strong>配置文件立即生效</strong>，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>（4）检测 Hive 环境变量是否设置成功，使用如下命令<strong>查看 Hive 版本</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive --version</span><br></pre></td></tr></table></figure><p>执行此命令后，若是出现 Hive 版本信息说明配置成功：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200429/jyqngavd_zuGmJHeBbqJLBA0Dk23M" alt="img"></p><h3 id="二、内嵌模式安装"><a href="#二、内嵌模式安装" class="headerlink" title="二、内嵌模式安装"></a>二、内嵌模式安装</h3><h4 id="1-修改配置文件-hive-env-sh"><a href="#1-修改配置文件-hive-env-sh" class="headerlink" title="1. 修改配置文件 hive-env.sh"></a>1. 修改配置文件 hive-env.sh</h4><p>切换到 ${HIVE_HOME}/conf 目录下，将 hive-env.sh.template 文件<strong>复制一份并重命名</strong>为 hive-env.sh：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure><p>修改完成，使用 <strong>vi 编辑器</strong>进行编辑：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim hive-env.sh</span><br></pre></td></tr></table></figure><p>在文件中配置 <strong>HADOOP_HOME</strong>、<strong>HIVE_CONF_DIR</strong> 以及<strong>HIVE_AUX_JARS_PATH</strong> 参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置Hadoop安装路径  </span></span><br><span class="line">HADOOP_HOME=/root/software/hadoop-2.7.7  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 配置Hive配置文件存放路径  </span></span><br><span class="line"><span class="built_in">export</span> HIVE_CONF_DIR=/root/software/apache-hive-2.3.4-bin/conf  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 配置Hive运行资源库路径  </span></span><br><span class="line"><span class="built_in">export</span> HIVE_AUX_JARS_PATH=/root/software/apache-hive-2.3.4-bin/lib</span><br></pre></td></tr></table></figure><p>配置完成，输入“:wq”保存退出。</p><h4 id="2-初始化元数据库"><a href="#2-初始化元数据库" class="headerlink" title="2. 初始化元数据库"></a>2. 初始化元数据库</h4><p>注意：当使用的 Hive 是 2.x 之前的版本时，不做初始化也是 OK 的。Hive 第一次启动时会自动进行初始化，只不过不会生成足够多的元数据库的表，其它的在使用过程中会慢慢生成。<strong>如果使用的是 2.x 版本的 Hive，那么就必须手动初始化元数据库。</strong> 使用如下命令进行初始化，这里我们使用 <strong>Hive 默认的 db 类型 “derby”</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">schematool -dbType derby -initSchema</span><br></pre></td></tr></table></figure><p>若是出现“schemaTool completed”则初始化成功，如下图所示：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200429/jyqngavd_G8Xxnwsc5uQUpcoRyLde" alt="img"></p><p>初始化完成，会在当前目录下生成一个 <strong>derby.log 文件</strong>和一个 <strong>metastore_db 目录</strong>。</p><h4 id="3-Hive-连接"><a href="#3-Hive-连接" class="headerlink" title="3. Hive 连接"></a>3. Hive 连接</h4><p>在此目录下使用 Hive 的三种连接方式之一：<strong>CLI 启动 Hive</strong>。由于已经在环境变量中配置了 HIVE_HOME ，所以这里直接在命令行执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive  </span><br><span class="line">或者  </span><br><span class="line">hive --service cli</span><br></pre></td></tr></table></figure><p>效果如下图所示：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200429/jyqngavd_UqYh1yVMrVj1q3NtCxjg" alt="img"></p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><h4 id="Hive-内嵌模式安装，具体步骤如下："><a href="#Hive-内嵌模式安装，具体步骤如下：" class="headerlink" title="Hive 内嵌模式安装，具体步骤如下："></a>Hive 内嵌模式安装，具体步骤如下：</h4><p><strong>1. Hive安装</strong><br>（1）解压安装包<br>（2）配置环境变量</p><p><strong>2. 内嵌模式安装</strong><br>（1）修改配置文件hive-env.sh<br>（2）初始化元数据库<br>（3）Hive 连接</p><h1 id="Hive本地安装"><a href="#Hive本地安装" class="headerlink" title="Hive本地安装"></a>Hive本地安装</h1><h2 id="任务1：安装-MySQL"><a href="#任务1：安装-MySQL" class="headerlink" title="任务1：安装 MySQL"></a>任务1：安装 MySQL</h2><h3 id="1-1-解压安装包"><a href="#1-1-解压安装包" class="headerlink" title="1.1 解压安装包"></a>1.1 解压安装包</h3><p>现在已经为大家下载好了 MySQL 5.7.25 的安装包，存放在 /root/software 目录下，首先进入此目录下，使用如下命令进行解压即可使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure><p>将其解压到当前目录下，即 /root/software 中。</p><h3 id="1-2-安装-MySQL-组件"><a href="#1-2-安装-MySQL-组件" class="headerlink" title="1.2 安装 MySQL 组件"></a>1.2 安装 MySQL 组件</h3><p>使用 <code>rpm -ivh</code> 命令依次安装以下组件：</p><p>（1）首先安装mysql-community-common （服务器和客户端库的公共文件），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（2）其次安装mysql-community-libs（MySQL数据库客户端应用程序的共享库），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（3）之后安装 mysql-community-libs-compat（MySQL 之前版本的共享兼容库），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（4）之后安装 mysql-community-client（MySQL客户端应用程序和工具），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（5）最后安装 mysql-community-server（数据库服务器和相关工具），使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="1-3-登录-MySQL"><a href="#1-3-登录-MySQL" class="headerlink" title="1.3 登录 MySQL"></a>1.3 登录 MySQL</h3><h4 id="1-初始化-MySQL-的数据库"><a href="#1-初始化-MySQL-的数据库" class="headerlink" title="1. 初始化 MySQL 的数据库"></a>1. 初始化 MySQL 的数据库</h4><p>安装好 MySQL 后，我们需要初始化数据库，初始化和启动数据库时最好不要使用root用户，而是使用mysql用户启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld --initialize-insecure --user&#x3D;mysql</span><br></pre></td></tr></table></figure><h4 id="2-启动-MySQL-服务"><a href="#2-启动-MySQL-服务" class="headerlink" title="2. 启动 MySQL 服务"></a>2. 启动 MySQL 服务</h4><p>使用如下命令<strong>开启 MySQL 服务</strong>，让其在后台运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld --user&#x3D;mysql &amp;</span><br></pre></td></tr></table></figure><p>说明：一定要加“&amp;”，才能脚本放到后台运行。</p><h4 id="3-登录-MySQL"><a href="#3-登录-MySQL" class="headerlink" title="3. 登录 MySQL"></a>3. 登录 MySQL</h4><p>使用root用户<strong>无密码登录 MySQL</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot</span><br></pre></td></tr></table></figure><h4 id="4-重置-MySQL-密码"><a href="#4-重置-MySQL-密码" class="headerlink" title="4. 重置 MySQL 密码"></a>4. 重置 MySQL 密码</h4><p>在 5.7 版本后，我们可以使用 <code>alter user...identified by</code>命令把root用户的密码修改为“123456”，具体命令如下所示：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user 'root'@'localhost' identified by '123456';</span><br></pre></td></tr></table></figure><p>修改完成，使用<code>exit</code>或者<code>quit</code>命令退出 MySQL，重新登录验证密码是否修改成功，具体命令如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure><p>效果如下图所示：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200511/jyqngavd_3Eid3eXK7Eff4emZXVoQ" alt="img"></p><h3 id="1-4-增加远程登录权限"><a href="#1-4-增加远程登录权限" class="headerlink" title="1.4 增加远程登录权限"></a>1.4 增加远程登录权限</h3><p>当我们的帐号不允许从远程登录，只能在localhost连接时。这个时候只要在 MySQL 服务器上，更改mysql 数据库里的 user 表里的 host 项，从localhost改成%即可实现用户远程登录。</p><h4 id="（1）首先我们来查看-mysql-数据库下的-user表信息："><a href="#（1）首先我们来查看-mysql-数据库下的-user表信息：" class="headerlink" title="（1）首先我们来查看 mysql 数据库下的 user表信息："></a>（1）首先我们来查看 mysql 数据库下的 user表信息：</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;  # 切换成mysql数据库</span><br><span class="line">mysql&gt; select user,host from user; # 查询用户信息</span><br></pre></td></tr></table></figure><p>可以看到在user表中已创建的root用户。host字段表示登录的主机，其值可以用IP地址，也可用主机名。</p><h4 id="（2）实现远程连接（授权法）"><a href="#（2）实现远程连接（授权法）" class="headerlink" title="（2）实现远程连接（授权法）"></a>（2）实现远程连接（授权法）</h4><p>将 host 字段的值改为%就表示在任何客户端机器上能以root用户登录到 MySQL 服务器，建议在开发时设为%。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置远程登录权限 </span></span><br><span class="line">mysql&gt; update user set host='%' where host='localhost';</span><br><span class="line"><span class="comment"># 刷新配置信息</span></span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>效果图如下所示：<br><img src="https://assets.qingjiaoclass.com/qingjiao-ppt/2020-5-11/42879f7cbc4f57d0" alt="null"></p><h2 id="任务2：Hive-安装部署"><a href="#任务2：Hive-安装部署" class="headerlink" title="任务2：Hive 安装部署"></a>任务2：Hive 安装部署</h2><h3 id="2-1-解压安装包"><a href="#2-1-解压安装包" class="headerlink" title="2.1 解压安装包"></a>2.1 解压安装包</h3><p>现在已经为大家下载好了 hive2.3.4 的安装包，存放在 /root/software 目录下，首先进入此目录下，使用如下命令进行解压即可使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-hive-2.3.4-bin.tar.gz</span><br></pre></td></tr></table></figure><p>将其<strong>解压到当前目录下</strong>，即 /root/software 中。</p><h3 id="2-2-配置环境变量"><a href="#2-2-配置环境变量" class="headerlink" title="2.2 配置环境变量"></a>2.2 配置环境变量</h3><h4 id="（1）首先打开-etc-profile-文件："><a href="#（1）首先打开-etc-profile-文件：" class="headerlink" title="（1）首先打开 /etc/profile 文件："></a>（1）首先打开 /etc/profile 文件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h4 id="（2）将以下内容添加到配置文件的底部，添加完成输入“-wq”保存退出："><a href="#（2）将以下内容添加到配置文件的底部，添加完成输入“-wq”保存退出：" class="headerlink" title="（2）将以下内容添加到配置文件的底部，添加完成输入“:wq”保存退出："></a>（2）将以下内容添加到配置文件的底部，添加完成输入“:wq”保存退出：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置Hive的安装目录   </span><br><span class="line">export HIVE_HOME&#x3D;&#x2F;root&#x2F;software&#x2F;apache-hive-2.3.4-bin  </span><br><span class="line"># 在原PATH的基础上加入Hive的bin目录  </span><br><span class="line">export PATH&#x3D;$PATH:$HIVE_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><h4 id="（3）让配置文件立即生效，使用如下命令："><a href="#（3）让配置文件立即生效，使用如下命令：" class="headerlink" title="（3）让配置文件立即生效，使用如下命令："></a>（3）让配置文件立即生效，使用如下命令：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h4 id="（4）检测-Hive-环境变量是否设置成功，使用如下命令查看-Hive-版本："><a href="#（4）检测-Hive-环境变量是否设置成功，使用如下命令查看-Hive-版本：" class="headerlink" title="（4）检测 Hive 环境变量是否设置成功，使用如下命令查看 Hive 版本："></a>（4）检测 Hive 环境变量是否设置成功，使用如下命令查看 Hive 版本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive --version</span><br></pre></td></tr></table></figure><p>执行此命令后，若是出现 Hive 版本信息说明配置成功：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200429/jyqngavd_zuGmJHeBbqJLBA0Dk23M" alt="img"></p><h3 id="2-3-修改配置文件-hive-env-sh"><a href="#2-3-修改配置文件-hive-env-sh" class="headerlink" title="2.3 修改配置文件 hive-env.sh"></a>2.3 修改配置文件 hive-env.sh</h3><p>切换到 ${HIVE_HOME}/conf 目录下，将 hive-env.sh.template 文件<strong>复制一份并重命名</strong>为 hive-env.sh：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure><p>修改完成，使用 <strong>vi 编辑器</strong>进行编辑：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim hive-env.sh</span><br></pre></td></tr></table></figure><p>在文件中配置 <strong>HADOOP_HOME</strong>、<strong>HIVE_CONF_DIR</strong> 以及<strong>HIVE_AUX_JARS_PATH</strong> 参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置Hadoop安装路径  </span><br><span class="line">HADOOP_HOME&#x3D;&#x2F;root&#x2F;software&#x2F;hadoop-2.7.7  </span><br><span class="line">  </span><br><span class="line"># 配置Hive配置文件存放路径  </span><br><span class="line">export HIVE_CONF_DIR&#x3D;&#x2F;root&#x2F;software&#x2F;apache-hive-2.3.4-bin&#x2F;conf  </span><br><span class="line">  </span><br><span class="line"># 配置Hive运行资源库路径  </span><br><span class="line">export HIVE_AUX_JARS_PATH&#x3D;&#x2F;root&#x2F;software&#x2F;apache-hive-2.3.4-bin&#x2F;lib</span><br></pre></td></tr></table></figure><p>配置完成，输入“:wq”保存退出。</p><h2 id="任务3：Hive元数据配置到MySQL"><a href="#任务3：Hive元数据配置到MySQL" class="headerlink" title="任务3：Hive元数据配置到MySQL"></a>任务3：Hive元数据配置到MySQL</h2><h3 id="3-1-驱动拷贝"><a href="#3-1-驱动拷贝" class="headerlink" title="3.1 驱动拷贝"></a>3.1 驱动拷贝</h3><p>将/root/software目录下的 MySQL 驱动包 mysql-connector-java-5.1.47-bin.jar 拷贝到 ${HIVE_HOME}/lib 目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;software&#x2F;  </span><br><span class="line">cp mysql-connector-java-5.1.47-bin.jar apache-hive-2.3.4-bin&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure><h3 id="3-2-配置-Metastore到MySQL"><a href="#3-2-配置-Metastore到MySQL" class="headerlink" title="3.2 配置 Metastore到MySQL"></a>3.2 配置 Metastore到MySQL</h3><p>（1）在${HIVE_HOME}/conf目录下创建一个名为hive-site.xml的文件，并使用vi编辑器进行编辑：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch hive-site.xml  </span><br><span class="line">vim hive-site.xml</span><br></pre></td></tr></table></figure><p>（2）根据官方文档配置参数（<a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+Administration），拷贝数据到" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+Administration），拷贝数据到</a> hive-site.xml 文件中：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--连接元数据库的链接信息 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/hivedb?createDatabaseIfNotExist=true<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--连接数据库驱动 --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--连接数据库用户名称 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--连接数据库用户密码 --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-初始化元数据库"><a href="#3-3-初始化元数据库" class="headerlink" title="3.3 初始化元数据库"></a>3.3 初始化元数据库</h3><p>注意：<strong>如果使用的是 2.x 版本的 Hive，那么就必须手动初始化元数据库。</strong> 使用 <code>schematool -dbType &lt;db type&gt; -initSchema</code> 命令进行初始化：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure><p>若是出现“schemaTool completed”则初始化成功。<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200511/jyqngavd_QVpiQafyvlP3yOFT7qU9" alt="img"></p><h3 id="3-4-Hive-连接"><a href="#3-4-Hive-连接" class="headerlink" title="3.4 Hive 连接"></a>3.4 Hive 连接</h3><p>在任意目录下使用 Hive 的三种连接方式之一：<strong>CLI 启动 Hive</strong>。由于已经在环境变量中配置了 HIVE_HOME ，所以这里直接在命令行执行如下命令即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive  </span><br><span class="line">或者  </span><br><span class="line">hive --service cli</span><br></pre></td></tr></table></figure><p>效果如下图所示：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200511/jyqngavd_AT3NDqcu6ViewnCOXmrK" alt="img"></p><p>可以使用如下命令退出 Hive 客户端：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; exit;</span><br><span class="line">或者</span><br><span class="line">hive&gt; quit;</span><br></pre></td></tr></table></figure><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><h3 id="Hive-本地模式安装，具体步骤如下："><a href="#Hive-本地模式安装，具体步骤如下：" class="headerlink" title="Hive 本地模式安装，具体步骤如下："></a>Hive 本地模式安装，具体步骤如下：</h3><h4 id="1-安装-MySQL"><a href="#1-安装-MySQL" class="headerlink" title="1. 安装 MySQL"></a>1. 安装 MySQL</h4><p><strong>（1）解压安装包</strong><br><strong>（2）安装 MySQL 组件</strong>，顺序为：<br>common——》libs——》libs-compat——》client——》server<br><strong>（3）登录 MySQL</strong></p><ul><li>初始化 MySQL 的数据库</li><li>启动 MySQL 服务</li><li>登录 MySQL</li><li>重置 MySQL 密码</li></ul><p><strong>（4）增加远程登录权限</strong></p><h4 id="2-Hive-安装部署"><a href="#2-Hive-安装部署" class="headerlink" title="2. Hive 安装部署"></a>2. Hive 安装部署</h4><p><strong>（1）解压安装包</strong><br><strong>（2）配置环境变量：/etc/profile 文件</strong><br><strong>（3）修改配置文件hive-env.sh</strong></p><h4 id="3-Hive元数据配置到MySQL"><a href="#3-Hive元数据配置到MySQL" class="headerlink" title="3. Hive元数据配置到MySQL"></a>3. Hive元数据配置到MySQL</h4><p><strong>（1）驱动拷贝</strong>：　将MySQL 驱动包 mysql-connector-java-5.1.47-bin.jar 拷贝到 ${HIVE_HOME}/lib 目录下。<br><strong>（2）配置 Metastore到MySQL</strong>：hive-site.xml<br><strong>（3）初始化元数据库</strong><br><strong>（4）Hive 连接</strong></p><h1 id="Hive常见属性配置"><a href="#Hive常见属性配置" class="headerlink" title="Hive常见属性配置"></a>Hive常见属性配置</h1><p>（1）首先，将 <code>${HIVE_HOME}/conf</code> 目录下的 hive-log4j2.properties.template 文件复制一份并重命名为 hive-log4j2.properties，具体命令如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp hive-log4j2.properties.template hive-log4j2.properties</span><br></pre></td></tr></table></figure><p>（2）之后使用 vi 编辑器进行编辑，将 Hive 日志配置到 /root/hive/logs/myhive.log 文件中。用到的两个参数是：</p><ul><li>property.hive.log.dir</li><li>property.hive.log.file</li></ul><p>（3）重新启动 Hive：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive</span><br><span class="line">或者</span><br><span class="line">hive --service cli</span><br></pre></td></tr></table></figure><p>（4）验证新的日志文件是否自动创建：<br><img src="https://assets.qingjiaoclass.com/gdlzpoyzbkrj/20200512/jyqngavd_3PT4ljOT4r60QnvkTzfw" alt="img"></p><p>从上图可以看出，我们成功将 Hive 日志存放路径修改为 /root/hive/logs/myhive.log。</p><p>任务要求<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAAkCAMAAABmIU6YAAAAQlBMVEVWhP//kDtXif9VhP/3Xo5Xhv9Wgv9HcEz/pyCubsH/pSCqlpBYif9xf+fHaa/2YJH5Xo2Zc8/4YJGYkqjuojXHm2gJ6LC6AAAAFnRSTlNNEAo8hi1HAGepR5AaXZ1Rd4Ulfk2A8zlkVwAAARlJREFUSMfV19uSgyAMBuAQDAcRte3u+7/qCoi1q0tvTDr7XznefGNIwgj2JGqau3lSliNw8u7eldyFQNXVKBlw2sCJHRxIG/B+HMcMzrwgkoEUn5NJVpBgjfeV5PxC1NWDWxU94xmi2TyIGwjIBe69pxjBIBOo4SUxVfUWlyfNAxL8GeIAERpBBpBaIDGALQ/M9eDQBGG4SFK9c71KILXBi2qqXI6Cw0z8zkWT0RewX0ADEofo1sCbnlnyT0Hxkoo3jfhYyA/+brUZgZ755PJeDjM8otz1lNr1O4QodgHngQzhwTsTO7DMYwjnQ49coAtC3lpS575O9o1m8ErTpB13HA6yHIG6454/M6WahJYJPPyugdE0WK78AHRkW9RS3xDmAAAAAElFTkSuQmCC" alt="img"></p><h3 id="Hive-运行日志信息配置"><a href="#Hive-运行日志信息配置" class="headerlink" title="Hive 运行日志信息配置"></a>Hive 运行日志信息配置</h3><p>在Hive中，使用的是 Log4j 来输出日志，<strong>默认情况下，CLI 是不能将日志信息输出到控制台的。</strong></p><p>默认的日志存放在<code>/tmp/${user.name}</code>文件夹的<code>hive.log</code>文件中，全路径就是<code>/tmp/${user.name}/hive.log</code>。</p><p>现要求将 Hive 的日志存放路径修改为 <strong>/root/hive/logs</strong>，日志文件为<strong>myhive.log</strong>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>linux</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的GC机制</title>
    <url>/2020/06/15/Python%E7%9A%84GC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="Python的GC机制"><a href="#Python的GC机制" class="headerlink" title="Python的GC机制"></a>Python的GC机制</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>python采用的是<strong>引用计数</strong>机制为主，<strong>标记-清除</strong>和<strong>分代收集</strong>两种机制为辅的策略。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ul><li>Python语言默认采用的垃圾收集机制是『引用计数法 <code>Reference Counting</code>』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用。</li><li>『引用计数法』的原理是：每个对象维护一个<code>ob_ref</code>字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数<code>ob_ref</code>加<code>1</code>，每当该对象的引用失效时计数<code>ob_ref</code>减<code>1</code>，一旦对象的引用计数为<code>0</code>，该对象立即被回收，对象占用的内存空间将被释放。</li><li>它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，也有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</li></ul><h3 id="引用计数案例"><a href="#引用计数案例" class="headerlink" title="引用计数案例"></a>引用计数案例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''初始化对象'''</span></span><br><span class="line">        print(<span class="string">'object born id:%s'</span> %str(hex(id(self))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''循环引用变量与删除变量'''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c1=A()</span><br><span class="line">        <span class="keyword">del</span> c1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(c)</span>:</span></span><br><span class="line">    print(<span class="string">'obejct refcount is: '</span>,sys.getrefcount(c)) <span class="comment">#getrefcount()方法用于返回对象的引用计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   <span class="comment">#生成对象</span></span><br><span class="line">    a=A()</span><br><span class="line">    func(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#增加引用</span></span><br><span class="line">    b=a</span><br><span class="line">    func(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#销毁引用对象b</span></span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    func(a)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">object born id:<span class="number">0x265c56a56d8</span></span><br><span class="line">obejct refcount <span class="keyword">is</span>:  <span class="number">4</span></span><br><span class="line">obejct refcount <span class="keyword">is</span>:  <span class="number">5</span></span><br><span class="line">obejct refcount <span class="keyword">is</span>:  <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="导致引用计数-1的情况"><a href="#导致引用计数-1的情况" class="headerlink" title="导致引用计数+1的情况"></a>导致引用计数+1的情况</h4><ul><li>对象被创建，例如a=23</li><li>对象被引用，例如b=a</li><li>对象被作为参数，传入到一个函数中，例如<code>func(a)</code></li><li>对象作为一个元素，存储在容器中，例如<code>list1=[a,a]</code></li></ul><h4 id="导致引用计数-1的情况-1"><a href="#导致引用计数-1的情况-1" class="headerlink" title="导致引用计数-1的情况"></a>导致引用计数-1的情况</h4><ul><li>对象的别名被显式销毁，例如<code>del a</code></li><li>对象的别名被赋予新的对象，例如<code>a=24</code></li><li>一个对象离开它的作用域，例如f函数执行完毕时，<code>func</code>函数中的局部变量（全局变量不会）</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ul><h3 id="循环引用导致内存泄露"><a href="#循环引用导致内存泄露" class="headerlink" title="循环引用导致内存泄露"></a>循环引用导致内存泄露</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''循环引用'''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c1=A()</span><br><span class="line">        c2=A()</span><br><span class="line">        c1.t=c2</span><br><span class="line">        c2.t=c1</span><br><span class="line">        <span class="keyword">del</span> c1</span><br><span class="line">        <span class="keyword">del</span> c2</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">id:<span class="number">0x1feb9f691d0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69438</span></span><br><span class="line">object born id:<span class="number">0x1feb9f690b8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69d68</span></span><br><span class="line">object born id:<span class="number">0x1feb9f690f0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f694e0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69f60</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69eb8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69128</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69c88</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69470</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69e48</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69ef0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69dd8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69e10</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69ac8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69198</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69cf8</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69da0</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69c18</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69d30</span></span><br><span class="line">object born id:<span class="number">0x1feb9f69ba8</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>创建了<code>c1</code>，<code>c2</code>后，这两个对象的引用计数都是<code>1</code>，执行<code>c1.t=c2</code>和<code>c2.t=c1</code>后，引用计数变成<code>2</code>.</li><li>在<code>del c1</code>后，内存<code>c1</code>的对象的引用计数变为<code>1</code>，由于不是为<code>0</code>，所以<code>c1</code>的对象不会被销毁,同理，在<code>del c2</code>后也是一样的。</li><li>虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。</li></ul><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><ul><li>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。</li><li>新创建的对象都会分配在<strong>年轻代</strong>，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到<strong>中年代</strong>去，依此类推，<strong>老年代</strong>中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</li><li>同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>有三种情况会触发垃圾回收：</p><ol><li>调用<code>gc.collect()</code>,需要先导入<code>gc</code>模块。</li><li>当<code>gc</code>模块的计数器达到阀值的时候。</li><li>程序退出的时候。</li></ol><h4 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a>gc模块</h4><p>gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p><p><strong>常用函数</strong>：</p><ol><li><code>gc.set_debug(flags)</code> 设置gc的debug日志，一般设置为<code>gc.DEBUG_LEAK</code></li><li><code>gc.collect([generation])</code><br>显式进行垃圾回收，可以输入参数，<code>0</code>代表只检查第一代的对象，<code>1</code>代表检查一，二代的对象，<code>2</code>代表检查一，二，三代的对象，如果不传参数，执行一个<code>full collection</code>，也就是等于传2。返回不可达（unreachable objects）对象的数目。</li><li><code>gc.set_threshold(threshold0[, threshold1[, threshold2])</code><br>设置自动执行垃圾回收的频率。</li><li><code>gc.get_count()</code> 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</li></ol><p>扩展资料：<a href="https://docs.python.org/3.5/library/gc.html" target="_blank" rel="noopener">Garbage Collector interface</a></p><h4 id="gc实践案例"><a href="#gc实践案例" class="headerlink" title="gc实践案例"></a>gc实践案例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''循环引用'''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c1=A()</span><br><span class="line">        c2=A()</span><br><span class="line">        c1.t=c2</span><br><span class="line">        c2.t=c1</span><br><span class="line">        <span class="keyword">del</span> c1</span><br><span class="line">        <span class="keyword">del</span> c2</span><br><span class="line">        <span class="comment">#增加垃圾回收机制</span></span><br><span class="line">        print(gc.garbage)</span><br><span class="line">        print(gc.collect())</span><br><span class="line">        print(gc.garbage)</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">object born id:<span class="number">0x21d1a5dc470</span></span><br><span class="line">object born id:<span class="number">0x21d1a5dc9e8</span></span><br><span class="line">[]</span><br><span class="line"><span class="number">4</span></span><br><span class="line">gc: collectable &lt;A <span class="number">0x0000021D1A5DC470</span>&gt;</span><br><span class="line">[&lt;__main__.A object at <span class="number">0x0000021D1A5DC470</span>&gt;, &lt;__main__.A object at <span class="number">0x0000021D1A5DC9E8</span>&gt;, &#123;<span class="string">'t'</span>: &lt;__main__.A object at <span class="number">0x0000021D1A5DC9E8</span>&gt;&#125;, &#123;<span class="string">'t'</span>: &lt;__main__.A object at <span class="number">0x0000021D1A5DC470</span>&gt;&#125;]</span><br><span class="line">gc: collectable &lt;A <span class="number">0x0000021D1A5DC9E8</span>&gt;</span><br><span class="line">gc: collectable &lt;dict <span class="number">0x0000021D1A156C88</span>&gt;</span><br><span class="line">gc: collectable &lt;dict <span class="number">0x0000021D1A5CABC8</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="gc模块的自动垃圾回收机制"><a href="#gc模块的自动垃圾回收机制" class="headerlink" title="gc模块的自动垃圾回收机制"></a>gc模块的自动垃圾回收机制</h3><p>必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。<br>这个机制的主要作用就是发现并处理不可达的垃圾对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">垃圾回收&#x3D;垃圾检查+垃圾回收</span><br></pre></td></tr></table></figure><p>在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。</p><p>gc模块里面会有一个长度为3的列表的计数器，可以通过<code>gc.get_count()</code>获取。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f4</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''垃圾自动回收'''</span></span><br><span class="line">    print(gc.get_count())</span><br><span class="line">    a=A()</span><br><span class="line">    print(gc.get_count())</span><br><span class="line">    <span class="keyword">del</span> a</span><br><span class="line">    print(gc.get_count())</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">621</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">object born id:<span class="number">0x2ca32a8c588</span></span><br><span class="line">(<span class="number">624</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">623</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><code>621</code>指距离上一次<code>一代</code>垃圾检查，Python分配内存的数目减去释放内存的数目，注意:是内存分配，而不是引用计数的增加。</li><li><code>10</code>指距离上一次<code>二代</code>垃圾检查，<code>一代</code>垃圾检查的次数。</li><li><code>0</code>是指距离上一次<code>三代</code>垃圾检查，<code>二代</code>垃圾检查的次数。</li></ul><h3 id="自动回收阈值"><a href="#自动回收阈值" class="headerlink" title="自动回收阈值"></a>自动回收阈值</h3><p>gc模快有一个自动垃圾回收的阀值，即通过<code>gc.get_threshold</code>函数获取到的长度为3的元组，例如<code>(700,10,10)</code><br>每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器</p><p>注意：<br>如果循环引用中，两个对象都定义了<code>__del__</code>方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的<code>__del__</code>方法，所以为了安全起见，gc模块会把对象放到<code>gc.garbage</code>中，但是不会销毁对象。</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p><p><img src="https://wx2.sbimg.cn/2020/06/22/GC.png" alt></p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 mark-sweepg 在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p><p>标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的is 和 == 你真的搞对对象了吗？</title>
    <url>/2020/06/09/Python%E7%9A%84%20is%20%E5%92%8C%20==%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><p>首先我先放一张简单总结的图</p><p><img src="https://wx2.sbimg.cn/2020/06/09/image-20200608161408086.png" alt="image-20200608161408086"></p><p>下面是我做的一个题目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已知x &#x3D; [[]]*3 执行语句x[0].append(1)后x的值为_____  #[[1],[1],[1]]</span><br><span class="line">已知x &#x3D; [[] for in i range(3)] 执行语句x[0].append(1)后x的值为_____  # [[1],[],[]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;b&#x3D;[[]]*3</span><br><span class="line">&gt;&gt;&gt;b</span><br><span class="line">[[], [], []]</span><br><span class="line">&gt;&gt;&gt;[id(b[i]) for i in range(3)]		#查看地址</span><br><span class="line">[2637926546248, 2637926546248, 2637926546248]</span><br><span class="line">&gt;&gt;&gt;a &#x3D; [[] for i in range(3)]</span><br><span class="line">&gt;&gt;&gt;[id(a[i]) for i in range(3)]		#查看地址</span><br><span class="line">[2637624332232, 2637909035016, 2637926538824]</span><br></pre></td></tr></table></figure><h3 id="下面开始正文，在Python中一切都是对象"><a href="#下面开始正文，在Python中一切都是对象" class="headerlink" title="下面开始正文，在Python中一切都是对象"></a>下面开始正文，在Python中一切都是对象</h3><p>Python中对象包含的三个基本要素，分别是：</p><ul><li>id(身份标识)</li><li>type(数据类型)</li><li>value(值)</li></ul><p>对象之间比较是否相等可以用 == ，也可以用 is 。</p><p>is 和 == 都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。下面来看看具体区别在哪?</p><p>is 比较的是两个对象的id值是否相等，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址。</p><p>== 比较的是两个对象的内容是否相等，默认会调用对象的 <code>__eq__</code> 方法。</p><p>== 是python标准操作符中的比较操作符，用来比较判断两个对象的值是否相等。</p><p>先来看一个例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br><span class="line">&gt;&gt;&gt; b is a </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b &#x3D;&#x3D; a</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a[:]</span><br><span class="line">&gt;&gt;&gt; b is a</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; b &#x3D;&#x3D; a</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>is 也被叫做同一性运算符，也就是id是否相同。</p><p>看下面代码， a和b变量的id不同， 所以 b == a 是True， b is a 是False.</p><p>再来看一下他们的id：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4364243328</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4364202696</span><br></pre></td></tr></table></figure><p>哪些情况下 is 和 == 结果是完全相同的？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 256</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 256</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 10**3</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>所以数字类型不完全相同。</p><p>那为什么256时相同， 而1000时不同呢？</p><p>因为出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫 small_ints 的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。</p><p>Python把这些可能频繁使用的整数对象规定在范围 [-5, 256] 之间的小对象放在 small_ints 中，但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; c &#x3D; &#39;miracle.young&#39;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &#39;miracle.young&#39;</span><br><span class="line">&gt;&gt;&gt; c is d</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; c &#x3D;&#x3D; d</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &#39;miracleyoung&#39;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &#39;miracleyoung&#39;</span><br><span class="line">&gt;&gt;&gt; c is c</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D;&#x3D; d</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>所以字符串类型不完全相同，这个和解释器实现有关。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; (1,2,3) # a和b为元组类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; (1,2,3)</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1,2,3] # a和b为list类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; &#123;&#39;miracle&#39;:100,&#39;young&#39;:1&#125; # a和b为dict类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;miracle&#39;:100,&#39;young&#39;:1&#125;</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; set([1,2,3]) # a和b为set类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; set([1,2,3])</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>所以当变量是数字、字符串、元组，列表，字典时，is 和 == 都不相同， 不能互换使用！当比较值时，要使用 ==，比较是否是同一个内存地址时应该使用is。</p><p>当然，开发中比较值的情况比较多。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>git上传大文件或者PDF或者二进制文件无法上传</title>
    <url>/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><p><span style="color:red;background:#fff;font-size:15;font-family:字体">提醒：git commit –hard commit_id 会把commit对应的文件从本地库删除！谨慎使用此命令！</span></p><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>​ push大文件失败，在将大文件删除之后，其余小文件仍然受到之前大文件push失败的影响，无法正常push。</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><p>​ 需要将之前含有大文件的commit记录删除（全部删除）</p><h2 id="3-详细过程"><a href="#3-详细过程" class="headerlink" title="3. 详细过程"></a>3. 详细过程</h2><ol><li><p>将git切换到之前提交的git项目所在目录</p></li><li><p>使用<code>git log</code>命令查看commit的历史记录及其对应的commit_id，查看结果如图：</p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/1.JPG" alt="1.JPG"></p></li><li><p>复制commit_id，使用Ctrl+C退出log查看页面，进入正常git可输入命令界面，输入下面命令，使git回退到commit_id的状态。 <code>git reset --hard //前面3个单词不需改变，将改成对应的commit_id的值</code></p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/2.JPG" alt="2.JPG"></p></li><li><p>使用下列命令使本地和远程的内容都回退到commit_id对应的状态。 <code>git push origin HEAD --force //固定模式，不需要改变单词</code></p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/3.JPG" alt="3.JPG"></p></li></ol><h2 id="4-参数解释"><a href="#4-参数解释" class="headerlink" title="4. 参数解释"></a>4. 参数解释</h2><p>根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:</p><ul><li><p>git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息。</p></li><li><p>git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可。</p></li><li><p>git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容。</p></li><li><p>git status :查看未被传送到远程代码库的提交状态</p></li><li><p>git cherry -v 查看未被传送到远程代码库的提交描述和说明</p></li><li><p>git reset commit_id 撤销未被传送到远程代码库的提交</p></li><li><p>HEAD 最近一个提交</p></li><li><p>HEAD^ 上一次提交</p></li><li><p>每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到。</p></li></ul><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.douban.com/note/189603387/" target="_blank" rel="noopener">git 删除错误提交的commit</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Stay hungry. Stay Foolish.</title>
    <url>/2020/03/18/Stay-hungry-Stay-Foolish/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><div id="article_content" class="article_content clearfix"><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css"><div id="content_views" class="markdown_views prism-atom-one-light"><svg xmlns="http://www.w3.org/2000/svg" style="display:none"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color:transparent"/></svg><p>Thank you. I am honored to be with you today at your commencement from one of the finest universities in the world. Truth be told, I never graduated from college. This is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.</p><p>很荣幸和大家一道参加这所世界上最好的一座大学的毕业典礼。我大学没毕业，说实话，这是我第一次离大学毕业典礼这么近。今天我想给大家讲三个我自己的故事，不讲别的，也不讲大道理，就讲三个故事。</p><p>The first story is about connecting the dots. I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?</p><p>第一个故事讲的是点与点之间的关系。我在里德学院(Reed College)只读了六个月就退学了，此后便在学校里旁听，又过了大约一年半，我彻底离开。那么，我为什么退学呢?</p><p>It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife.</p><p>这得从我出生前讲起。我的生母是一名年轻的未婚在校研究生，她决定将我送给别人收养。她非常希望收养我的是有大学学历的人，所以把一切都安排好了，我一出生就交给一对律师夫妇收养。</p><p>Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.”</p><p>没想到我落地的霎那间，那对夫妇却决定收养一名女孩。就这样，我的养父母─当时他们还在登记册上排队等着呢─半夜三更接到一个电话: “我们这儿有一个没人要的男婴，你们要么?”“当然要”他们回答。</p><p>My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.</p><p>但是，我的生母后来发现我的养母不是大学毕业生，我的养父甚至连中学都没有毕业，所以她拒绝在最后的收养文件上签字。不过，没过几个月她就心软了，因为我的养父母许诺日后一定送我上大学。</p><p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition.</p><p>17 年后，我真的进了大学。当时我很天真，选了一所学费几乎和斯坦福大学一样昂贵的学校，当工人的养父母倾其所有的积蓄为我支付了大学学费。</p><p>After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life.</p><p>读了六个月后，我却看不出上学有什么意义。我既不知道自己这一生想干什么，也不知道大学是否能够帮我弄明白自己想干什么。这时，我就要花光父母一辈子节省下来的钱了。</p><p>So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting。</p><p>所以，我决定退学，并且坚信日后会证明我这样做是对的。当年做出这个决定时心里直打鼓，但现在回想起来，这还真是我有生以来做出的最好的决定之一。从退学那一刻起，我就可以不再选那些我毫无兴趣的必修课，开始旁听一些看上去有意思的课。</p><p>It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5? deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p><p>那些日子一点儿都不浪漫。我没有宿舍，只能睡在朋友房间的地板上。我去退还可乐瓶，用那五分钱的押金来买吃的。每个星期天晚上我都要走七英里，到城那头的黑尔-科里施纳礼拜堂去，吃每周才能享用一次的美餐。我喜欢这样。我凭著好奇心和直觉所干的这些事情，有许多后来都证明是无价之宝。我给大家举个例子:</p><p>Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.</p><p>当时，里德学院的书法课大概是全国最好的。校园里所有的公告栏和每个抽屉标签上的字都写得非常漂亮。当时我已经退学，不用正常上课，所以我决定选一门书法课，学学怎么写好字。</p><p>I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.</p><p>我学习写带短截线和不带短截线的印刷字体，根据不同字母组合调整其间距，以及怎样把版式调整得好上加好。这门课太棒了，既有历史价值，又有艺术造诣，这一点科学就做不到，而我觉得它妙不可言。</p><p>None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac.</p><p>当时我并不指望书法在以后的生活中能有什么实用价值。但是，十年之后，我们在设计第一台 Macintosh 计算机时，它一下子浮现在我眼前。于是，我们把这些东西全都设计进了计算机中。</p><p>It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, its likely that no personal computer would have them.</p><p>这是第一台有这么漂亮的文字版式的计算机。要不是我当初在大学里偶然选了这么一门课，Macintosh 计算机绝不会有那么多种印刷字体或间距安排合理的字号。要不是 Windows 照搬了 Macintosh，个人电脑可能不会有这些字体和字号。</p><p>If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.</p><p>要不是退了学，我决不会碰巧选了这门书法课，个人电脑也可能不会有现在这些漂亮的版式了。当然，我在大学里不可能从这一点上看到它与将来的关系。十年之后再回头看，两者之间的关系就非常、非常清楚了。</p><p>Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something — your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.</p><p>你们同样不可能从现在这个点上看到将来；只有回头看时，才会发现它们之间的关系。所以，要相信这些点迟早会连接到一起。你们必须信赖某些东西─直觉、归宿、生命，还有业力，等等。这样做从来没有让我的希望落空过，而且还彻底改变了我的生活。</p><p>My second story is about love and loss. I was lucky — I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees.</p><p>我的第二个故事是关于好恶与得失。幸运的是，我在很小的时候就发现自己喜欢做什么。我在 20 岁时和沃兹在我父母的车库里办起了苹果公司。我们干得很卖力，十年后，苹果公司就从车库里我们两个人发展成为一个拥有 20 亿元资产、4,000 名员工的大企业。</p><p>We had just released our finest creation — the Macintosh — a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well.</p><p>那时，我们刚刚推出了我们最好的产品─ Macintosh 电脑─那是在第 9 年，我刚满 30 岁。可后来，我被解雇了。你怎么会被自己办的公司解雇呢?是这样，随著苹果公司越做越大，我们聘了一位我认为非常有才华的人与我一道管理公司。在开始的一年多里，一切都很顺利。</p><p>But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.</p><p>可是，随后我俩对公司前景的看法开始出现分歧，最后我俩反目了。这时，董事会站在了他那一边，所以在 30 岁那年，我离开了公司，而且这件事闹得满城风雨。我成年后的整个生活重心都没有了，这使我心力交瘁。</p><p>I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley.</p><p>一连几个月，我真的不知道应该怎么办。我感到自己给老一代的创业者丢了脸─因为我扔掉了交到自己手里的接力棒。我去见了戴维帕卡德和鲍勃.诺伊斯，想为把事情搞得这么糟糕说声道歉。这次失败弄得沸沸扬扬的，我甚至想过逃离硅谷。</p><p>But something slowly began to dawn on me — I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.</p><p>但是，渐渐地，我开始有了一个想法─我仍然热爱我过去做的一切。在苹果公司发生的这些风波丝毫没有改变这一点。我虽然被拒之门外，但我仍然深爱我的事业。于是，我决定从头开始。</p><p>I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.</p><p>虽然当时我并没有意识到，但事实证明，被苹果公司炒鱿鱼是我一生中碰到的最好的事情。尽管前景未卜，但从头开始的轻松感取代了保持成功的沉重感。这使我进入了一生中最富有创造力的时期之一。</p><p>During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.</p><p>在此后的五年里，我开了一家名叫 NeXT 的公司和一家叫皮克斯的公司，我还爱上一位了不起的女人，后来娶了她。皮克斯公司推出了世界上第一部用电脑制作的动画片《玩具总动员》(Toy Story)，它现在是全球最成功的动画制作室。</p><p>In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.</p><p>世道轮回，苹果公司买下 NeXT 后，我又回到了苹果公司，我们在 NeXT 公司开发的技术成了苹果公司这次重新崛起的核心。我和劳伦娜(Laurene)也建立了美满的家庭。</p><p>I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did.</p><p>我确信，如果不是被苹果公司解雇，这一切决不可能发生。这是一剂苦药，可我认为苦药利于病。有时生活会当头给你一棒，但不要灰心。我坚信让我一往无前的唯一力量就是我热爱我所做的一切。</p><p>You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do.</p><p>所以，一定得知道自己喜欢什么，选择爱人时如此，选择工作时同样如此。工作将是生活中的一大部分，让自己真正满意的唯一办法，是做自己认为是有意义的工作;做有意义的工作的唯一办法，是热爱自己的工作。</p><p>If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.</p><p>你们如果还没有发现自己喜欢什么，那就不断地去寻找，不要急于做出决定。就像一切要凭着感觉去做的事情一样，一旦找到了自己喜欢的事，感觉就会告诉你。就像任何一种美妙的东西，历久弥新。所以说，要不断地寻找，直到找到自己喜欢的东西。不要半途而废。</p><p>My third story is about death. When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something.</p><p>我的第三个故事与死亡有关。17 岁那年，我读到过这样一段话，大意是:“如果把每一天都当作生命的最后一天，总有一天你会如愿以偿。”我记住了这句话，从那时起，33 年过去了，我每天早晨都对着镜子自问: “假如今天是生命的最后一天，我还会去做今天要做的事吗?”如果一连许多天我的回答都是“不”，我知道自己应该有所改变了。</p><p>Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything — all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.</p><p>让我能够做出人生重大抉择的最主要办法是，记住生命随时都有可能结束。因为几乎所有的东西─所有对自身之外的希求、所有的尊严、所有对困窘和失败的恐惧─在死亡来临时都将不复存在，只剩下真正重要的东西。记住自己随时都会死去，这是我所知道的防止患得患失的最好方法。你已经一无所有了，还有什么理由不跟着自己的感觉走呢。</p><p>About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months.</p><p>大约一年前，我被诊断患了癌症。那天早上七点半，我做了一次扫描检查，结果清楚地表明我的胰腺上长了一个瘤子，可那时我连胰腺是什么还不知道呢!医生告诉我说，几乎可以确诊这是一种无法治愈的恶性肿瘤，我最多还能活 3 到 6 个月。</p><p>My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.</p><p>医生建议我回去把一切都安排好，其实这是在暗示“准备后事”。也就是说，把今后十年要跟孩子们说的事情在这几个月内嘱咐完;也就是说，把一切都安排妥当，尽可能不给家人留麻烦；也就是说，去跟大家诀别。</p><p>I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now.</p><p>那一整天里，我的脑子一直没离开这个诊断。到了晚上，我做了一次组织切片检查，他们把一个内窥镜通过喉咙穿过我的胃进入肠子，用针头在胰腺的瘤子上取了一些细胞组织。当时我用了麻醉剂，陪在一旁的妻子后来告诉我，医生在显微镜里看了细胞之后叫了起来，原来这是一种少见的可以通过外科手术治愈的恶性肿瘤。我做了手术，现在好了。</p><p>This was the closest I’ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share.</p><p>这是我和死神离得最近的一次，我希望也是今后几十年里最近的一次。有了这次经历之后，现在我可以更加实在地和你们谈论死亡，而不是纯粹纸上谈兵，那就是: 谁都不愿意死。就是那些想进天堂的人也不愿意死后再进。然而，死亡是我们共同的归宿，没人能摆脱。</p><p>No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.</p><p>我们注定会死，因为死亡很可能是生命最好的一项发明。它推进生命的变迁，旧的不去，新的不来。现在，你们就是新的，但在不久的将来，你们也会逐渐成为旧的，也会被淘汰。对不起，话说得太过分了，不过这是千真万确的。</p><p>Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.</p><p>你们的时间都有限，所以不要按照别人的意愿去活，这是浪费时间。不要囿于成见，那是在按照别人设想的结果而活。不要让别人观点的聒噪声淹没自己的心声。最主要的是，要有跟着自己感觉和直觉走的勇气。无论如何，感觉和直觉早就知道你到底想成为什么样的人，其他都是次要的。</p><p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch.</p><p>我年轻时有一本非常好的刊物，叫《全球概览》，这是我那代人的宝书之一，创办人名叫斯图尔特布兰德，就住在离这儿不远的门洛帕克市。他用诗一般的语言把刊物办得生动活泼。</p><p>This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.</p><p>那是 20 世纪 60 年代末，还没有个人电脑和桌面印刷系统，全靠打字机、剪刀和宝丽莱照相机。它就像一种纸质的 Google，却比 Google 早问世了 35 年。这份刊物太完美了，查阅手段齐备、构思不凡。</p><p>Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age.</p><p>斯图尔特和他的同事们出了好几期《全球概览》，到最后办不下去时，他们出了最后一期。那是 20 世纪 70 年代中期，我也就是你们现在的年纪。</p><p>On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself.</p><p>最后一期的封底上是一张清晨乡间小路的照片，就是那种爱冒险的人等在那儿搭便车的那种小路。照片下面写道: 求知若饥、虚心若愚。那是他们停刊前的告别语。求知若渴，大智若愚。这也是我一直想做到的。</p><p>And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish.</p><p>眼下正值诸位大学毕业、开始新生活之际，我同样愿大家：求知若饥、虚心若愚。</p><p><img src="https://img-blog.csdnimg.cn/20190922204331298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>TED</category>
      </categories>
      <tags>
        <tag>TED</tag>
      </tags>
  </entry>
  <entry>
    <title>python列表生成式</title>
    <url>/2020/03/05/python%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>举个例子，要生成list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>可以用<code>list(range(1, 11))</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>但如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>   L.append(x * x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure><p>三层和三层以上的循环就很少用到了。</p><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></span><br><span class="line">[<span class="string">'.emacs.d'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'Adlm'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, <span class="string">'Documents'</span>, <span class="string">'Downloads'</span>, <span class="string">'Library'</span>, <span class="string">'Movies'</span>, <span class="string">'Music'</span>, <span class="string">'Pictures'</span>, <span class="string">'Public'</span>, <span class="string">'VirtualBox VMs'</span>, <span class="string">'Workspace'</span>, <span class="string">'XCode'</span>]</span><br></pre></td></tr></table></figure><p><code>for</code>循环其实可以同时使用两个甚至多个变量，比如<code>dict</code>的<code>items()</code>可以同时迭代key和value：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span>    print(k, <span class="string">'='</span>, v)</span><br><span class="line">...</span><br><span class="line">y = B</span><br><span class="line">x = A</span><br><span class="line">z = C</span><br></pre></td></tr></table></figure><p>因此，列表生成式也可以使用两个变量来生成list：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br></pre></td></tr></table></figure><p>最后把一个list中所有的字符串变成小写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</span><br></pre></td></tr></table></figure><h3 id="if-…-else"><a href="#if-…-else" class="headerlink" title="if … else"></a>if … else</h3><p>使用列表生成式的时候，有些童鞋经常搞不清楚<code>if...else</code>的用法。</p><p>例如，以下代码正常输出偶数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>但是，我们不能在最后的<code>if</code>加上<code>else</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">                                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这是因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code>，否则如何筛选？</p><p>另一些童鞋发现把<code>if</code>写在<code>for</code>前面必须加<code>else</code>，否则报错：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">                       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这是因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">-7</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>上述<code>for</code>前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。</p><p>可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>图解算法</title>
    <url>/2020/03/01/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h1><h2 id="1-第一章-算法简介"><a href="#1-第一章-算法简介" class="headerlink" title="1. 第一章 算法简介"></a><strong>1. 第一章 算法简介</strong></h2><p>1.2 二分查找<br>二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。使用二分查找时，每次都排除一半的数字。<br>一般而言，对于包含n个元素的列表，用二分查找最多需要<strong>log2n</strong>步，而简单查找最多需要<strong>n</strong>步。仅当列表是有序的时候，二分查找才管用。<br>二分法代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list)—<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high: <span class="comment">#只要范围没有缩小到只包含一个元素，就检查中间的元素</span></span><br><span class="line">        mid = (low + high)</span><br><span class="line">        guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == item:  <span class="comment">#找到了元素</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:  <span class="comment">#猜的数字大了</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:            <span class="comment">#猜的数字小了</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>   <span class="comment">#没有指定的元素</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">3</span>)  <span class="comment"># =&gt; 1</span></span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">-1</span>)  <span class="comment"># =&gt; None</span></span><br></pre></td></tr></table></figure><p>1.2.2 运行时间<br>二分查找的运行时间为对数时间（或log时间）。简单查找的运行时间为线性时间。</p><p>1.3 大 O表示法<br>算法的运行时间以不同的速度增加。<br>大O表示法指出了算法有多快，大O表示法指的并非以秒为单位的速度。 大O表示法让你能够比较操作数，它指出了算法运行时间的增速。二分查找需要执行log n次操作，使用大O表示法，O(log n)。简单查找的运行时间为O(n)。大O表示法说的是最糟的情形。</p><p>1.3.4 一些常见的大 O 运行时间（“阶指幂对”）<br>O(log n)，也叫对数时间，这样的算法包括二分查找。<br>O(n)，也叫线性时间，这样的算法包括简单查找。<br>O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。<br>O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。<br>O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</p><blockquote><p>小结：<br>\1. 算法的速度指的并非时间，而是操作数的增速。谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。<br>\2. 算法的运行时间用大O表示法表示。 O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。 算法运行时间并不以秒为单位。<br>\3. 算法运行时间是从其增速的角度度量的。</p></blockquote><h2 id="2-第二章-选择排序"><a href="#2-第二章-选择排序" class="headerlink" title="2. 第二章 选择排序"></a><strong>2. 第二章 选择排序</strong></h2><p>2.1 内存的工作原理<br>计算机就像是很多抽屉的集合体，每个抽屉都有地址。<br>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——<strong>数组和链表</strong>。<br>2.2 数组和链表<br>使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。<br>需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。<br>需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。<br>2.2.3 术语<br>元素的位置称为索引。<br><img src="https://img-blog.csdn.net/20180702203705464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>2.2.4 在中间插入<br>需要在中间插入元素时，数组和链表哪个更好呢？使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。</p><p>2.3 选择排序<br>需要的总时间为 O(n × n)，即O(n2)。<br>代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSmallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ar</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    newArr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        smallest = findSmallest(arr)</span><br><span class="line">        newArr.append(arr.pop(smallest))</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line"><span class="keyword">print</span> selectionSort([<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><h2 id="3-第三章-递归"><a href="#3-第三章-递归" class="headerlink" title="3. 第三章 递归"></a><strong>3. 第三章 递归</strong></h2><p>3.2 基线条件和递归条件<br>编写递归函数时，必须告诉它何时停止递归。正因为如此， 每个递归函数都有两部分：基线条件（ base case）和递归条件（ recursive case） 。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br>代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">0</span>:   <span class="comment">#基线条件</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:    <span class="comment">#递归条件</span></span><br><span class="line">        countdown(i<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>3.3 栈<br>栈是一种简单的数据结构，栈有两种操作：压入（插入）和弹出（删除并读取）。<br>每当调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。这个栈用于存储多个函数的变量，被称为调用栈。 调用栈可能很长，这将占用大量的内存。所有函数调用都进入调用栈。</p><h2 id="4-第四章-快速排序"><a href="#4-第四章-快速排序" class="headerlink" title="4. 第四章 快速排序"></a><strong>4. 第四章 快速排序</strong></h2><p>4.1 分而治之<br>D&amp;C算法包括两个步骤：<br>(1) 找出基线条件，这种条件必须尽可能简单。<br>(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。<br>D&amp;C的工作原理：<br>(1) 找出简单的基线条件；<br>(2) 确定如何缩小问题的规模，使其符合基线条件。</p><p>快速排序的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"><span class="keyword">print</span> quicksort([<span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>4.3 再谈大 O 表示法<br>快速排序的独特之处在于，其速度取决于选择的基准值。选择排序，其运行时间为O(n2)，速度非常慢。<br><img src="https://img-blog.csdn.net/20180703205638308?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>合并排序（ merge sort） 的排序算法，其运行时间为O(n log n)。比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。<br>4.4 小结<br>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。<br>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。<br>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， O(log n)的速度比O(n)快得多。</p><h2 id="5-第五章-散列表"><a href="#5-第五章-散列表" class="headerlink" title="5. 第五章 散列表"></a><strong>5. 第五章 散列表</strong></h2><p>运行时间O(n)和O(log n)之间有天壤之别！</p><ol><li>散列函数总是将同样的输入映射到相同的索引。</li><li>散列函数将不同的输入映射到不同的索引。</li><li>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。</li></ol><p>散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。</p><p>5.2.3 将散列表用作缓存<br>缓存的工作原理：网站将数据记住，而不再重新计算。<br>缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！</p><blockquote><p>散列表适合用于：</p><ol><li>模拟映射关系；</li><li>防止重复；</li><li>缓存/记住数据，以免服务器再通过处理来生成它们。</li></ol></blockquote><p>5.3 冲突<br>冲突（ collision） ：给两个键分配的位置相同。<br>处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。<br>散列函数很重要，好的散列函数很少导致冲突。</p><p>5.4 性能<br>在平均情况下，散列表执行各种操作的时间都为O(1)。 O(1)被称为常量时间。简单查找的运行时间为线性时间。二分查找的速度更快，所需时间为对数时间。在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。<br>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。<br>因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：<br> 较低的填装因子；<br> 良好的散列函数。</p><h2 id="6-第六章-广度优先搜索（-breadth-first-search，-BFS）"><a href="#6-第六章-广度优先搜索（-breadth-first-search，-BFS）" class="headerlink" title="6. 第六章 广度优先搜索（ breadth-first search， BFS）"></a><strong>6. 第六章 广度优先搜索（ breadth-first search， BFS）</strong></h2><p>广度优先搜索让你能够找出两样东西之间的最短距离，广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。<br>第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？）<br>第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？）<br>使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。<br><strong>广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。</strong></p><p>6.3.2 队列<br>队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作： 入队和出队。<br><strong>队列是一种先进先出（ First In First Out， FIFO）的数据结构，而栈是一种后进先出（ Last InFirst Out， LIFO）的数据结构。</strong><br>运行时间<br>如果你在你的整个人际关系网中搜索芒果销售商，就意味着你将沿每条边前行（记住，边是从一个人到另一个人的箭头或连接），因此运行时间至少为O(边数)。<br>你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（ vertice）数， E为边数。<br>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。</p><h2 id="7-第七章-狄克斯特拉算法"><a href="#7-第七章-狄克斯特拉算法" class="headerlink" title="7. 第七章 狄克斯特拉算法"></a><strong>7. 第七章 狄克斯特拉算法</strong></h2><p>应用场景：路由协议选路<br>广度优先搜索，它找出的是段数最少的路径，狄克斯特拉算法（ Dijkstra’s algorithm）找的是最快的路径。广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是段数最少。<strong>在狄克斯特拉算法中，你给每段都分配了一个数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。</strong><br>狄克斯特拉算法包含4个步骤。<br>(1) 找出“代价最低”的节点，即可在最短时间内到达的节点。<br>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。<br>(3) 重复这个过程，直到对图中的每个节点都这样做了。<br>(4) 计算最终路径。<br>带权重的图称为加权图（ weighted graph），不带权重的图称为非加权图（unweighted graph）。<br>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。<strong>狄克斯特拉算法只适用于有向无环图</strong>。<br>最短路径指的并不一定是物理距离，也可能是让某种度量指标最小。如果有负权边，就不能使用狄克斯特拉算法。因为负权边会导致这种算法不管用。</p><blockquote><p>7.6 小结</p><ol><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径。</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ol></blockquote><h2 id="8-第八章-贪婪算法"><a href="#8-第八章-贪婪算法" class="headerlink" title="8. 第八章 贪婪算法"></a><strong>8. 第八章 贪婪算法</strong></h2><p>贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。<br>8.2 背包问题<br>在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。<br>背包问题就是有若干物品，每个物品有自己的价值和重量。背包有总重量。问题就是怎样将背包装的最大价值。背包问题也分很多种，贪心算法解决的是物品可以拆分的背包问题（就是物品可以分成几份装入）。这个问题用贪心还是比较好解决的。贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。此问题就是将每次的放入看成每一步，要想解决问题，就是将每一步都放入最优解。也就是说，每一次的放入都要放入最佳的选择。讲到这里，就要说一说最佳的选择，每一次的放入的最佳的选择就是每次放入的物品都是剩余的物品中价值最大且质量最小的，这里就要引入一个物品的属性，物品的权重值。物品的权重值就是指物品的价值除以物品的质量。所以，本问题的每一次的最佳选择就是每次都选出权重值最大的物品。<br>近似算法<br>在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：<br> 速度有多快；<br> 得到的近似解与最优解的接近程度。</p><p>8.4 NP 完全问题(Non-deterministic Polynomial多项式的不确定性)<br>NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。<br>如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。</p><p> 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。<br> 涉及“所有组合”的问题通常是NP完全问题。<br> 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。<br> 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。<br> 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。<br> 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</p><blockquote><p>8.5 小结</p><ol><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。</li><li>对于NP完全问题，还没有找到快速解决方案。</li><li>面临NP完全问题时，最佳的做法是使用近似算法。</li><li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li></ol></blockquote><h2 id="9-第九章-动态规划"><a href="#9-第九章-动态规划" class="headerlink" title="9. 第九章 动态规划"></a><strong>9. 第九章 动态规划</strong></h2><p>9.1.2 动态规划<br>动态规划先解决子问题，再逐步解决大问题。<br>对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。<br>每个动态规划算法都从一个网格开始，网格的各行为商品，各列为不同容量（ 1～4磅）的背包。所有这些列你都需要，因为它们将帮助你计算子背包的价值。<br>动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。 但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。</p><blockquote><ol><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。</li><li>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。要设计出动态规划解决方案可能很难，这正是本节要介绍的。下面是一些通用的小贴士。</li><li>每种动态规划解决方案都涉及网格。</li></ol></blockquote><p>9.3.1 绘制网格<br>对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。</p><blockquote><p>9.4 小结</p><ol><li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li><li>问题可分解为离散子问题时，可使用动态规划来解决。</li><li>每种动态规划解决方案都涉及网格。</li><li>单元格中的值通常就是你要优化的值。</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li><li>没有放之四海皆准的计算动态规划解决方案的公式。</li></ol></blockquote><h2 id="10-第十章-K最近邻算法"><a href="#10-第十章-K最近邻算法" class="headerlink" title="10. 第十章 K最近邻算法"></a><strong>10. 第十章 K最近邻算法</strong></h2><p>KNN可以用来做两项基本工作——分类和回归：</p><ol><li>分类就是编组；</li><li>回归就是预测结果（如一个数字）。</li></ol><p><strong>余弦相似度（ cosine similarity）</strong><br>余弦相似度不计算两个矢量的距离，而比较它们的角度。<br>余弦相似度。余弦相似度被广泛用于协同过滤算法中，尤其是Item-base的协同过滤。<br>余弦相似度衡量的是两个向量间的夹角大小，通过夹角的余弦值表示结果，假设A向量是（x1, y1），B向量是(x2, y2)，那么两个向量的余弦相似度为：</p><p>分子为向量A与向量B的点乘，分母为二者各自的L2相乘，即将所有维度值的平方相加后开方。 余弦相似度的取值为[-1,1]，值越大表示越相似。</p><p>10.3.1 OCR<br>OCR指的是光学字符识别（ optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。 一般而言， OCR算法提取线段、点和曲线等特征。<br>OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（ training）。大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。</p><p>10.3.2 创建垃圾邮件过滤器<br>垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（ Naive Bayes classifier）。</p><blockquote><p>10.4 小结</p><ol><li>KNN用于分类和回归，需要考虑最近的邻居。</li><li>分类就是编组。</li><li>回归就是预测结果（如数字）。</li><li>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。</li><li>能否挑选合适的特征事关KNN算法的成败。</li></ol></blockquote><h2 id="11-第十一章-接下来如何做"><a href="#11-第十一章-接下来如何做" class="headerlink" title="11. 第十一章 接下来如何做"></a><strong>11. 第十一章 接下来如何做</strong></h2><p>二叉查找树（ binary search tree）<br>在二叉查找树中查找节点时，平均运行时间为O(log n)，但在最糟的情况下所需时间为O(n)；而在有序数组中查找时，即便是在最糟情况下所需的时间也只有O(log n)，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。<br><img src="https://img-blog.csdn.net/2018070419575199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>二叉查找树也存在一些缺点，例如，不能随机访问，在二叉查找树处于平衡状态时，平均访问时间也为O(log n)。</p><p>11.2 反向索引<br>一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（ inverted index），常用于创建搜索引擎。</p><p>11.4 并行算法<br>并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。<br>并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。<br>负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易， 10秒钟就完成了，而分配给内核B的任务都很难， 1分钟才完成。这意味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？</p><p>11.5 MapReduce<br>MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（ map）函数和归并（ reduce）函数。<br>11.5.2 映射函数<br>映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。<br>11.5.3 归并函数<br>归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。<br>MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。<br>11.6 布隆过滤器和 HyperLogLog<br>布隆过滤器是一种概率型数据结构，布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况，前面所有的示例都是这样的。<br>HyperLogLog是一种类似于布隆过滤器的算法。<br>HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。<br>面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！</p><p>11.7 SHA 算法<br>另一种散列函数是安全散列算法（ secure hash algorithm， SHA）函数。给定一个字符串， SHA返回其散列值。<br>SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。对于每个不同的字符串， SHA生成的散列值都不同。<br>你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。</p><p><strong>斐波那契数列</strong><br>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p><p>递归方式实现斐波那契数列 前n项:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归方式实现 生成前20项</span></span><br><span class="line">lis =[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">0</span> <span class="keyword">or</span> i ==<span class="number">1</span>:<span class="comment">#第1,2项 都为1</span></span><br><span class="line">        lis.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lis.append(lis[i<span class="number">-2</span>]+lis[i<span class="number">-1</span>])<span class="comment">#从第3项开始每项值为前两项值之和</span></span><br><span class="line">print(lis)<span class="number">12345678</span></span><br><span class="line"> <span class="comment">#递归函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_function_tool</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Fibonacci_function_tool(n - <span class="number">1</span>) + Fibonacci_function_tool(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_function</span><span class="params">(n)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>): result_list.append(Fibonacci_function_tool(i))</span><br><span class="line">    <span class="keyword">return</span> result_list</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你彻底掌握 shell 语言</title>
    <url>/2020/06/01/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Shell/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="一篇文章让你彻底掌握-shell-语言"><a href="#一篇文章让你彻底掌握-shell-语言" class="headerlink" title="一篇文章让你彻底掌握 shell 语言"></a>一篇文章让你彻底掌握 shell 语言</h1><blockquote><p>由于 bash 是 Linux 标准默认的 shell 解释器，可以说 bash 是 shell 编程的基础。</p><p>本文主要介绍 bash 的语法，对于 linux 指令不做任何介绍。</p><p>📓 本文已归档到：<a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">notes</a><br>⌨️ 本文的源码已归档到 <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos" target="_blank" rel="noopener">os-tutorial</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">███████╗	██╗  ██╗	███████╗	██╗     	██╗</span><br><span class="line">██╔════╝	██║  ██║	██╔════╝	██║     	██║</span><br><span class="line">███████╗	███████║	█████╗  	██║     	██║</span><br><span class="line">╚════██║	██╔══██║	██╔══╝  	██║     	██║</span><br><span class="line">███████║	██║  ██║	███████╗	███████╗	███████╗</span><br></pre></td></tr></table></figure><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-什么是-shell"><a href="#1-1-什么是-shell" class="headerlink" title="1.1. 什么是 shell"></a>1.1. 什么是 shell</h3><ul><li>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li><li>Shell 既是一种命令语言，又是一种程序设计语言。</li><li>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。</li></ul><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h3 id="1-2-什么是-shell-脚本"><a href="#1-2-什么是-shell-脚本" class="headerlink" title="1.2. 什么是 shell 脚本"></a>1.2. 什么是 shell 脚本</h3><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 <code>.sh</code>。</p><p>业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。</p><h3 id="1-3-Shell-环境"><a href="#1-3-Shell-环境" class="headerlink" title="1.3. Shell 环境"></a>1.3. Shell 环境</h3><p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Shell 的解释器种类众多，常见的有：</p><ul><li><a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">sh</a> - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。</li><li><a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">bash</a> - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。</li><li><a href="https://fishshell.com/" target="_blank" rel="noopener">fish</a> - 智能和用户友好的命令行 shell。</li><li><a href="http://xiki.org/" target="_blank" rel="noopener">xiki</a> - 使 shell 控制台更友好，更强大。</li><li><a href="http://www.zsh.org/" target="_blank" rel="noopener">zsh</a> - 功能强大的 shell 与脚本语言。</li></ul><h4 id="指定脚本解释器"><a href="#指定脚本解释器" class="headerlink" title="指定脚本解释器"></a>指定脚本解释器</h4><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang（也称为 Hashbang ）</a>。</p><p>所以，你应该会在 shell 中，见到诸如以下的注释：</p><ul><li>指定 sh 解释器</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure><ul><li>指定 bash 解释器</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure><p>这样做的好处是，系统会自动在 <code>PATH</code> 环境变量中查找你指定的程序（本例中的<code>bash</code>）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的<code>PATH</code>变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的<code>bash</code>，我们可能将其路径添加到<code>PATH</code>中，来“隐藏”老版本。如果直接用<code>#!/bin/bash</code>，那么系统会选择老版本的<code>bash</code>来执行脚本，如果用<code>#!/usr/bin/env bash</code>，则会使用新版本。</p></blockquote><h3 id="1-4-模式"><a href="#1-4-模式" class="headerlink" title="1.4. 模式"></a>1.4. 模式</h3><p>shell 有交互和非交互两种模式。</p><h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><blockquote><p>简单来说，你可以将 shell 的交互模式理解为执行命令行。</p></blockquote><p>看到形如下面的东西，说明 shell 处于交互模式下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user@host:~$</span><br></pre></td></tr></table></figure><p>接着，便可以输入一系列 Linux 命令，比如 <code>ls</code>，<code>grep</code>，<code>cd</code>，<code>mkdir</code>，<code>rm</code> 等等。</p><h4 id="非交互模式"><a href="#非交互模式" class="headerlink" title="非交互模式"></a>非交互模式</h4><blockquote><p>简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。</p></blockquote><p>在非交互模式下，shell 从文件或者管道中读取命令并执行。</p><p>当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。</p><p>可以使用下面的命令让 shell 以非交互模式运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh /path/to/script.sh</span><br><span class="line">bash /path/to/script.sh</span><br><span class="line"><span class="built_in">source</span> /path/to/script.sh</span><br><span class="line">./path/to/script.sh</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>script.sh</code>是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，<code>sh</code>和<code>bash</code>是 shell 解释器程序。你可以使用任何喜欢的编辑器创建<code>script.sh</code>（vim，nano，Sublime Text, Atom 等等）。</p><p>其中，<code>source /path/to/script.sh</code> 和 <code>./path/to/script.sh</code> 是等价的。</p><p>除此之外，你还可以通过<code>chmod</code>命令给文件添加可执行的权限，来直接执行脚本文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /path/to/script.sh <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">/path/to/test.sh</span><br></pre></td></tr></table></figure><p>这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如：</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/helloworld.sh" target="_blank" rel="noopener">helloworld.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们使用了一个很有用的命令<code>echo</code>来输出字符串到屏幕上。</p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="2-1-解释器"><a href="#2-1-解释器" class="headerlink" title="2.1. 解释器"></a>2.1. 解释器</h3><p>前面虽然两次提到了<code>#!</code> ，但是本着重要的事情说三遍的精神，这里再强调一遍：</p><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang（也称为 Hashbang ）</a>。</p><p><code>#!</code> 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入<code>sh</code>, <code>bash</code>, <code>python</code>, <code>php</code>等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure><h3 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2. 注释"></a>2.2. 注释</h3><p>注释可以说明你的代码是什么作用，以及为什么这样写。</p><p>shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。</p><ul><li>单行注释 - 以 <code>#</code> 开头，到行尾结束。</li><li>多行注释 - 以 <code>:&lt;&lt;EOF</code> 开头，到 <code>EOF</code> 结束。</li></ul><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/comment-demo.sh" target="_blank" rel="noopener">comment-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment"># shell 注释示例</span></span><br><span class="line"><span class="comment"># author：zp</span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo '这是单行注释'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## 这是分割线 ##########</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-3-echo"><a href="#2-3-echo" class="headerlink" title="2.3. echo"></a>2.3. echo</h3><p>echo 用于字符串的输出。</p><p>输出普通字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello, world"</span></span><br><span class="line"><span class="comment"># Output: hello, world</span></span><br></pre></td></tr></table></figure><p>输出含变量的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment"># Output: hello, "zp"</span></span><br></pre></td></tr></table></figure><p>输出含变量的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=zp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"<span class="variable">$&#123;name&#125;</span>\""</span></span><br><span class="line"><span class="comment"># Output: hello, "zp"</span></span><br></pre></td></tr></table></figure><p>输出含换行符的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出含换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"YES\nNO"</span></span><br><span class="line"><span class="comment">#  Output: YES\nNO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\nNO"</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br></pre></td></tr></table></figure><p>输出含不换行符的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"YES"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\c"</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YESNO</span></span><br></pre></td></tr></table></figure><p>输出重定向至文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; test.txt</span><br></pre></td></tr></table></figure><p>输出执行结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#  Output:(当前目录路径)</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/echo-demo.sh" target="_blank" rel="noopener">echo-demo.sh</a></p><h3 id="2-4-printf"><a href="#2-4-printf" class="headerlink" title="2.4. printf"></a>2.4. printf</h3><p>printf 用于格式化输出字符串。</p><p>默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 <code>\n</code>。</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/printf-demo.sh" target="_blank" rel="noopener">printf-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'%d %s\n'</span> 1 <span class="string">"abc"</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%d %s\n"</span> 1 <span class="string">"abc"</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无引号</span></span><br><span class="line"><span class="built_in">printf</span> %s abcdef</span><br><span class="line"><span class="comment">#  Output: abcdef(并不会换行)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> abc def</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  abc</span></span><br><span class="line"><span class="comment">#  def</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s\n"</span> a b c d e f g h i j</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  a b c</span></span><br><span class="line"><span class="comment">#  d e f</span></span><br><span class="line"><span class="comment">#  g h i</span></span><br><span class="line"><span class="comment">#  j</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s and %d \n"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#   and 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4s\n"</span> 姓名 性别 体重kg</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭靖 男 66.1234</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 杨过 男 48.6543</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭芙 女 47.9876</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  姓名     性别   体重kg</span></span><br><span class="line"><span class="comment">#  郭靖     男      66.12</span></span><br><span class="line"><span class="comment">#  杨过     男      48.65</span></span><br><span class="line"><span class="comment">#  郭芙     女      47.99</span></span><br></pre></td></tr></table></figure><h4 id="printf-的转义符"><a href="#printf-的转义符" class="headerlink" title="printf 的转义符"></a>printf 的转义符</h4><table><thead><tr><th>序列</th><th>说明</th></tr></thead><tbody><tr><td><code>\a</code></td><td>警告字符，通常为 ASCII 的 BEL 字符</td></tr><tr><td><code>\b</code></td><td>后退</td></tr><tr><td><code>\c</code></td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td><code>\f</code></td><td>换页（formfeed）</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车（Carriage return）</td></tr><tr><td><code>\t</code></td><td>水平制表符</td></tr><tr><td><code>\v</code></td><td>垂直制表符</td></tr><tr><td><code>\\</code></td><td>一个字面上的反斜杠字符</td></tr><tr><td><code>\ddd</code></td><td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td><code>\0ddd</code></td><td>表示 1 到 3 位的八进制值字符</td></tr></tbody></table><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p>跟许多程序设计语言一样，你可以在 bash 中创建变量。</p><p>Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。</p><h3 id="3-1-变量命名原则"><a href="#3-1-变量命名原则" class="headerlink" title="3.1. 变量命名原则"></a>3.1. 变量命名原则</h3><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li></ul><h3 id="3-2-声明变量"><a href="#3-2-声明变量" class="headerlink" title="3.2. 声明变量"></a>3.2. 声明变量</h3><p>访问变量的语法形式为：<code>${var}</code> 和 <code>$var</code> 。</p><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">word=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;word&#125;</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br></pre></td></tr></table></figure><h3 id="3-3-只读变量"><a href="#3-3-只读变量" class="headerlink" title="3.3. 只读变量"></a>3.3. 只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rword=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;rword&#125;</span></span><br><span class="line"><span class="built_in">readonly</span> rword</span><br><span class="line"><span class="comment"># rword="bye"  # 如果放开注释，执行时会报错</span></span><br></pre></td></tr></table></figure><h3 id="3-4-删除变量"><a href="#3-4-删除变量" class="headerlink" title="3.4. 删除变量"></a>3.4. 删除变量</h3><p>使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dword=<span class="string">"hello"</span>  <span class="comment"># 声明变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span>  <span class="comment"># 输出变量值</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> dword    <span class="comment"># 删除变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span></span><br><span class="line"><span class="comment"># Output: （空）</span></span><br></pre></td></tr></table></figure><h3 id="3-5-变量类型"><a href="#3-5-变量类型" class="headerlink" title="3.5. 变量类型"></a>3.5. 变量类型</h3><ul><li><strong>局部变量</strong> - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。</li><li><strong>环境变量</strong> - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 <code>export</code> 关键字，shell 脚本也可以定义环境变量。</li></ul><p>常见的环境变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$HOME</code></td><td>当前用户的用户目录</td></tr><tr><td><code>$PATH</code></td><td>用分号分隔的目录列表，shell 会到这些目录中查找命令</td></tr><tr><td><code>$PWD</code></td><td>当前工作目录</td></tr><tr><td><code>$RANDOM</code></td><td>0 到 32767 之间的整数</td></tr><tr><td><code>$UID</code></td><td>数值类型，当前用户的用户 ID</td></tr><tr><td><code>$PS1</code></td><td>主要系统输入提示符</td></tr><tr><td><code>$PS2</code></td><td>次要系统输入提示符</td></tr></tbody></table><p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html###sect_03_02_04" target="_blank" rel="noopener">这里</a> 有一张更全面的 Bash 环境变量列表。</p><h3 id="3-6-变量示例源码"><a href="#3-6-变量示例源码" class="headerlink" title="3.6. 变量示例源码"></a>3.6. 变量示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/variable-demo.sh" target="_blank" rel="noopener">variable-demo.sh</a></p><h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><h3 id="4-1-单引号和双引号"><a href="#4-1-单引号和双引号" class="headerlink" title="4.1. 单引号和双引号"></a>4.1. 单引号和双引号</h3><p>shell 字符串可以用单引号 <code>&#39;&#39;</code>，也可以用双引号 <code>“”</code>，也可以不用引号。</p><ul><li>单引号的特点<ul><li>单引号里不识别变量</li><li>单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。</li></ul></li><li>双引号的特点<ul><li>双引号里识别变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><p>综上，推荐使用双引号。</p><h3 id="4-2-拼接字符串"><a href="#4-2-拼接字符串" class="headerlink" title="4.2. 拼接字符串"></a>4.2. 拼接字符串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">name1=<span class="string">'white'</span></span><br><span class="line">str1=<span class="string">'hello, '</span><span class="variable">$&#123;name1&#125;</span><span class="string">''</span></span><br><span class="line">str2=<span class="string">'hello, $&#123;name1&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str1&#125;</span>_<span class="variable">$&#123;str2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, white_hello, $&#123;name1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">name2=<span class="string">"black"</span></span><br><span class="line">str3=<span class="string">"hello, "</span><span class="variable">$&#123;name2&#125;</span><span class="string">""</span></span><br><span class="line">str4=<span class="string">"hello, <span class="variable">$&#123;name2&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str3&#125;</span>_<span class="variable">$&#123;str4&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, black_hello, black</span></span><br></pre></td></tr></table></figure><h3 id="4-3-获取字符串长度"><a href="#4-3-获取字符串长度" class="headerlink" title="4.3. 获取字符串长度"></a>4.3. 获取字符串长度</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#text&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h3 id="4-4-截取子字符串"><a href="#4-4-截取子字符串" class="headerlink" title="4.4. 截取子字符串"></a>4.4. 截取子字符串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;text:2:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 34</span></span><br></pre></td></tr></table></figure><p>从第 3 个字符开始，截取 2 个字符</p><h3 id="4-5-查找子字符串"><a href="#4-5-查找子字符串" class="headerlink" title="4.5. 查找子字符串"></a>4.5. 查找子字符串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">text=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$&#123;text&#125;</span>"</span> ll`</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute: ./str-demo5.sh</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>查找 <code>ll</code> 子字符在 <code>hello</code> 字符串中的起始位置。</p><h3 id="4-6-字符串示例源码"><a href="#4-6-字符串示例源码" class="headerlink" title="4.6. 字符串示例源码"></a>4.6. 字符串示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/string-demo.sh" target="_blank" rel="noopener">string-demo.sh</a></p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><p>bash 只支持一维数组。</p><p>数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h3 id="5-1-创建数组"><a href="#5-1-创建数组" class="headerlink" title="5.1. 创建数组"></a>5.1. 创建数组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数组的不同方式</span></span><br><span class="line">nums=([2]=2 [0]=0 [1]=1)</span><br><span class="line">colors=(red yellow <span class="string">"dark blue"</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-访问数组元素"><a href="#5-2-访问数组元素" class="headerlink" title="5.2. 访问数组元素"></a>5.2. 访问数组元素</h3><ul><li><strong>访问数组的单个元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[1]&#125;</span></span><br><span class="line"><span class="comment"># Output: 1</span></span><br></pre></td></tr></table></figure><ul><li><strong>访问数组的所有元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br></pre></td></tr></table></figure><p>上面两行有很重要（也很微妙）的区别：</p><p>为了将数组中每个元素单独一行输出，我们用 <code>printf</code> 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark</span></span><br><span class="line"><span class="comment"># + blue</span></span><br></pre></td></tr></table></figure><p>为什么<code>dark</code>和<code>blue</code>各占了一行？尝试用引号包起来：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[*]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red yellow dark blue</span></span><br></pre></td></tr></table></figure><p>现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试<code>${colors[@]}</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark blue</span></span><br></pre></td></tr></table></figure><p>在引号内，<code>${colors[@]}</code>将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。</p><ul><li><strong>访问数组的部分元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]:0:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 0 1</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>${array[@]}</code> 扩展为整个数组，<code>:0:2</code>取出了数组中从 0 开始，长度为 2 的元素。</p><h3 id="5-3-访问数组长度"><a href="#5-3-访问数组长度" class="headerlink" title="5.3. 访问数组长度"></a>5.3. 访问数组长度</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#nums[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="5-4-向数组中添加元素"><a href="#5-4-向数组中添加元素" class="headerlink" title="5.4. 向数组中添加元素"></a>5.4. 向数组中添加元素</h3><p>向数组中添加元素也非常简单：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colors=(white <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span> green black)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># white red yellow dark blue green black</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>${colors[@]}</code> 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组<code>colors</code>的赋值覆盖了它原来的值。</p><h3 id="5-5-从数组中删除元素"><a href="#5-5-从数组中删除元素" class="headerlink" title="5.5. 从数组中删除元素"></a>5.5. 从数组中删除元素</h3><p>用<code>unset</code>命令来从数组中删除一个元素：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> nums[0]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure><h3 id="5-6-数组示例源码"><a href="#5-6-数组示例源码" class="headerlink" title="5.6. 数组示例源码"></a>5.6. 数组示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/array-demo.sh" target="_blank" rel="noopener">array-demo.sh</a></p><h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h2><h3 id="6-1-算术运算符"><a href="#6-1-算术运算符" class="headerlink" title="6.1. 算术运算符"></a>6.1. 算术运算符</h3><p>下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $x + $y</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr $x - $y</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr $x * $y</code> 结果为 200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr $y / $x</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr $y % $x</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td><code>x=$y</code> 将把变量 y 的值赋给 x。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true。</td><td><code>[ $x == $y ]</code> 返回 false。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td><code>[ $x != $y ]</code> 返回 true。</td></tr></tbody></table><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <code>[$x==$y]</code> 是错误的，必须写成 <code>[ $x == $y ]</code>。</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo.sh" target="_blank" rel="noopener">operator-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> == <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 + 20 = 30</span></span><br><span class="line"><span class="comment">#  10 - 20 = -10</span></span><br><span class="line"><span class="comment">#  10 * 20 = 200</span></span><br><span class="line"><span class="comment">#  20 / 10 = 2</span></span><br><span class="line"><span class="comment">#  20 % 10 = 0</span></span><br><span class="line"><span class="comment">#  10 != 20</span></span><br></pre></td></tr></table></figure><h3 id="6-2-关系运算符"><a href="#6-2-关系运算符" class="headerlink" title="6.2. 关系运算符"></a>6.2. 关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>检测两个数是否相等，相等返回 true。</td><td><code>[ $a -eq $b ]</code>返回 false。</td></tr><tr><td><code>-ne</code></td><td>检测两个数是否相等，不相等返回 true。</td><td><code>[ $a -ne $b ]</code> 返回 true。</td></tr><tr><td><code>-gt</code></td><td>检测左边的数是否大于右边的，如果是，则返回 true。</td><td><code>[ $a -gt $b ]</code> 返回 false。</td></tr><tr><td><code>-lt</code></td><td>检测左边的数是否小于右边的，如果是，则返回 true。</td><td><code>[ $a -lt $b ]</code> 返回 true。</td></tr><tr><td><code>-ge</code></td><td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td><code>[ $a -ge $b ]</code> 返回 false。</td></tr><tr><td><code>-le</code></td><td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td><code>[ $a -le $b ]</code>返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo2.sh" target="_blank" rel="noopener">operator-demo2.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> : x 等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 大于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 不大于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 小于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 不小于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 大于或等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 小于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 小于或等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 大于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo2.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -eq 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -ne 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -gt 20: x 不大于 y</span></span><br><span class="line"><span class="comment">#  10 -lt 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -ge 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -le 20: x 小于或等于 y</span></span><br></pre></td></tr></table></figure><h3 id="6-3-布尔运算符"><a href="#6-3-布尔运算符" class="headerlink" title="6.3. 布尔运算符"></a>6.3. 布尔运算符</h3><p>下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>!</code></td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td><code>[ ! false ]</code> 返回 true。</td></tr><tr><td><code>-o</code></td><td>或运算，有一个表达式为 true 则返回 true。</td><td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td></tr><tr><td><code>-a</code></td><td>与运算，两个表达式都为 true 才返回 true。</td><td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo3.sh" target="_blank" rel="noopener">operator-demo3.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 15 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 5 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo3.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 != 20 : x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 小于 100 且 20 大于 15 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 100 或 20 大于 100 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 5 或 20 大于 100 : 返回 false</span></span><br></pre></td></tr></table></figure><h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4. 逻辑运算符"></a>6.4. 逻辑运算符</h3><p>以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20:</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑的 AND</td><td><code>[[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]]</code> 返回 false</td></tr><tr><td>`</td><td></td><td>`</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo4.sh" target="_blank" rel="noopener">operator-demo4.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo4.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -lt 100 &amp;&amp; 20 -gt 100 返回 false</span></span><br><span class="line"><span class="comment">#  10 -lt 100 || 20 -gt 100 返回 true</span></span><br></pre></td></tr></table></figure><h3 id="6-5-字符串运算符"><a href="#6-5-字符串运算符" class="headerlink" title="6.5. 字符串运算符"></a>6.5. 字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>=</code></td><td>检测两个字符串是否相等，相等返回 true。</td><td><code>[ $a = $b ]</code> 返回 false。</td></tr><tr><td><code>!=</code></td><td>检测两个字符串是否相等，不相等返回 true。</td><td><code>[ $a != $b ]</code> 返回 true。</td></tr><tr><td><code>-z</code></td><td>检测字符串长度是否为 0，为 0 返回 true。</td><td><code>[ -z $a ]</code> 返回 false。</td></tr><tr><td><code>-n</code></td><td>检测字符串长度是否为 0，不为 0 返回 true。</td><td><code>[ -n $a ]</code> 返回 true。</td></tr><tr><td><code>str</code></td><td>检测字符串是否为空，不为空返回 true。</td><td><code>[ $a ]</code> 返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo5.sh" target="_blank" rel="noopener">operator-demo5.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=<span class="string">"abc"</span></span><br><span class="line">y=<span class="string">"xyz"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> : x 等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$&#123;x&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> : 字符串不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> : 字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo5.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=abc, y=xyz</span></span><br><span class="line"><span class="comment">#  abc = xyz: x 不等于 y</span></span><br><span class="line"><span class="comment">#  abc != xyz : x 不等于 y</span></span><br><span class="line"><span class="comment">#  -z abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  -n abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  abc : 字符串不为空</span></span><br></pre></td></tr></table></figure><h3 id="6-6-文件测试运算符"><a href="#6-6-文件测试运算符" class="headerlink" title="6.6. 文件测试运算符"></a>6.6. 文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td><code>[ -b $file ]</code> 返回 false。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td><code>[ -c $file ]</code> 返回 false。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td><td><code>[ -d $file ]</code> 返回 false。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td><code>[ -f $file ]</code> 返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td><code>[ -g $file ]</code> 返回 false。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td><code>[ -k $file ]</code>返回 false。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td><code>[ -p $file ]</code> 返回 false。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td><code>[ -u $file ]</code> 返回 false。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td><td><code>[ -r $file ]</code> 返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td><td><code>[ -w $file ]</code> 返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td><td><code>[ -x $file ]</code> 返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td><td><code>[ -s $file ]</code> 返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td><td><code>[ -e $file ]</code> 返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo6.sh" target="_blank" rel="noopener">operator-demo6.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file=<span class="string">"/etc/hosts"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -r <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可读"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可读"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -w <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可写"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可写"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -x <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可执行"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可执行"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为普通文件"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为特殊文件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件是个目录"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不是个目录"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -s <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -e <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo6.sh</span></span><br><span class="line"><span class="comment">#  Output:(根据文件的实际情况，输出结果可能不同)</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可读</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可写</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不可执行</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件为普通文件</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不是个目录</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不为空</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件存在</span></span><br></pre></td></tr></table></figure><h2 id="7-控制语句"><a href="#7-控制语句" class="headerlink" title="7. 控制语句"></a>7. 控制语句</h2><h3 id="7-1-条件语句"><a href="#7-1-条件语句" class="headerlink" title="7.1. 条件语句"></a>7.1. 条件语句</h3><p>跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在<code>[[ ]]</code>里的表达式。</p><p>由<code>[[ ]]</code>（<code>sh</code>中是<code>[ ]</code>）包起来的表达式被称作 <strong>检测命令</strong> 或 <strong>基元</strong>。这些表达式帮助我们检测一个条件的结果。这里可以找到有关<a href="http://serverfault.com/a/52050" target="_blank" rel="noopener">bash 中单双中括号区别</a>的答案。</p><p>共有两个不同的条件表达式：<code>if</code>和<code>case</code>。</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h4><p>（1）<code>if</code> 语句</p><p><code>if</code>在使用上跟其它语言相同。如果中括号里的表达式为真，那么<code>then</code>和<code>fi</code>之间的代码会被执行。<code>fi</code>标志着条件代码块的结束。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写成一行</span></span><br><span class="line"><span class="keyword">if</span> [[ 1 -eq 1 ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"1 -eq 1 result is: true"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 1 -eq 1 result is: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写成多行</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"abc"</span> -eq <span class="string">"abc"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">""</span>abc<span class="string">" -eq "</span>abc<span class="string">" result is: true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: abc -eq abc result is: true</span></span><br></pre></td></tr></table></figure><p>（2）<code>if else</code> 语句</p><p>同样，我们可以使用<code>if..else</code>语句，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 2 -ne 1 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: true</span></span><br></pre></td></tr></table></figure><p>（3）<code>if elif else</code> 语句</p><p>有些时候，<code>if..else</code>不能满足我们的要求。别忘了<code>if..elif..else</code>，使用起来也很方便。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 10 &lt; 20</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/if-demo.sh" target="_blank" rel="noopener">if-demo.sh</a></p><h4 id="case"><a href="#case" class="headerlink" title="case"></a><code>case</code></h4><p>如果你需要面对很多情况，分别要采取不同的措施，那么使用<code>case</code>会比嵌套的<code>if</code>更有用。使用<code>case</code>来解决复杂的条件判断，看起来像下面这样：</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/case-demo.sh" target="_blank" rel="noopener">case-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">"+"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"-"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"*"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"/"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unknown oper!"</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>每种情况都是匹配了某个模式的表达式。<code>|</code>用来分割多个模式，<code>)</code>用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。<code>*</code>代表任何不匹配以上给定模式的模式。命令块儿之间要用<code>;;</code>分隔。</p><h3 id="7-2-循环语句"><a href="#7-2-循环语句" class="headerlink" title="7.2. 循环语句"></a>7.2. 循环语句</h3><p>循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。</p><p>Bash 中有四种循环：<code>for</code>，<code>while</code>，<code>until</code>和<code>select</code>。</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><p><code>for</code>与它在 C 语言中的姊妹非常像。看起来是这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>在每次循环的过程中，<code>arg</code>依次被赋值为从<code>elem1</code>到<code>elemN</code>。这些值还可以是通配符或者<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#大括号扩展" target="_blank" rel="noopener">大括号扩展</a>。</p><p>当然，我们还可以把<code>for</code>循环写在一行，但这要求<code>do</code>之前要有一个分号，就像下面这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>还有，如果你觉得<code>for..in..do</code>对你来说有点奇怪，那么你也可以像 C 语言那样使用<code>for</code>，比如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 10; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>当我们想对一个目录下的所有文件做同样的操作时，<code>for</code>就很方便了。举个例子，如果我们想把所有的<code>.bash</code>文件移动到<code>script</code>文件夹中，并给它们可执行权限，我们的脚本可以这样写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DIR=/home/zp</span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$&#123;DIR&#125;</span>/*.sh; <span class="keyword">do</span></span><br><span class="line">  mv <span class="string">"<span class="variable">$FILE</span>"</span> <span class="string">"<span class="variable">$&#123;DIR&#125;</span>/scripts"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/for-demo.sh" target="_blank" rel="noopener">for-demo.sh</a></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h4><p><code>while</code>循环检测一个条件，只要这个条件为 <em>真</em>，就执行一段命令。被检测的条件跟<code>if..then</code>中使用的<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#基元和组合表达式" target="_blank" rel="noopener">基元</a>并无二异。因此一个<code>while</code>循环看起来会是这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [[ condition ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>跟<code>for</code>循环一样，如果我们把<code>do</code>和被检测的条件写到一行，那么必须要在<code>do</code>之前加一个分号。</p><p>比如下面这个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 0到9之间每个数的平方</span></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> $((x * x))</span><br><span class="line">  x=$((x + 1))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  4</span></span><br><span class="line"><span class="comment">#  9</span></span><br><span class="line"><span class="comment">#  16</span></span><br><span class="line"><span class="comment">#  25</span></span><br><span class="line"><span class="comment">#  36</span></span><br><span class="line"><span class="comment">#  49</span></span><br><span class="line"><span class="comment">#  64</span></span><br><span class="line"><span class="comment">#  81</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/while-demo.sh" target="_blank" rel="noopener">while-demo.sh</a></p><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a><code>until</code>循环</h4><p><code>until</code>循环跟<code>while</code>循环正好相反。它跟<code>while</code>一样也需要检测一个测试条件，但不同的是，只要该条件为 <em>假</em> 就一直执行循环：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=0</span><br><span class="line">until [[ <span class="variable">$&#123;x&#125;</span> -ge 5 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span></span><br><span class="line">  x=`expr <span class="variable">$&#123;x&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  2</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  4</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/until-demo.sh" target="_blank" rel="noopener">until-demo.sh</a></p><h4 id="select循环"><a href="#select循环" class="headerlink" title="select循环"></a><code>select</code>循环</h4><p><code>select</code>循环帮助我们组织一个用户菜单。它的语法几乎跟<code>for</code>循环一致：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select answer <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>select</code>会打印<code>elem1..elemN</code>以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是<code>$?</code>（<code>PS3</code>变量）。用户的选择结果会被保存到<code>answer</code>中。如果<code>answer</code>是一个在<code>1..N</code>之间的数字，那么<code>语句</code>会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用<code>break</code>语句。</p><p>一个可能的实例可能会是这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">PS3=<span class="string">"Choose the package manager: "</span></span><br><span class="line">select ITEM <span class="keyword">in</span> bower npm gem pip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Enter the package name: "</span> &amp;&amp; <span class="built_in">read</span> PACKAGE</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;ITEM&#125;</span> <span class="keyword">in</span></span><br><span class="line">  bower) bower install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  npm) npm install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  gem) gem install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  pip) pip install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">break</span> <span class="comment"># 避免无限循环</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。</p><p>运行这个脚本，会得到如下输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">1) bower</span><br><span class="line">2) npm</span><br><span class="line">3) gem</span><br><span class="line">4) pip</span><br><span class="line">Choose the package manager: 2</span><br><span class="line">Enter the package name: gitbook-cli</span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/select-demo.sh" target="_blank" rel="noopener">select-demo.sh</a></p><h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a><code>break</code> 和 <code>continue</code></h4><p>如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的<code>break</code>和<code>continue</code>语句来实现。它们可以在任何循环中使用。</p><blockquote><p><code>break</code>语句用来提前结束当前循环。</p><p><code>continue</code>语句用来跳过某次迭代。</p></blockquote><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/break-demo.sh" target="_blank" rel="noopener">break-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找 10 以内第一个能整除 2 和 3 的正整数</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;i&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % 3)) -eq 0 ]] &amp;&amp; [[ $((i % 2)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  i=`expr <span class="variable">$&#123;i&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># Output: 6</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/continue-demo.sh" target="_blank" rel="noopener">continue-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印10以内的奇数</span></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 10; i ++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % 2)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  5</span></span><br><span class="line"><span class="comment">#  7</span></span><br><span class="line"><span class="comment">#  9</span></span><br></pre></td></tr></table></figure><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><p>bash 函数定义语法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()] &#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 说明：</p><ol><li>函数定义时，<code>function</code> 关键字可有可无。</li><li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。</li><li>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</li><li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li></ol></blockquote><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo.sh" target="_blank" rel="noopener">function-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">calc</span></span>()&#123;</span><br><span class="line">  PS3=<span class="string">"choose the oper: "</span></span><br><span class="line">  select oper <span class="keyword">in</span> + - \* / <span class="comment"># 生成操作符选择菜单</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"enter first num: "</span> &amp;&amp; <span class="built_in">read</span> x <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"enter second num: "</span> &amp;&amp; <span class="built_in">read</span> y <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">exec</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"+"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"-"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"*"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"/"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;oper&#125;</span> is not support!"</span></span><br><span class="line">      <span class="built_in">return</span> 0</span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">calc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the result is: $?"</span> <span class="comment"># $? 获取 calc 函数返回值</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./<span class="keyword">function</span>-demo.sh</span><br><span class="line">1) +</span><br><span class="line">2) -</span><br><span class="line">3) *</span><br><span class="line">4) /</span><br><span class="line">choose the oper: 3</span><br><span class="line">enter first num: 10</span><br><span class="line">enter second num: 10</span><br><span class="line">the result is: 100</span><br></pre></td></tr></table></figure><h3 id="8-1-位置参数"><a href="#8-1-位置参数" class="headerlink" title="8.1. 位置参数"></a>8.1. 位置参数</h3><p><strong>位置参数</strong>是在调用一个函数并传给它参数时创建的变量。</p><p>位置参数变量表：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本名称</td></tr><tr><td><code>$1 … $9</code></td><td>第 1 个到第 9 个参数列表</td></tr><tr><td><code>${10} … ${N}</code></td><td>第 10 个到 N 个参数列表</td></tr><tr><td><code>$*</code> or <code>$@</code></td><td>除了<code>$0</code>外的所有位置参数</td></tr><tr><td><code>$#</code></td><td>不包括<code>$0</code>在内的位置参数的个数</td></tr><tr><td><code>$FUNCNAME</code></td><td>函数名称（仅在函数内部有值）</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo2.sh" target="_blank" rel="noopener">function-demo2.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span></span><br><span class="line">  x=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第一个参数为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">y=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$2</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第二个参数为：<span class="variable">$2</span>"</span></span><br><span class="line">  y=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第二个参数为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第一个入参：<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第二个入参：<span class="variable">$2</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction <span class="variable">$&#123;x&#125;</span> <span class="variable">$&#123;y&#125;</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./<span class="keyword">function</span>-demo2.sh</span><br><span class="line">第一个参数为空</span><br><span class="line">第二个参数为空</span><br><span class="line">函数第一个入参：0</span><br><span class="line">函数第二个入参：0</span><br><span class="line"></span><br><span class="line">$ ./<span class="keyword">function</span>-demo2.sh 10 20</span><br><span class="line">第一个参数为：10</span><br><span class="line">第二个参数为：20</span><br><span class="line">函数第一个入参：10</span><br><span class="line">函数第二个入参：20</span><br></pre></td></tr></table></figure><p>执行 <code>./variable-demo4.sh hello world</code> ，然后在脚本中通过 <code>$1</code>、<code>$2</code> … 读取第 1 个参数、第 2 个参数。。。</p><h3 id="8-2-函数处理参数"><a href="#8-2-函数处理参数" class="headerlink" title="8.2. 函数处理参数"></a>8.2. 函数处理参数</h3><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>返回参数个数</td></tr><tr><td><code>$*</code></td><td>返回所有参数</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程 ID 号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的 ID 号</td></tr><tr><td><code>$@</code></td><td>返回所有参数</td></tr><tr><td><code>$-</code></td><td>返回 Shell 使用的当前选项，与 set 命令功能相同。</td></tr><tr><td><code>$?</code></td><td>函数返回值</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo3.sh" target="_blank" rel="noopener">function-demo3.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">runner</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name=zp</span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第一个入参：<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第二个入参：<span class="variable">$2</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"传递到脚本的参数个数：<span class="variable">$#</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数："</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"$*"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"脚本运行的当前进程 ID 号：$$"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"后台运行的最后一个进程的 ID 号：$!"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数："</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Shell 使用的当前选项：$-"</span></span><br><span class="line">  runner</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"runner 函数的返回值：$?"</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction 1 <span class="string">"abc"</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  函数第一个入参：1</span></span><br><span class="line"><span class="comment">#  函数第二个入参：abc</span></span><br><span class="line"><span class="comment">#  传递到脚本的参数个数：3</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1 abc hello, "zp"</span></span><br><span class="line"><span class="comment">#  脚本运行的当前进程 ID 号：26400</span></span><br><span class="line"><span class="comment">#  后台运行的最后一个进程的 ID 号：</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1</span></span><br><span class="line"><span class="comment">#  + abc</span></span><br><span class="line"><span class="comment">#  + hello, "zp"</span></span><br><span class="line"><span class="comment">#  Shell 使用的当前选项：hB</span></span><br><span class="line"><span class="comment">#  runner 函数的返回值：0</span></span><br></pre></td></tr></table></figure><h2 id="9-Shell-扩展"><a href="#9-Shell-扩展" class="headerlink" title="9. Shell 扩展"></a>9. Shell 扩展</h2><p><em>扩展</em> 发生在一行命令被分成一个个的 <em>记号（tokens）</em> 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。</p><p>感兴趣的话可以阅读<a href="https://www.gnu.org/software/bash/manual/bash.html###Shell-Expansions" target="_blank" rel="noopener">关于 shell 扩展的更多细节</a>。</p><h4 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h4><p>大括号扩展让生成任意的字符串成为可能。它跟 <em>文件名扩展</em> 很类似，举个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> beg&#123;i,a,u&#125;n <span class="comment">### begin began begun</span></span><br></pre></td></tr></table></figure><p>大括号扩展还可以用来创建一个可被循环迭代的区间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;0..5&#125; <span class="comment">### 0 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">echo</span> &#123;00..8..2&#125; <span class="comment">### 00 02 04 06 08</span></span><br></pre></td></tr></table></figure><h4 id="命令置换"><a href="#命令置换" class="headerlink" title="命令置换"></a>命令置换</h4><p>命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或<code>$()</code>包围时，命令置换将会执行。举个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">now=`date +%T`</span><br><span class="line"><span class="comment">### or</span></span><br><span class="line">now=$(date +%T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$now</span> <span class="comment">### 19:08:26</span></span><br></pre></td></tr></table></figure><h4 id="算数扩展"><a href="#算数扩展" class="headerlink" title="算数扩展"></a>算数扩展</h4><p>在 bash 中，执行算数运算是非常方便的。算数表达式必须包在<code>$(( ))</code>中。算数扩展的格式为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">result=$(( ((10 + 5*3) - 7) / 2 ))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span> <span class="comment">### 9</span></span><br></pre></td></tr></table></figure><p>在算数表达式中，使用变量无需带上<code>$</code>前缀：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=4</span><br><span class="line">y=7</span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 11</span></span><br><span class="line"><span class="built_in">echo</span> $(( ++x + y++ )) <span class="comment">### 12</span></span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 13</span></span><br></pre></td></tr></table></figure><h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Your home: <span class="variable">$HOME</span>"</span> <span class="comment">### Your home: /Users/&lt;username&gt;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Your home: $HOME'</span> <span class="comment">### Your home: $HOME</span></span><br></pre></td></tr></table></figure><p>当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用<code>echo</code>来输出用户的输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INPUT=<span class="string">"A string  with   strange    whitespace."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$INPUT</span>   <span class="comment">### A string with strange whitespace.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$INPUT</span>"</span> <span class="comment">### A string  with   strange    whitespace.</span></span><br></pre></td></tr></table></figure><p>调用第一个<code>echo</code>时给了它 5 个单独的参数 —— <code>$INPUT</code> 被分成了单独的词，<code>echo</code>在每个词之间打印了一个空格。第二种情况，调用<code>echo</code>时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。</p><p>来看一个更严肃的例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FILE=<span class="string">"Favorite Things.txt"</span></span><br><span class="line">cat <span class="variable">$FILE</span>   <span class="comment">### 尝试输出两个文件: `Favorite` 和 `Things.txt`</span></span><br><span class="line">cat <span class="string">"<span class="variable">$FILE</span>"</span> <span class="comment">### 输出一个文件: `Favorite Things.txt`</span></span><br></pre></td></tr></table></figure><p>尽管这个问题可以通过把 FILE 重命名成<code>Favorite-Things.txt</code>来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（<code>find</code>, <code>cat</code>, 等等）呢。因此，如果输入 <em>可能</em> 包含空格，务必要用引号把表达式包起来。</p><h2 id="10-流和重定向"><a href="#10-流和重定向" class="headerlink" title="10. 流和重定向"></a>10. 流和重定向</h2><p>Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。</p><p>管道给了我们创建传送带的机会，控制程序的执行成为可能。</p><p>学习如何使用这些强大的、高级的工具是非常非常重要的。</p><h3 id="10-1-输入、输出流"><a href="#10-1-输入、输出流" class="headerlink" title="10.1. 输入、输出流"></a>10.1. 输入、输出流</h3><p>Bash 接收输入，并以字符序列或 <strong>字符流</strong> 的形式产生输出。这些流能被重定向到文件或另一个流中。</p><p>有三个文件描述符：</p><table><thead><tr><th>代码</th><th>描述符</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>stdin</code></td><td>标准输入</td></tr><tr><td><code>1</code></td><td><code>stdout</code></td><td>标准输出</td></tr><tr><td><code>2</code></td><td><code>stderr</code></td><td>标准错误输出</td></tr></tbody></table><h3 id="10-2-重定向"><a href="#10-2-重定向" class="headerlink" title="10.2. 重定向"></a>10.2. 重定向</h3><p>重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>重定向输出</td></tr><tr><td><code>&amp;&gt;</code></td><td>重定向输出和错误输出</td></tr><tr><td><code>&amp;&gt;&gt;</code></td><td>以附加的形式重定向输出和错误输出</td></tr><tr><td><code>&lt;</code></td><td>重定向输入</td></tr><tr><td><code>&lt;&lt;</code></td><td><a href="http://tldp.org/LDP/abs/html/here-docs.html" target="_blank" rel="noopener">Here 文档</a> 语法</td></tr><tr><td><code>&lt;&lt;&lt;</code></td><td><a href="http://www.tldp.org/LDP/abs/html/x17837.html" target="_blank" rel="noopener">Here 字符串</a></td></tr></tbody></table><p>以下是一些使用重定向的例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### ls的结果将会被写到list.txt中</span></span><br><span class="line">ls -l &gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 将输出附加到list.txt中</span></span><br><span class="line">ls -a &gt;&gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 所有的错误信息会被写到errors.txt中</span></span><br><span class="line">grep da * 2&gt; errors.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从errors.txt中读取输入</span></span><br><span class="line">less &lt; errors.txt</span><br></pre></td></tr></table></figure><h3 id="10-3-dev-null-文件"><a href="#10-3-dev-null-文件" class="headerlink" title="10.3. /dev/null 文件"></a>10.3. <code>/dev/null</code> 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null</span><br></pre></td></tr></table></figure><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="11-Debug"><a href="#11-Debug" class="headerlink" title="11. Debug"></a>11. Debug</h2><p>shell 提供了用于 debug 脚本的工具。</p><p>如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash options</span><br></pre></td></tr></table></figure><p>options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：</p><table><thead><tr><th>Short</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>-f</code></td><td>noglob</td><td>禁止文件名展开（globbing）</td></tr><tr><td><code>-i</code></td><td>interactive</td><td>让脚本以 <em>交互</em> 模式运行</td></tr><tr><td><code>-n</code></td><td>noexec</td><td>读取命令，但不执行（语法检查）</td></tr><tr><td><code>-t</code></td><td>—</td><td>执行完第一条命令后退出</td></tr><tr><td><code>-v</code></td><td>verbose</td><td>在执行每条命令前，向<code>stderr</code>输出该命令</td></tr><tr><td><code>-x</code></td><td>xtrace</td><td>在执行每条命令前，向<code>stderr</code>输出该命令以及该命令的扩展参数</td></tr></tbody></table><p>举个例子，如果我们在脚本中指定了<code>-x</code>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 3; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这会向<code>stdout</code>打印出变量的值和一些其它有用的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">+ (( i = 0 ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 0</span><br><span class="line">0</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 1</span><br><span class="line">1</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 2</span><br><span class="line">2</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br></pre></td></tr></table></figure><p>有时我们值需要 debug 脚本的一部分。这种情况下，使用<code>set</code>命令会很方便。这个命令可以启用或禁用选项。使用<code>-</code>启用选项，<code>+</code>禁用选项：</p><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/debug-demo.sh" target="_blank" rel="noopener">debug-demo.sh</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启 debug</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 3; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 关闭 debug</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  + (( i = 0 ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 0</span></span><br><span class="line"><span class="comment">#  0+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 1</span></span><br><span class="line"><span class="comment">#  1+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 2</span></span><br><span class="line"><span class="comment">#  2+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + set +x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span>; <span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\n"</span></span><br><span class="line"><span class="comment">#  Output: 12345</span></span><br></pre></td></tr></table></figure><h2 id="12-更多内容"><a href="#12-更多内容" class="headerlink" title="12. 更多内容"></a>12. 更多内容</h2><blockquote><p>📓 本文已归档到：<a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">notes</a></p></blockquote><ul><li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="noopener">awesome-shell</a>，shell 资源列表</li><li><a href="https://github.com/awesome-lists/awesome-bash" target="_blank" rel="noopener">awesome-bash</a>，bash 资源列表</li><li><a href="https://github.com/denysdovhan/bash-handbook" target="_blank" rel="noopener">bash-handbook</a></li><li><a href="https://github.com/vuuihc/bash-guide" target="_blank" rel="noopener">bash-guide</a> ，bash 基本用法指南</li><li><a href="https://github.com/Bash-it/bash-it" target="_blank" rel="noopener">bash-it</a>，为你日常使用，开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架</li><li><a href="http://dotfiles.github.io/" target="_blank" rel="noopener">dotfiles.github.io</a>，上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接</li><li><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Runoob Shell 教程</a></li><li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">shellcheck</a> 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li></ul><p>最后，Stack Overflow 上 <a href="https://stackoverflow.com/questions/tagged/bash" target="_blank" rel="noopener">bash 标签下</a>有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。</p><p><strong>作者原文链接: <a href="https://www.cnblogs.com/jingmoxukong/p/7867397.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingmoxukong/p/7867397.html</a></strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器和HyperLogLog</title>
    <url>/2020/07/01/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8CHyperLogLog/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="python-布隆过滤器"><a href="#python-布隆过滤器" class="headerlink" title="python-布隆过滤器"></a>python-布隆过滤器</h1><p>在学习<code>redis</code>过程中提到一个缓存穿透的问题， 书中参考的解决方案之一是使用布隆过滤器， 那么就有必要来了解一下什么是布隆过滤器。在参考了许多博客之后， 写个总结记录一下。</p><h2 id="一、布隆过滤器简介"><a href="#一、布隆过滤器简介" class="headerlink" title="一、布隆过滤器简介"></a>一、布隆过滤器简介</h2><h3 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h3><p>本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>布隆过滤器内部维护一个<code>bitArray</code>(位数组)， 开始所有数据全部置 0 。当一个元素过来时，能过多个哈希函数（hash1,hash2,hash3….）计算不同的在哈希值，并通过哈希值找到对应的<code>bitArray</code>下标处，将里面的值 0 置为 1 。 需要说明的是，布隆过滤器有一个误判率的概念，误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间越小。</p><p>下面以网址为例来进行说明, 例如布隆过滤器的初始情况如下图所示：<br><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205013684-856617678.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205013684-856617678.jpg" alt="img"></a></p><p>现在我们需要往布隆过滤里中插入<code>baidu</code>这个url，经过3个哈希函数的计算，hash值分别为1，4，7，那么我们就需要对布隆过滤器的对应的bit位置1， 就如图下所示：</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205051490-438287903.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205051490-438287903.jpg" alt="img"></a></p><p>接下来，需要继续往布隆过滤器中添加<code>tencent</code>这个url，然后它计算出来的hash值分别3，4，8，继续往对应的bit位置1。这里就需要注意一个点， 上面两个url最后计算出来的hash值都有4，这个现象也是布隆不能确认某个元素一定存在的原因，最后如下图所示：</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205113779-698386268.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205113779-698386268.jpg" alt="img"></a></p><p>布隆过滤器的查询也很简单，例如我们需要查找<code>python</code>，只需要计算出它的hash值， 如果该值为2，4，7，那么因为对应bit位上的数据有一个不为1， 那么一定可以断言<code>python</code>不存在，但是如果它计算的hash值是1，3，7，那么就只能判断出<code>python</code>可能存在，这个例子就可以看出来， 我们没有存入<code>python</code>，但是由于其他key存储的时候返回的hash值正好将<code>python</code>计算出来的hash值对应的bit位占用了，这样就不能准确地判断出<code>python</code>是否存在。</p><p>因此， 随着添加的值越来越多， 被占的bit位越来越多， 这时候误判的可能性就开始变高，如果布隆过滤器所有bit位都被置为1的话，那么所有key都有可能存在， 这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。</p><p>从上面布隆过滤器的实现原理可以看出，它不支持删除， 一旦将某个key对应的bit位置0，可能会导致同样bit位的其他key的存在性判断错误。</p><h3 id="布隆过滤器的准确性"><a href="#布隆过滤器的准确性" class="headerlink" title="布隆过滤器的准确性"></a>布隆过滤器的准确性</h3><p>布隆过滤器的核心思想有两点：</p><ol><li>多个hash，增大随机性，减少hash碰撞的概率</li><li>扩大数组范围，使hash值均匀分布，进一步减少hash碰撞的概率。</li></ol><p>虽然布隆过滤器已经尽可能的减小hash碰撞的概率了，但是，并不能彻底消除，因此正如上面的小例子所举的小例子的结果来看， 布隆过滤器只能告诉我们<strong>某样东西一定不存在以及它可能存在</strong>。</p><p>关于布隆过滤器的数组大小以及相应的hash函数个数的选择， 可以参考网上的其他博客或者是这个维基百科上对应词条上的结果: <a href="http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives" target="_blank" rel="noopener">Probability of false positives</a> .</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205508471-460587233.png" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205508471-460587233.png" alt="1024px-Bloom_filter_fp_probability.svg"></a></p><p>上图的纵坐标p是误判率，横坐标n表示插入的元素个数，m表示布隆过滤器的bit长度，当然上图结果成立都假设hash函数的个数k满足条件<code>k = (m/n)ln2</code>(忽略k是整数)。</p><p>从上面的结果来看， 选择合适后误判率还是比较低的。</p><h3 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h3><ol><li>网页爬虫对URL的去重，避免爬取相同的URL地址</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li><li>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</li><li>黑名单过滤，</li></ol><h2 id="二、python中使用布隆过滤器"><a href="#二、python中使用布隆过滤器" class="headerlink" title="二、python中使用布隆过滤器"></a>二、python中使用布隆过滤器</h2><ol><li><p>先去这个网站下载<code>bitarray</code>这个依赖 <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/#bitarray</code></p><p>直接安装会报错<code>error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Build Tools for Visual Studio&quot;: https://visualstudio.microsoft.com/downloads/</code></p></li><li><p>安装<code>wheel</code>文件, 防止我们主动安装报这样的错误<code>pip3 install bitarray-1.1.0-cp36-cp36m-win_amd64.whl</code></p></li></ol><p>注: 如果不知道怎么确定版本可以查看这个链接 <a href="https://blog.csdn.net/happywlg123/article/details/107281936" target="_blank" rel="noopener">https://blog.csdn.net/happywlg123/article/details/107281936</a></p><ol start="3"><li><code>pip3 install pybloom_live</code></li></ol><p>使用案例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copyfrom pybloom_live <span class="keyword">import</span> ScalableBloomFilter, BloomFilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可自动扩容的布隆过滤器</span></span><br><span class="line">bloom = ScalableBloomFilter(initial_capacity=<span class="number">100</span>, error_rate=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">url1 = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">url2 = <span class="string">'http://qq.com'</span></span><br><span class="line"></span><br><span class="line">bloom.add(url1)</span><br><span class="line">print(url1 <span class="keyword">in</span> bloom)</span><br><span class="line">print(url2 <span class="keyword">in</span> bloom)</span><br><span class="line">Copy<span class="comment"># BloomFilter 是定长的</span></span><br><span class="line"><span class="keyword">from</span> pybloom_live <span class="keyword">import</span> BloomFilter</span><br><span class="line"></span><br><span class="line">url1 = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">url2 = <span class="string">'http://qq.com'</span></span><br><span class="line"></span><br><span class="line">bf = BloomFilter(capacity=<span class="number">1000</span>)</span><br><span class="line">bf.add(url1)</span><br><span class="line">print(url1 <span class="keyword">in</span> bf)</span><br><span class="line">print(url2 <span class="keyword">in</span> bf)</span><br></pre></td></tr></table></figure><h2 id="三、redis中使用布隆过滤器"><a href="#三、redis中使用布隆过滤器" class="headerlink" title="三、redis中使用布隆过滤器"></a>三、redis中使用布隆过滤器</h2><p>详细的文档可以参考<a href="https://oss.redislabs.com/redisbloom/Quick_Start/" target="_blank" rel="noopener">官方文档</a>。</p><p>这个模块不仅仅实现了布隆过滤器，还实现了 <code>CuckooFilter</code>（布谷鸟过滤器），以及 <code>TopK</code>功能。<code>CuckooFilter</code>是在 <code>BloomFilter</code>的基础上主要解决了<code>BloomFilter</code>不能删除的缺点。 下面只说明了布隆过滤器</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>传统的<code>redis</code>服务器安装 <code>RedisBloom</code> 插件，详情可以参考<a href="https://blog.csdn.net/u013030276/article/details/88350641" target="_blank" rel="noopener">centos中安装redis插件bloom-filter</a></p><p>我这里使用docker进行安装，简单快捷。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copydocker pull redislabs/rebloom:latest</span><br><span class="line">docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span><br><span class="line">docker <span class="built_in">exec</span> -it redis-redisbloom /bin/bash</span><br></pre></td></tr></table></figure><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>命令使用非常简单。</p><h4 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h4><blockquote><p>bf.reserve {key} {error_rate} {size}</p></blockquote><p>创建一个空的名为<code>key</code>的布隆过滤器，并设置一个期望的错误率和初始大小。<code>{error_rate}</code>过滤器的错误率在0-1之间，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copy127.0.0.1:6379&gt; bf.reserve black_male 0.001 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="add-madd"><a href="#add-madd" class="headerlink" title="add, madd"></a>add, madd</h4><blockquote><p>bf.add {key} {item}</p><p>bf.madd {key} {item} [item…]</p></blockquote><p>往过滤器中添加元素。如果key不存在，过滤器会自动创建。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copy127.0.0.1:6379&gt; bf.add <span class="built_in">test</span> 123</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.madd urls baidu google tencent</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面已经存在的值再次添加会返回0， 不存在则返回1</span></span><br></pre></td></tr></table></figure><h4 id="exists-mexists"><a href="#exists-mexists" class="headerlink" title="exists, mexists"></a>exists, mexists</h4><blockquote><p>bf.exists {key} {item}</p><p>bf.mexists {key} {item} [item…]</p></blockquote><p>判断过滤器中是否存在该元素，不存在返回0，存在返回1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copy127.0.0.1:6379&gt; bf.exists <span class="built_in">test</span> 123</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.mexists urls baidu google hello</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h2 id="四、python程序中使用redisbloom"><a href="#四、python程序中使用redisbloom" class="headerlink" title="四、python程序中使用redisbloom"></a>四、python程序中使用redisbloom</h2><p>使用<code>redisbloom</code>这个模块来操作<code>redis</code>的布隆过滤器插件</p><blockquote><p>pip3 install redisbloom</p></blockquote><p>使用方法，参考官方给出的例子即可。<a href="https://github.com/RedisBloom/redisbloom-py" target="_blank" rel="noopener">https://github.com/RedisBloom/redisbloom-py</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copy<span class="comment"># 自己的简单使用</span></span><br><span class="line"><span class="keyword">from</span> redisbloom.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为我使用的是虚拟机中docker的redis, 填写虚拟机的ip地址和暴露的端口</span></span><br><span class="line">rb = Client(host=<span class="string">'192.168.12.78'</span>, port=<span class="number">6379</span>)</span><br><span class="line">rb.bfAdd(<span class="string">'urls'</span>, <span class="string">'baidu'</span>)</span><br><span class="line">rb.bfAdd(<span class="string">'urls'</span>, <span class="string">'google'</span>)</span><br><span class="line">print(rb.bfExists(<span class="string">'urls'</span>, <span class="string">'baidu'</span>))  <span class="comment"># out: 1</span></span><br><span class="line">print(rb.bfExists(<span class="string">'urls'</span>, <span class="string">'tencent'</span>))  <span class="comment"># out: 0</span></span><br><span class="line"></span><br><span class="line">rb.bfMAdd(<span class="string">'urls'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">print(rb.bfMExists(<span class="string">'urls'</span>, <span class="string">'google'</span>, <span class="string">'baidu'</span>, <span class="string">'tencent'</span>))  <span class="comment"># out: [1, 1, 0]</span></span><br></pre></td></tr></table></figure><p><strong>误判率的测试demo</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copy<span class="string">"""</span></span><br><span class="line"><span class="string">基于redis布隆过滤器的误判率的测试</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> redisbloom.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">rb = Client(host=<span class="string">'192.168.12.78'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(size, key=<span class="string">'book'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""插入数据"""</span></span><br><span class="line">    <span class="comment"># 一条条插入速度太慢了</span></span><br><span class="line">    <span class="comment"># for i in range(size):</span></span><br><span class="line">    <span class="comment">#     rb.bfAdd(key, f'book&#123;i&#125;')</span></span><br><span class="line">    s = time.time()</span><br><span class="line">    step = <span class="number">1000</span>  <span class="comment"># 每次插入1000条数据</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">0</span>, size, step):</span><br><span class="line">        stop = start + step</span><br><span class="line">        <span class="keyword">if</span> stop &gt;= size:</span><br><span class="line">            stop = size</span><br><span class="line">        rb.bfMAdd(key, *range(start, stop))</span><br><span class="line">    print(<span class="string">'插入结束... 花费时间: &#123;:.4f&#125;s'</span>.format(time.time() - s))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(size, key=<span class="string">'book'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""查询数据"""</span></span><br><span class="line">    <span class="comment"># 统计误判个数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    s = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单条查询速度太慢了。。。</span></span><br><span class="line">    <span class="comment"># for i in range(size, size * 2):</span></span><br><span class="line">    <span class="comment">#     count += rb.bfExists(key, i)</span></span><br><span class="line"></span><br><span class="line">    step = <span class="number">1000</span>  <span class="comment"># 每次查1000条数据</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(size, size * <span class="number">2</span>, step):</span><br><span class="line">        stop = start + step</span><br><span class="line">        <span class="keyword">if</span> stop &gt;= size * <span class="number">2</span>:</span><br><span class="line">            stop = size * <span class="number">2</span></span><br><span class="line">        count += rb.bfMExists(key, *range(start, stop)).count(<span class="number">1</span>)  <span class="comment"># 返回值[1, 0, 1, ...]统计1的个数</span></span><br><span class="line">    print(<span class="string">'size: &#123;&#125;, 误判元素个数: &#123;&#125;, 误判率&#123;:.4%&#125;'</span>.format(size, count, count / size))</span><br><span class="line">    print(<span class="string">'查询结束... 花费时间: &#123;:.4f&#125;s'</span>.format(time.time() - s))</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test1</span><span class="params">(size, key=<span class="string">'book'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""测试size个不存在的"""</span></span><br><span class="line">    rb.delete(key)  <span class="comment"># 先清空原来的key</span></span><br><span class="line">    insert(size, key)</span><br><span class="line">    select(size, key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test2</span><span class="params">(size, error=<span class="number">0.001</span>, key=<span class="string">'book'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""指定误差率和初始大小的布隆过滤器"""</span></span><br><span class="line">    rb.delete(key)</span><br><span class="line"></span><br><span class="line">    rb.bfCreate(key, error, size)  <span class="comment"># 误差率为0.1%， 初始个数为size</span></span><br><span class="line"></span><br><span class="line">    insert(size, key)</span><br><span class="line">    select(size, key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># The default error rate is 0.01 and the default initial capacity is 100.</span></span><br><span class="line">    <span class="comment"># 这个是默认的配置， 初始大小为100， 误差率默认为0.01</span></span><br><span class="line">    _test1(<span class="number">1000</span>)</span><br><span class="line">    _test1(<span class="number">10000</span>)</span><br><span class="line">    _test1(<span class="number">100000</span>)</span><br><span class="line">    _test2(<span class="number">500000</span>)</span><br><span class="line">Copy<span class="comment"># 输出的结果</span></span><br><span class="line"></span><br><span class="line">插入结束... 花费时间: <span class="number">0.0409</span>s</span><br><span class="line">size: <span class="number">1000</span>, 误判元素个数: <span class="number">14</span>, 误判率<span class="number">1.4000</span>%</span><br><span class="line">查询结束... 花费时间: <span class="number">0.0060</span>s</span><br><span class="line">******************************</span><br><span class="line">插入结束... 花费时间: <span class="number">0.1389</span>s</span><br><span class="line">size: <span class="number">10000</span>, 误判元素个数: <span class="number">110</span>, 误判率<span class="number">1.1000</span>%</span><br><span class="line">查询结束... 花费时间: <span class="number">0.0628</span>s</span><br><span class="line">******************************</span><br><span class="line">插入结束... 花费时间: <span class="number">0.5372</span>s</span><br><span class="line">size: <span class="number">100000</span>, 误判元素个数: <span class="number">1419</span>, 误判率<span class="number">1.4190</span>%</span><br><span class="line">查询结束... 花费时间: <span class="number">0.4318</span>s</span><br><span class="line">******************************</span><br><span class="line">插入结束... 花费时间: <span class="number">1.9484</span>s</span><br><span class="line">size: <span class="number">500000</span>, 误判元素个数: <span class="number">152</span>, 误判率<span class="number">0.0304</span>%</span><br><span class="line">查询结束... 花费时间: <span class="number">2.2177</span>s</span><br><span class="line">******************************</span><br></pre></td></tr></table></figure><p>如果想要布隆过滤器知道具体的耗费内存大小以及对应的错误率的信息， 可以使用查看这个<a href="https://krisives.github.io/bloom-calculator/" target="_blank" rel="noopener">布隆过滤器计算器</a>计算出最后的结果。就如下面所示， 1kw数据， 误差为0.01%， 只需要23M内存。</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205337366-2116880413.png" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205337366-2116880413.png" alt="img"></a></p><h2 id="五、缓存穿透"><a href="#五、缓存穿透" class="headerlink" title="五、缓存穿透"></a>五、缓存穿透</h2><p>现在又回到开头的问题， 解决缓存穿透的问题。</p><p><strong>什么是缓存穿透</strong></p><p>我们通常使用<code>redis</code>作为数据缓存，当请求进来时先通过<code>key</code>去<code>redis</code>缓存查询，如果缓存中数据不存在，需要去查询数据库的数据。当数据库和缓存中都不存在的数据来查询时候，请求都打在数据库的请求中。如果这种请求量很大，会给数据库造成更大的压力进而影响系统的性能。</p><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205359267-68051944.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205359267-68051944.jpg" alt="img"></a></p><p><strong>解决这类问题的方法</strong></p><blockquote><p>方法一:当DB和redis中都不存在<code>key</code>，在DB返回<code>null</code>时，在redis中插入``当<code>key</code>再次请求时,redis直接返回<code>null</code>，而不用再次请求DB。</p></blockquote><blockquote><p>方法二:使用redis提供的<code>redisbloom</code>，同样是将存在的key放入到过滤器中。当请求进来时，先去过滤器中校验是否存在，如果不存在直接返回<code>null</code>。</p></blockquote><p><a href="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205415414-1027574260.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1534894/201912/1534894-20191207205415414-1027574260.jpg" alt="img"></a><br><strong>黑名单的小例子</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Copyimport redis</span><br><span class="line"><span class="keyword">from</span> redisbloom.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个连接池来进行使用</span></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'192.168.12.78'</span>, port=<span class="number">6379</span>, max_connections=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_key</span><span class="params">(key, error, capacity)</span>:</span></span><br><span class="line">    rb = Client(connection_pool=pool)</span><br><span class="line">    rb.bfCreate(key, errorRate=error, capacity=capacity)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_item</span><span class="params">(key, item)</span>:</span></span><br><span class="line">    <span class="string">"""判断是否存在"""</span></span><br><span class="line">    rb = Client(connection_pool=pool)</span><br><span class="line">    <span class="keyword">return</span> rb.bfExists(key, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(key, item)</span>:</span></span><br><span class="line">    <span class="string">"""添加值"""</span></span><br><span class="line">    rb = Client(connection_pool=pool)</span><br><span class="line">    <span class="keyword">return</span> rb.bfAdd(key, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 添加黑名单, 误差为0.001， 大小为1000</span></span><br><span class="line">    create_key(<span class="string">'blacklist'</span>, <span class="number">0.001</span>, <span class="number">1000</span>)</span><br><span class="line">    add_item(<span class="string">'blacklist'</span>, <span class="string">'user:1'</span>)</span><br><span class="line">    add_item(<span class="string">'blacklist'</span>, <span class="string">'user:2'</span>)</span><br><span class="line">    add_item(<span class="string">'blacklist'</span>, <span class="string">'user:3'</span>)</span><br><span class="line">    add_item(<span class="string">'blacklist'</span>, <span class="string">'user:4'</span>)</span><br><span class="line">    print(<span class="string">'user:1是否在黑名单-&gt; '</span>, get_item(<span class="string">'blacklist'</span>, <span class="string">'user:1'</span>))</span><br><span class="line">    print(<span class="string">'user:2是否在黑名单-&gt; '</span>, get_item(<span class="string">'blacklist'</span>, <span class="string">'user:2'</span>))</span><br><span class="line">    print(<span class="string">'user:6是否在黑名单-&gt; '</span>, get_item(<span class="string">'blacklist'</span>, <span class="string">'user:6'</span>))</span><br></pre></td></tr></table></figure><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>​ HyperLogLog是一种类似于布隆过滤器的算法。如果Google要计算用户执行的不同搜索的数量，或者Amazon要计算当天用户浏览的不同商品的数量，要回答这些问题，需要耗用大量的空间！对Google来说，必须有一个日志，其中包含用户执行的不同搜索。有用户执行搜索时，Google必须判断该搜索是否包含在日志中：如果答案是否定的，就必须将其加入到日志中。即便只记录一天的搜索，这种日志也大得不得了！<br>​ HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。<br>​ 面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>布隆过滤器</category>
        <category>python</category>
        <category>HyperLogLog</category>
        <category>搜索算法</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
        <tag>搜索算法</tag>
        <tag>HyperLogLog</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用教程</title>
    <url>/2020/06/18/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="Git使用教程"><a href="#Git使用教程" class="headerlink" title="Git使用教程"></a>Git使用教程</h1><p>转载自: <a href="https://www.cnblogs.com/tugenhua0707/p/4050072.html" target="_blank" rel="noopener">git使用教程</a></p><h2 id="一：Git是什么？"><a href="#一：Git是什么？" class="headerlink" title="一：Git是什么？"></a><strong>一：Git是什么？</strong></h2><p>​ Git是目前世界上最先进的分布式版本控制系统。</p><p>​ 工作原理 / 流程：</p><p><img src="https://img.vim-cn.com/55/8c5b3217f5613b3d6fbb7b27aaf2e68427fde9.png" alt="git-1"></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="二：SVN与Git的最主要的区别？"><a href="#二：SVN与Git的最主要的区别？" class="headerlink" title="二：SVN与Git的最主要的区别？"></a><strong>二：SVN与Git的最主要的区别？</strong></h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h2 id="三：在windows上如何安装Git？"><a href="#三：在windows上如何安装Git？" class="headerlink" title="三：在windows上如何安装Git？"></a><strong>三：在windows上如何安装Git？</strong></h2><p>msysgit是 windows版的Git,如下：</p><p><img src="https://img.vim-cn.com/4f/7898dd99592a556b30f854e1d0d9e6227f50f1.jpg" alt="git-2"></p><p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下：</p><p><img src="https://img.vim-cn.com/19/37fe2646eedd98ef8b90da05f999e167caf4fc.jpg" alt="git-3"></p><p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：</p><p><img src="https://img.vim-cn.com/7b/4617c7c85dd552e3059b23b1bb132ebe4faf1b.jpg" alt="git-4"></p><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><p><img src="https://img.vim-cn.com/6a/882bdd3fcab7d2deaed09ff6bb94b546327627.jpg" alt="git-5"></p><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p><strong>注意：</strong>git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><h2 id="四：如何操作？"><a href="#四：如何操作？" class="headerlink" title="四：如何操作？"></a><strong>四：如何操作？</strong></h2><h3 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1. 创建版本库"></a>1. 创建版本库</h3><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><p>​ <img src="https://img.vim-cn.com/d3/b456182de26a6934cf8e3a0950f67ca630c23a.png" alt="git-6"></p><p>pwd 命令是用于显示当前的目录。</p><ol><li><p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><p>​ <img src="https://img.vim-cn.com/a1/7a4855e0bb8174d4a0aa404da893d1f9e78761.png" alt="git-7"></p><p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><p><img src="https://img.vim-cn.com/4f/a82ff42262a9c70a001ff92f01c8daef0e6081.png" alt="git-8"></p></li><li><p>把文件添加到版本库中。</p></li></ol><p>​ 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p><strong>下面先看下**</strong>demo<strong>**如下演示：</strong></p><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p>第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p><p>​ <img src="https://img.vim-cn.com/20/87cbae36cf3866ecc3259fd724ffc02f469d14.png" alt="git-9"></p><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p><p>第二步：用命令 git commit告诉Git，把文件提交到仓库。</p><p>​ <img src="https://img.vim-cn.com/23/fccc06cddc7e1e92caa1f14ac436de8e6c0195.png" alt="git-10"></p><p>现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p><p>​ <img src="https://img.vim-cn.com/d9/bab4ed448c85a0ebb239d00abeaa3d21d1a4b1.png" alt="git-11"></p><p>说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p><p>​ <img src="https://img.vim-cn.com/68/1a092ee19e672fa8f8e0003498d431b8e75470.png" alt="git-12"></p><p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：</p><p>git diff readme.txt 如下：</p><p>​ <img src="https://img.vim-cn.com/bb/ae4dbe881e3a072b77cc551459d4b3afe7b3f7.png" alt="git-13"></p><p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。</p><p>如下：</p><p><img src="https://img.vim-cn.com/7f/f6e7ad64f559c01c2e524130b0a8f80d88a66c.png" alt="git-14"></p><h3 id="2-版本回退："><a href="#2-版本回退：" class="headerlink" title="2. 版本回退："></a>2. 版本回退：</h3><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行</p><p>内容为33333333333333.继续执行命令如下：</p><p>​ <img src="https://img.vim-cn.com/bb/6fc932e36136c2b4708872b06958baf4f0583c.png" alt="git-15"></p><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p><p>​ <img src="https://img.vim-cn.com/5e/e4b4dddaf465d42a3247d322ba44ff1ad14de8.png" alt="git-16"></p><p>git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p><p>​ <img src="https://img.vim-cn.com/e8/47ceb37bb9125f969bb207a82e29ffb55c0e10.png" alt="git-17"></p><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p><p>​ <img src="https://img.vim-cn.com/5d/e6cf37d88899c789fd354c74896f6b0b16ed2d.png" alt="git-18"></p><p>如果想回退到上一个版本的命令如下操作：</p><p><img src="https://img.vim-cn.com/a8/9be2854e4470497ac60f096ecd60ff41488462.png" alt="git-19"></p><p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p><p><img src="https://img.vim-cn.com/75/5ead06cf8071a9b586f77d5a3877cd77487702.png" alt="git-20"></p><p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p><p><img src="https://img.vim-cn.com/31/438003880618107dbac6c103cbd1bd00997c5b.png" alt="git-21"></p><p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p><p>git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p><p><img src="https://img.vim-cn.com/f3/ea50f5869683cb9a7206401bac73d8e5ae6476.png" alt="git-22"></p><p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令</p><p>git reset –hard 6fcfc89来恢复了。演示如下：</p><p><img src="https://img.vim-cn.com/f1/17ebd76bf8065c2469c29a294d7838a38ea104.png" alt="git-23"></p><p>可以看到 目前已经是最新的版本了。</p><h3 id="3-理解工作区与暂存区的区别？"><a href="#3-理解工作区与暂存区的区别？" class="headerlink" title="3. 理解工作区与暂存区的区别？"></a>3. 理解工作区与暂存区的区别？</h3><p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</p><p><strong>版本库**</strong>(Repository)<strong>**：</strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p><p>我们前面说过使用Git提交文件到版本库有两步：</p><p>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p><p>第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p><p>我们继续使用demo来演示下：</p><p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p><p><img src="https://img.vim-cn.com/bd/f9df3cbf8162cbf7f79faecf7b3f8c371c67a9.png" alt="git-24"></p><p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p><p><img src="https://img.vim-cn.com/38/b414c940aae8db0cd3c0645c7764c678cd8cbc.png" alt="git-25"></p><p>接着我们可以使用git commit一次性提交到分支上，如下：</p><p><img src="https://img.vim-cn.com/a7/e0c1e6172d1f3f1666722cbce4405dc75f6c93.png" alt="git-26"></p><h3 id="4-Git撤销修改和删除文件操作。"><a href="#4-Git撤销修改和删除文件操作。" class="headerlink" title="4. Git撤销修改和删除文件操作。"></a>4. Git撤销修改和删除文件操作。</h3><h4 id="1-撤销修改："><a href="#1-撤销修改：" class="headerlink" title="1. 撤销修改："></a><strong>1. 撤销修改：</strong></h4><p>比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p><p><img src="https://img.vim-cn.com/57/c5600e1d75a21c66cbcad0e502373aaf8744a7.png" alt="git-27"></p><p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p><p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</p><p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^</p><p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p><p><img src="https://img.vim-cn.com/fc/2f07314d2e577d72daf340f82e734ca434ad54.png" alt="git-28"></p><p>可以发现，Git会告诉你，git checkout – file 可以丢弃工作区的修改，如下命令：</p><p>git checkout – readme.txt,如下所示：</p><p><img src="https://img.vim-cn.com/8f/b19b7f59f38a5e86b5f02c10d25ee13cfc49ca.png" alt="git-29"></p><p>命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p><ol><li>readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li><li>另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ol><p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><p>​ <img src="https://img.vim-cn.com/01/c8f55ed637c5d4134fd2a8c7f964ba03806b79.png" alt="git-30"></p><p><strong>注意：</strong>命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</p><h4 id="2-删除文件。"><a href="#2-删除文件。" class="headerlink" title="2. 删除文件。"></a><strong>2. 删除文件。</strong></h4><p>假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p><p>​ <img src="https://img.vim-cn.com/9c/309fce9f96a1923394b0789d3b32ff24007dfa.png" alt="git-31"></p><p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p><p>​ <img src="https://img.vim-cn.com/78/a4f0ce205fb1d206f78d6f93e40b5167d547a6.png" alt="git-32"></p><p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？</p><p>可以使用如下命令 git checkout – b.txt，如下所示：</p><p><img src="https://img.vim-cn.com/f2/06e342452030025b055f7cc0bb4cf3c7f01287.png" alt="git-33"></p><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><p><img src="https://img.vim-cn.com/a8/d864bd4b128f41b80b1186b6038282d3204b4c.png" alt="git-34"></p><h2 id="五：远程仓库。"><a href="#五：远程仓库。" class="headerlink" title="五：远程仓库。"></a>五：远程仓库。</h2><p>在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><p>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><p>ssh-keygen -t rsa –C “<a href="mailto:youremail@example.com">youremail@example.com</a>”, 由于我本地此前运行过一次，所以本地有，如下所示：</p><p><img src="https://img.vim-cn.com/95/648955904337a03588811633dcf1cf08e750aa.png" alt="git-35"></p><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p><p><img src="https://img.vim-cn.com/38/c1b1d1805e13f95503f3878736e0af6aa1863f.png" alt="git-36"></p><p>点击 Add Key，你就应该可以看到已经添加的key。</p><p><img src="https://img.vim-cn.com/7f/1428728699fa8397e71115eb8e8e682c9a7d5f.png" alt="git-37"></p><ol><li>如何添加远程库？</li></ol><p>​ 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p><p>首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><p><img src="https://img.vim-cn.com/87/2c9573020e7e29c604e780055e2f0008e9fb17.png" alt="git-38"></p><p>在Repository name填入<code>testgit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://img.vim-cn.com/1c/35e892f664f41c4ab632f4ceb02dbfdda6088d.png" alt="git-39"></p><p>目前，在GitHub上的这个<code>testgit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>testgit</code>仓库下运行命令：</p><p>git remote add origin <a href="https://github.com/tugenhua0707/testgit.git" target="_blank" rel="noopener">https://github.com/tugenhua0707/testgit.git</a></p><p>所有的如下：</p><p><img src="https://img.vim-cn.com/75/8b7a5c33f9f3234bc99f1a62bae4cc78c7bae6.png" alt="git-40"></p><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p><p><img src="https://img.vim-cn.com/8d/2fbafbafe3149690414b29b9c9c2c6c0eccf2c.png" alt="git-41"></p><p>从现在起，只要本地作了提交，就可以通过如下命令：</p><p>git push origin master</p><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p><p>\2. 如何从远程库克隆？</p><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p><p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p><p>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p><p><img src="https://img.vim-cn.com/f1/28d8f6728f176194c18ae427ce7672ed66204d.png" alt="git-42"></p><p>如下，我们看到：</p><p><img src="https://img.vim-cn.com/0b/0105602339f7a63b99cad7ff8fc7e14a51326b.png" alt="git-43"></p><p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p><p><img src="https://img.vim-cn.com/88/37b60b1940ea4314a82bc4e60cea35a82e49da.png" alt="git-44"></p><p>接着在我本地目录下 生成testgit2目录了，如下所示：</p><p><img src="https://img.vim-cn.com/2c/6af45fdd7c80dd7a78a7d3c4b0628f78451634.png" alt="git-45"></p><h2 id="六：创建与合并分支。"><a href="#六：创建与合并分支。" class="headerlink" title="六：创建与合并分支。"></a>六：创建与合并分支。</h2><p>在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p><p>​ <img src="https://img.vim-cn.com/c4/b1e17b04d4aa70af0742f860dc755b8bc99d7d.png" alt="git-46"></p><p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p><p>git branch dev</p><p>git checkout dev</p><p>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><p><img src="https://img.vim-cn.com/61/74e0fd9828a5530a5c2b80598ef95a56150630.png" alt="git-47"></p><p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p><p><img src="https://img.vim-cn.com/0f/9f901cabdb61019683d516d3de594a9792947a.png" alt="git-48"></p><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p><p><strong>在master分支下创建并转到分支dev ：git checkout -b dev</strong></p><p><strong>在dev分支（此时内容和master一毛一样）做一些修改</strong></p><p><strong>然后远程操作一般是先 git pull origin master使得master与origin远程先同步</strong></p><p><strong>然后git push origin dev将dev分支推到origin分支</strong></p><p><strong>再切换到master分支git checkout master 再合并分支git merge dev</strong></p><p><img src="https://img.vim-cn.com/ff/086018080710de0082910848670b2ed5581007.png" alt="git-49"></p><p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p><p>注意到上面的<em>Fast-forward</em>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>合并完成后，我们可以接着删除dev分支了，操作如下：</p><p><img src="https://img.vim-cn.com/c5/e353896106305a74a6b09cd8092b6fa1abc5fe.png" alt="git-50"></p><p>总结创建与合并分支命令如下：</p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><p>如何解决冲突？</p><p>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p><p><img src="https://img.vim-cn.com/84/7d8d0c1a6194e8e2020e1c67c10180d2d9a854.png" alt="git-51"></p><p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p><p><img src="https://img.vim-cn.com/51/e24702835f75d58af98b0f53c88f10f68b887d.png" alt="git-52"></p><p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p><p><img src="https://img.vim-cn.com/f1/b275dd4dddd145831ddcfa4f963b4be086a314.png" alt="git-53"></p><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p><p><img src="https://img.vim-cn.com/a8/fb7edd6ac4187d5ceb3a81ed911398af435177.png" alt="git-54"></p><p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p><p><img src="https://img.vim-cn.com/e7/a360ed1831a96877f7e79ec49ede5dab668da2.png" alt="git-55"></p><p>3.分支管理策略。</p><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p><ol><li>创建一个dev分支。</li><li>修改readme.txt内容。</li><li>添加到暂存区。</li><li>切换回主分支(master)。</li><li>合并dev分支，使用命令 git merge –no-ff -m “注释” dev</li><li>查看历史记录</li></ol><p>截图如下：</p><p>​ <img src="https://img.vim-cn.com/11/9008d317dc0a0d7889c0e7c03fef4f2359cb71.png" alt="git-56"></p><p><strong>分支策略：</strong>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h2 id="七：bug分支："><a href="#七：bug分支：" class="headerlink" title="七：bug分支："></a>七：bug分支：</h2><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p><p>​ <img src="https://img.vim-cn.com/86/e01e194fb3803e210486b1c486f263f84c4505.png" alt="git-57"></p><p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p><p><img src="https://img.vim-cn.com/bb/e8cbd78754734d5c86d6b34e808a2f64292f49.png" alt="git-58"></p><p>所以现在我可以通过创建issue-404分支来修复bug了。</p><p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p><p>​ <img src="https://img.vim-cn.com/ab/bbb6c49735bf98bcd72832b567e2dd3482bced.png" alt="git-59"></p><p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p><p><img src="https://img.vim-cn.com/25/0b85dc031690b5b0eac907650c735fc7b0bffc.png" alt="git-60"></p><p>现在，我们回到dev分支上干活了。</p><p><img src="https://img.vim-cn.com/01/8fa0c38b1d0b7accf71aa6fd6d6cda219138ac.png" alt="git-61"></p><p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p><p><img src="https://img.vim-cn.com/11/fc850a37a2b693a11ebd27564e1cf25bd7c0ac.png" alt="git-62"></p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p><ol><li>git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</li><li>另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</li></ol><p>​ 演示如下</p><p><img src="https://img.vim-cn.com/bb/87d905b61da33219d648b687d5586b1f1f3e05.png" alt="git-63"></p><h2 id="八：多人协作"><a href="#八：多人协作" class="headerlink" title="八：多人协作"></a>八：多人协作</h2><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p><ol><li>要查看远程库的信息 使用 git remote</li><li>要查看远程库的详细信息 使用 git remote –v</li></ol><p>如下演示：</p><p>​ <img src="https://img.vim-cn.com/7e/7fe36e8a6dfa09923ec2d8bc2b56e37f32a43d.png" alt="git-64"></p><h3 id="一：推送分支："><a href="#一：推送分支：" class="headerlink" title="一：推送分支："></a><strong>一：推送分支：</strong></h3><p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><p>使用命令 git push origin master</p><p>比如我现在的github上的readme.txt代码如下：</p><p><img src="https://img.vim-cn.com/15/61f82d44dde26ddd9dbd58d077a7dd4799734e.png" alt="git-65"></p><p>本地的readme.txt代码如下：</p><p>​ <img src="https://img.vim-cn.com/95/173a2a31be6ebeac67427bd8df32856f7a98ac.png" alt="git-66"></p><p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p><p><img src="https://img.vim-cn.com/29/c50d67ff0778751e70a4cbd2f51813322633c7.png" alt="git-67"></p><p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p><p><img src="https://img.vim-cn.com/74/b988491115c711c22bab5b9366e777091d518e.png" alt="git-68"></p><p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev</p><p>那么一般情况下，那些分支要推送呢？</p><ol><li>master分支是主分支，因此要时刻与远程同步。</li><li>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</li></ol><h3 id="二：抓取分支："><a href="#二：抓取分支：" class="headerlink" title="二：抓取分支："></a><strong>二：抓取分支：</strong></h3><p>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2</p><p>但是我首先要把dev分支也要推送到远程去，如下</p><p><img src="https://img.vim-cn.com/1f/8d9edf66ede77f034e7e5c12b97b1f236eca64.jpg" alt="git-69"></p><p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p><p><img src="https://img.vim-cn.com/01/979d865032561133cc0a4f2966509512844e90.png" alt="git-70"></p><p>现在目录下生成有如下所示：</p><p><img src="https://img.vim-cn.com/20/c45d0f325d551b44450bd8516803044d9b73ed.png" alt="git-71"></p><p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev</p><p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p><p>如下：</p><p><img src="https://img.vim-cn.com/cf/ac7389565ee9d78b5c3bf90c72019ef1e81e4d.png" alt="git-72"></p><p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p><p><img src="https://img.vim-cn.com/3b/fe9e1b65c30dea40d92884a3b07168560569ed.png" alt="git-73"></p><p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p><p><img src="https://img.vim-cn.com/24/882fe4235b1c8cb210be4f9972a739994d680f.png" alt="git-74"></p><p><em>git pull</em>也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p><p><img src="https://img.vim-cn.com/ec/818fce2318330df62c5c9e33d3ae138817b9a1.png" alt="git-75"></p><p>这回<em>git pull</em>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：</p><p>我们可以先来看看readme.txt内容了。</p><p><img src="https://img.vim-cn.com/80/fc74cd7cdd8ba25e95f36a11effbe056fb87c7.png" alt="git-76"></p><p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</p><p><img src="https://img.vim-cn.com/8d/53c7de472c5c3cc8c247e05a39f116c15010de.png" alt="git-77"></p><p>因此：多人协作工作模式一般是这样的：</p><ol><li>首先，可以试图用git push origin branch-name推送自己的修改.</li><li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li><li>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</li></ol><h2 id="九-Git基本常用命令如下："><a href="#九-Git基本常用命令如下：" class="headerlink" title="九. Git基本常用命令如下："></a>九. Git基本常用命令如下：</h2><p>mkdir： XX (创建一个空目录 XX指目录名)</p><p>pwd： 显示当前目录的路径。</p><p>git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</p><p>git add XX 把xx文件添加到暂存区去。</p><p>git commit –m “XX” 提交文件 –m 后面的是注释。</p><p>git status 查看仓库状态</p><p>git diff XX 查看XX文件修改了那些内容</p><p>git log 查看历史记录</p><p>git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本</p><p>​ (如果想回退到100个版本，使用git reset –hard HEAD~100 )</p><p>cat XX 查看XX文件内容</p><p>git reflog 查看历史记录的版本号id</p><p>git checkout – XX 把XX文件在工作区的修改全部撤销。</p><p>git rm XX 删除XX文件</p><p>git remote add origin <a href="https://github.com/tugenhua0707/testgit" target="_blank" rel="noopener">https://github.com/tugenhua0707/testgit</a> 关联一个远程库</p><p>git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库</p><p>git clone <a href="https://github.com/tugenhua0707/testgit" target="_blank" rel="noopener">https://github.com/tugenhua0707/testgit</a> 从远程库中克隆</p><p>git checkout –b dev 创建dev分支 并切换到dev分支上</p><p>git branch 查看当前所有的分支</p><p>git checkout master 切换回master分支</p><p>git merge dev 在当前的分支上合并dev分支</p><p>git branch –d dev 删除dev分支</p><p>git branch name 创建分支</p><p>git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作</p><p>git stash list 查看所有被隐藏的文件列表</p><p>git stash apply 恢复被隐藏的文件，但是内容不删除</p><p>git stash drop 删除文件</p><p>git stash pop 恢复文件的同时 也删除文件</p><p>git remote 查看远程库的信息</p><p>git remote –v 查看远程库的详细信息</p><p>git push origin master Git会把master分支推送到远程库对应的远程分支上</p><h2 id="十-Git分支练习平台-快速通道"><a href="#十-Git分支练习平台-快速通道" class="headerlink" title="十. Git分支练习平台    快速通道"></a>十. Git分支练习平台 <a href="https://learngitbranching.js.org/?demo=&locale=zh_CN" target="_blank" rel="noopener">快速通道</a></h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志</title>
    <url>/2020/03/01/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="1-更新："><a href="#1-更新：" class="headerlink" title="1. 更新："></a>1. 更新：</h1><h2 id="2020-2-29"><a href="#2020-2-29" class="headerlink" title="2020.2.29"></a>2020.2.29</h2><ol><li><em>页面加载性能优化</em></li><li><em>图片懒加载</em></li><li><em>发布新博客</em></li><li><em>优化背景</em></li><li><em>压缩代码</em></li></ol><h2 id="2020-6-09"><a href="#2020-6-09" class="headerlink" title="2020.6.09"></a>2020.6.09</h2><ul><li>更换Butterfly主题</li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>更新日志</tag>
      </tags>
  </entry>
  <entry>
    <title>python迭代器与生成器</title>
    <url>/2020/06/18/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><h2 id="1-Python推导式"><a href="#1-Python推导式" class="headerlink" title="1. Python推导式"></a>1. Python推导式</h2><ul><li><p><strong>列表推导式</strong></p><ul><li><p>基本格式：variable = [Out_exp_res for Out_exp in Input_list if Out_exp == 2]</p><p>• Out_exp_res:　　列表生成元素表达式，可以是有返回值的函数。<br>• for Out_exp in Input_list：　　迭代Input_list将Out_exp传入Out_exp_res表达式中。<br>• if Out_exp == 2：　　根据条件过滤哪些值</p></li></ul><p><strong>打印30以内的数字，所有能被3整除的整数</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> rang(<span class="number">30</span>) <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li><p>推导式嵌套<br>• 找到嵌套列表中名字含有2个’e’的所有名字<br>names = [[‘Tom’, ‘Billy’, ‘Jefferson’, ‘Andrew’, ‘Wesley’, ‘Steven’, ‘Joe’],<br>[‘Alice’, ‘Jill’, ‘Ana’, ‘Wendy’, ‘Jennifer’, ‘Sherry’, ‘Eva’, ‘Elven’]]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[name <span class="keyword">for</span> lst <span class="keyword">in</span> names <span class="keyword">for</span> name <span class="keyword">in</span> lst <span class="keyword">if</span> name.count(<span class="string">'e'</span>)&gt;=<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">for</span> lst <span class="keyword">in</span> names:</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="keyword">if</span> name.count(<span class="string">'e'</span>) &gt;= <span class="number">2</span>:</span><br><span class="line">            print(name)</span><br></pre></td></tr></table></figure></li></ul><p><strong>三元运算与列表推导式</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注: 放在for之前的if必须要有一个else不然会报错</span></span><br><span class="line">print([i//<span class="number">2</span> <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span> ])</span><br><span class="line"><span class="comment"># 等价于以下代码</span></span><br><span class="line">li = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">3</span> ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            li.append(i//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li.append(i)</span><br><span class="line">print(lt)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>字典推导式</strong></p><p>字典推导和列表推导的使用方法是类似的，只不中括号该改成大括号。<br>基本格式：variable = {out_key:out_value for out_key,out_value in input_list if out_exp == 2}</p><p>• out_key:　返回字典结果的key<br>• out_value: 返回字典结果的value<br>• for out_key,out_value in input_list：迭代input_list将out_exp传入out_exp_res表达式中。<br>• if out_exp == 2：根据条件过滤哪些值可以。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除key中包含'a'的数据</span></span><br><span class="line">dic = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>, <span class="string">'ab'</span>:<span class="number">4</span>&#125; </span><br><span class="line">li = &#123; k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items() <span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">not</span> <span class="keyword">in</span> k &#125; <span class="comment"># 可以将k:v看成列表推导式中的一个元素item</span></span><br><span class="line">print(li,type(li))  <span class="comment"># &#123;'a': 1, 'ab': 4&#125; &lt;class 'dict'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">li = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">not</span> <span class="keyword">in</span> k:</span><br><span class="line">        li[k] = v</span><br><span class="line">print(li, type(li) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键小写化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'B'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">4</span>, <span class="string">'A'</span>:<span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123; k.lower():v <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items() &#125;      </span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并大小写的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'B'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">4</span>, <span class="string">'A'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k.lower():dic.get(k.lower(), <span class="number">0</span>) + dic.get(k.upper(), <span class="number">0</span>) <span class="keyword">for</span> k <span class="keyword">in</span> dic.keys()&#125;</span><br><span class="line"><span class="comment"># 注：在dic内获取内容（键值）最好用get方法,0表示未获取到返回的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>集合推导式</strong></p><p>它们跟列表推导式也是类似的。 唯一的区别在于它使用大括号{}</p><p>• 集合推导式，自带去重功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">li = &#123;i*i <span class="keyword">for</span> i <span class="keyword">in</span> l&#125;</span><br><span class="line">print(li, type(li))</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-Python可迭代对象"><a href="#2-Python可迭代对象" class="headerlink" title="2. Python可迭代对象"></a>2. Python可迭代对象</h2><ul><li><h3 id="for-后面接可迭代对象"><a href="#for-后面接可迭代对象" class="headerlink" title="==for 后面接可迭代对象=="></a>==for 后面接可迭代对象==</h3><p>• 之前讲过的for可用的有哪些？<br>• list, set, str, dict, tuple<br>• list(可迭代对象)<br>• sorted(可迭代对象)</p></li><li><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not<br>in关键字判断元素是否包含在容器中。<br>通常这类数据结构把所有的元素存储在内存中（也有一些特例，并不是所有的元素都放在内存，比如<br>迭代器和生成器对象）</p></li><li><h3 id="在Python中，常见的容器对象有"><a href="#在Python中，常见的容器对象有" class="headerlink" title="在Python中，常见的容器对象有"></a>在Python中，常见的容器对象有</h3><p>• str,list, deque, tuple , …<br>• dict, defaultdict, OrderedDict, Counter, ….<br>• set, frozensets, ….</p></li><li><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>凡是可以返回一个迭代器的对象都可称之为可迭代对象。</p></li><li><h3 id="如何确认一个对象是不是可迭代对象"><a href="#如何确认一个对象是不是可迭代对象" class="headerlink" title="==如何确认一个对象是不是可迭代对象=="></a>==如何确认一个对象是不是可迭代对象==</h3><p>• 可迭代对象实现__iter__方法，该方法返回一个迭代器对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">dir(b) <span class="comment"># 如果有__iter__方法的话则表示该对象为可迭代对象</span></span><br><span class="line">[..., <span class="string">'__iter__'</span>, ...]</span><br></pre></td></tr></table></figure></li><li><h3 id="如何确定一个对象是不是可迭代对象"><a href="#如何确定一个对象是不是可迭代对象" class="headerlink" title="==如何确定一个对象是不是可迭代对象=="></a><strong>==如何确定一个对象是不是可迭代对象==</strong></h3><ul><li><p>Iterable判断</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'tom'</span>, <span class="string">'age'</span>:<span class="number">21</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> isinstance(a, Iterable):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'a是可迭代对象'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">a是可迭代对象</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> isinstance(b, Iterable): </span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'b是可迭代对象'</span>) </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">b是可迭代对象</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> isinstance(c, Iterable): </span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'c是可迭代对象'</span>) </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">c是可迭代对象</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> isinstance(d, Iterable): </span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'d是可迭代对象'</span>)  </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">d是可迭代对象</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="可迭代对象有哪些"><a href="#可迭代对象有哪些" class="headerlink" title="==可迭代对象有哪些=="></a><strong>==可迭代对象有哪些==</strong></h3><ul><li>容器都是可迭代对象</li><li>此外还有更多的对象同样也是可迭代对象，比如处于打开状态的files，sockets等等。</li><li>凡是可以返回一个迭代器（iter__）的对象都可称之为可迭代对象（dir(对象名)的列表结果中含有<strong>iter</strong>）</li></ul></li></ul><h2 id="3-迭代器（iterator）"><a href="#3-迭代器（iterator）" class="headerlink" title="3. 迭代器（iterator）"></a>3. 迭代器（iterator）</h2><ul><li><p><strong>什么是迭代器</strong></p><p>==<em>迭代器是有状态的，可以被next()调用，函数调用并不断返回下一</em>==<br>==<em>个值的对象称为迭代器(Iterator)。</em>==<br>==任何实现了<strong>iter</strong>()和<strong>next</strong>()都是迭代器==<br>• _<strong><em>iter _</em></strong>()：返回迭代器自身 表示可迭代的迭代器<br>• _<em>next_</em>()：返回容器中的下一个值<br>• 如果容器中没有更多元素了，则抛出==<strong>StopIteration</strong>==异常</p><p>•（for循环取数据遇到StopIteration时，会退出循环）</p><p>• 所有的Iterable均可以通过内置函数iter()来转变为Iterator。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  <span class="comment"># 这里x是一个可迭代对象，可迭代对象和容器一样是一种通俗的叫法，并不是指某种具</span></span><br><span class="line">				 <span class="comment"># 体的数据类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = iter(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">&lt;list_iterator object at <span class="number">0x0000019290BECBA8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x.__iter__() <span class="comment"># __iter__方法返回迭代器本身</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">&lt;list_iterator object at <span class="number">0x0000019290BEC9E8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = iter(x)			 <span class="comment"># y和z是两个独立的迭代器, 迭代器有一种具体的迭代器类型，比如									 # list_iterator, set_iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(y))</span><br><span class="line"><span class="number">1</span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(y))</span><br><span class="line"><span class="number">2</span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(z)) </span><br><span class="line"><span class="number">1</span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(x)) </span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(y)</span>)</span> </span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list_iterator</span>'&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>判断迭代器</strong></p><ul><li><p>看是否实现了__iter__ 和 __next__方法</p></li><li><p>Iterator判断</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable, Iterator </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ran = range(<span class="number">3</span>) </span><br><span class="line"><span class="comment"># ran是一个可迭代器对象, 并不是迭代器( iter(ran) 是一个迭代器)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> isinstance(ran, Iterable):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'ran 是可迭代的'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'ran 是不可迭代的'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ran 是可迭代的</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(dir(ran))</span><br><span class="line">[<span class="string">'__bool__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, </span><br><span class="line"><span class="string">'__repr__'</span>, <span class="string">'__reversed__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'count'</span>, <span class="string">'index'</span>, <span class="string">'start'</span>, <span class="string">'step'</span>, <span class="string">'stop'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(ran)) </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'range'</span> object <span class="keyword">is</span> <span class="keyword">not</span> an iterator</span><br><span class="line"><span class="comment"># 前面说了ran不是一个迭代器但是调用了迭代器的next方法,所以会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> isinstance(ran, Iterator): </span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'ran 是迭代器'</span>)     </span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>: </span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'ran 不是迭代器'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ran 不是迭代器</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>可迭代对象和迭代器的转换</strong></p><p><strong>==注: 迭代器一般都是可迭代对象==</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代器--&gt;迭代对象</span></span><br><span class="line"><span class="comment">#假设有一个列表可迭代对象 </span></span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 变成迭代器 </span></span><br><span class="line">li2 = iter(li)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设有一个迭代器 转列表可迭代对象</span></span><br><span class="line">a = iter(<span class="string">"abcd"</span>)</span><br><span class="line">print(a, list(a) )</span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">li2 = iter(li)</span><br><span class="line">print( li2, list(li2)  )  <span class="comment"># 方法主要是 list(迭代器名称) 即list set dic tuple str等</span></span><br></pre></td></tr></table></figure></li><li><h3 id="生成无限序列"><a href="#生成无限序列" class="headerlink" title="==生成无限序列=="></a>==生成无限序列==</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"><span class="comment"># 生成一个无限大的数据序列,从start开始</span></span><br><span class="line">counter = count(start = <span class="number">10</span>)</span><br><span class="line">print(counter, type(counter))</span><br><span class="line"><span class="comment"># print(dir(counter))</span></span><br><span class="line">print(next(counter))</span><br><span class="line">print(next(counter))</span><br><span class="line">print(next(counter))</span><br></pre></td></tr></table></figure></li><li><h3 id="从一个有限序列中生成无限序列"><a href="#从一个有限序列中生成无限序列" class="headerlink" title="==从一个有限序列中生成无限序列=="></a>==从一个有限序列中生成无限序列==</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">weeks = cycle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment"># 1 -&gt; 7 -&gt; 1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> weeks:</span><br><span class="line">    print(i)</span><br><span class="line">    time.sleep(<span class="number">1</span>) </span><br><span class="line"><span class="comment"># 此时weeks依然是迭代器,也是可迭代对象</span></span><br></pre></td></tr></table></figure></li><li><h3 id="从无限的序列中生成有限序列"><a href="#从无限的序列中生成有限序列" class="headerlink" title="==从无限的序列中生成有限序列=="></a>==从无限的序列中生成有限序列==</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count, islice</span><br><span class="line">counter = count(start=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s = islice(counter, <span class="number">1</span>, <span class="number">10</span>) <span class="comment"># 对迭代进行有限的'切片'从第1次之后到第10次截至作为</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 此时s依然是迭代器,也是可迭代对象</span></span><br></pre></td></tr></table></figure></li><li><p><strong>迭代器有什么好处</strong></p><p>迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休<br>眠状态等待下一次调用。</p></li></ul><h2 id="4-生成器（generator）"><a href="#4-生成器（generator）" class="headerlink" title="4. 生成器（generator）"></a>4. 生成器（generator）</h2><ul><li><p><strong>生成器表达式</strong><br>• 使用()生成generator， 将列表推导式的[]改成()即可得到生成器。<br>• 列表推导式与生成器表达式，定义和使用非常类似,但是,在(大量数据处理时)性能上相<br>差很大</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a = [x for x in range(10**9)]</span></span><br><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>**<span class="number">9</span>))</span><br><span class="line">print(a)</span><br><span class="line">print(dir(a))</span><br><span class="line">print(next(a))</span><br><span class="line">print(next(a))</span><br><span class="line">print(next(a))</span><br><span class="line"><span class="comment"># StopInterpter</span></span><br></pre></td></tr></table></figure></li><li><p>==<strong>yield关键字</strong>==<br>包含yield表达式的函数是特殊的函数,叫做<strong>生成器函数</strong>(generator function),被调用时将返回一个<br>迭代器(iterator),调用时可以使用next或send(msg)<br>• 一个生成器中可以有多个yield<br>• 一旦遇到yield，就会保存当前状态，然后返回yield后面的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">8</span></span><br><span class="line">    <span class="keyword">yield</span> x - <span class="number">1</span></span><br><span class="line">    y = <span class="number">6</span></span><br><span class="line">    <span class="keyword">yield</span> y + <span class="number">2</span></span><br><span class="line">    z = <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> z</span><br><span class="line"></span><br><span class="line">g = get_content() <span class="comment"># 实例化一个生成器</span></span><br><span class="line">print(type(g))</span><br><span class="line">print(next(g)) <span class="comment"># 第一次数据获取完退出函数,保留上次执行位置</span></span><br><span class="line">print(next(g)) <span class="comment"># 第二次再次执行会从上一次执行的地方再次执行</span></span><br><span class="line">print(next(g))</span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># &lt;classs 'generator'&gt;</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li><li><p>yield生成器来实现斐波那契数列</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    prev, curr = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> curr</span><br><span class="line">        prev, curr = curr, curr + prev</span><br><span class="line"></span><br><span class="line">f = fib()</span><br><span class="line">list(islice(f, <span class="number">0</span> ,<span class="number">10</span>))</span><br><span class="line"><span class="comment"># [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br></pre></td></tr></table></figure><p><strong>执行过程：</strong></p><p>• 当执行f=fib()返回的是一个生成器对象，此时函数体中的代码并不会执行，<strong>而是首先返回一个</strong><br><strong>iterable 对象！</strong><br>• 只有显示或隐示地调用next的时候才会真正执行函数里面的代码<br>• 执行到语句 yield b 时，fab() 函数会返回yield后面(右边)的值，<strong>并记住当前执行的状态</strong><br>• ==<strong>下次调用next时，程序流会回到 yield b 的下一条语句继续执行</strong>==<br>• ==看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返==<br>==回当前的迭代值。==<br>• 由此可以看出，==生成器通过关键字 yield 不断的将迭代器返回到内存进行处理，而不会一次性==<br>==的将对象全部放入内存，从而节省内存空间==。</p></li><li><p><strong>send数据</strong></p><p>除了可以使用 next() 方法来获取下一个生成的值，用户还可以使用 send() 方法将一个<br>新的或者是被修改的值返回给生成器。除此之外，还可以使用 close() 方法来随时退出<br>生成器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(start_at=<span class="number">0</span>)</span>:</span></span><br><span class="line">    count = start_at</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        val = (<span class="keyword">yield</span> count) <span class="comment"># send 发送的数据会赋值给val, next获取时, val值为None</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count = val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">count = counter(<span class="number">5</span>)</span><br><span class="line">print(type(count))</span><br><span class="line"><span class="comment"># generator</span></span><br><span class="line">print(count.__next__()) <span class="comment"># 在send之前必须有一个yield 返回之后才能用send</span></span><br><span class="line">print(count.send(<span class="number">9</span>)) <span class="comment"># 返回一个新的值给生成器中的 yield count</span></span><br><span class="line">print(count.__next__())</span><br><span class="line">count.close() <span class="comment"># 关闭一个生成器</span></span><br><span class="line">print(count.__next__())</span><br></pre></td></tr></table></figure></li><li><p>yield from</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> range(x)		<span class="comment"># 返回整个可迭代对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(x) <span class="comment"># 获取后面可迭代对象的内容，每一次作为一次返回</span></span><br><span class="line">it1 = g1(<span class="number">5</span>)</span><br><span class="line">it2 = g2(<span class="number">5</span>)</span><br><span class="line">print( [x <span class="keyword">for</span> x <span class="keyword">in</span> it1] )</span><br><span class="line"><span class="comment"># out [range(0, 5)]</span></span><br><span class="line">print( [x <span class="keyword">for</span> x <span class="keyword">in</span> it2] )</span><br><span class="line"><span class="comment"># out [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>==使用生成器最好的场景==</p><p>当你需要以迭代的方式去处理一个巨大的数据集合。比如：一个巨大的文件/一个复杂的数据库查<br>询等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(fpath)</span>:</span></span><br><span class="line">    BLOCK_SIZE = <span class="number">1024</span></span><br><span class="line">    <span class="keyword">with</span> open(fpathm, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        block = f.read(BLOCK_SIZE)</span><br><span class="line">        <span class="keyword">if</span> block:</span><br><span class="line">            <span class="keyword">yield</span> block</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>如果直接对文件对象调用 read() 方法，会导致不可预测的内存占用。<strong>==好的方法是利用固定长度的缓冲区来不断读取文件的部分内容==</strong>。通过 yield，我们不再需要编写读文件的迭代类，就可以轻松<br>实现文件读取。</p></li><li><p>==<strong>生成器的好处</strong>==<br>生成器在Python中是一个非常强大的编程结构<br>• 可以用更少地中间变量写流式代码<br>• 相比其它容器对象它更能节省内存<br>• 可以用更少的代码来实现相似的功能</p></li></ul><h2 id="5-可迭代对象、迭代器、生成器"><a href="#5-可迭代对象、迭代器、生成器" class="headerlink" title="5. 可迭代对象、迭代器、生成器"></a>5. 可迭代对象、迭代器、生成器</h2><ul><li><p>三种关系小结</p><p><img src="https://wx1.sbimg.cn/2020/07/12/CuvAT.png" alt="image-20200706173831682"></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
        <category>迭代器与生成器</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>迭代器与生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中深拷贝和浅拷贝</title>
    <url>/2020/06/09/%E8%B0%88%E8%B0%88python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="Python中深拷贝和浅拷贝"><a href="#Python中深拷贝和浅拷贝" class="headerlink" title="Python中深拷贝和浅拷贝"></a>Python中深拷贝和浅拷贝</h1><p>python中深拷贝和浅拷贝的知识这里进行下总结，以便今后复习<br><code>python</code>中的深拷贝和浅拷贝和<code>java</code>里面的概念是一样的，所谓浅拷贝就是对引用的拷贝，所谓深拷贝就是对对象的资源的拷贝。<br>首先，对<strong>赋值</strong>操作我们要有以下认识：</p><ol><li>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址（ 旧瓶装旧酒 ）。</li><li>修改不可变对象（<code>str</code>、<code>tuple</code>）需要开辟新的空间</li><li>修改可变对象（<code>list</code>等）不需要开辟新的空间</li></ol><ul><li><strong>浅拷贝</strong>仅仅复制了容器中元素的地址</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">'hello'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">6444104</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">6444104</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="string">'world'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">[<span class="string">'hello'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>这里可以看出，未修改前，<code>a</code>和<code>b</code>中元素的地址都是相同的，不可变的<code>hello</code><br>和可变的<code>list</code>地址都一样，说明浅拷贝知识将容器内的元素的地址复制了一份。这可以通过修改后，<code>b</code>中字符串没改变，但是<code>list</code>元素随着<code>a</code>相应改变得到验证。</p><blockquote><p>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。</p></blockquote><ul><li><strong>深拷贝</strong>，完全拷贝了一个副本，容器内部元素地址都不一样</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">'hello'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">55645000</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">58338824</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="string">'world'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">[<span class="string">'hello'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>这里可以看出，深拷贝后，<code>a</code>和<code>b</code>的地址以及<code>a</code>和<code>b</code>中的元素地址均不同，这是完全拷贝的一个副本，修改<code>a</code>后，发现<code>b</code>没有发生任何改变，因为<code>b</code>是一个完全的副本，元素地址与<code>a</code>均不同，<code>a</code>修改不影响<code>b</code>。</p><blockquote><p>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说（ 新瓶装新酒 ）。</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>学生管理系统</title>
    <url>/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="学生管理系统"><a href="#学生管理系统" class="headerlink" title="学生管理系统"></a>学生管理系统</h1><h2 id="（第1阶段）学生信息管理系统部分截图"><a href="#（第1阶段）学生信息管理系统部分截图" class="headerlink" title="（第1阶段）学生信息管理系统部分截图"></a>（第1阶段）学生信息管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1-1.JPG" alt="1-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1-2.JPG" alt="1-2.JPG"></p><h2 id="（第2阶段）学生选课管理系统部分截图"><a href="#（第2阶段）学生选课管理系统部分截图" class="headerlink" title="（第2阶段）学生选课管理系统部分截图"></a>（第2阶段）学生选课管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-1.JPG" alt="2-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-2.JPG" alt="2-2.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-3.JPG" alt="2-3.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-4.JPG" alt="2-4.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-5.JPG" alt="2-5.JPG"></p><h2 id="（第3阶段）学生签到考勤系统截图-略"><a href="#（第3阶段）学生签到考勤系统截图-略" class="headerlink" title="（第3阶段）学生签到考勤系统截图(略)"></a>（第3阶段）学生签到考勤系统截图(略)</h2><h2 id="（第4阶段）学生成绩管理系统部分截图"><a href="#（第4阶段）学生成绩管理系统部分截图" class="headerlink" title="（第4阶段）学生成绩管理系统部分截图"></a>（第4阶段）学生成绩管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-1.JPG" alt="4-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-2.JPG" alt="4-2.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-3.JPG" alt="4-3.JPG"></p><h4 id="完整源代码和视频教学资源：百度云链接-百度网盘，提取码：3jbh"><a href="#完整源代码和视频教学资源：百度云链接-百度网盘，提取码：3jbh" class="headerlink" title="完整源代码和视频教学资源：百度云链接:百度网盘，提取码：3jbh"></a><strong><em>完整源代码和视频教学资源：百度云链接:<a href="https://pan.baidu.com/s/1vwebuzdVTBmSc-bHdbEnSg" target="_blank" rel="noopener">百度网盘</a>，提取码：3jbh</em></strong></h4><!-- rebuild by neat -->]]></content>
      <categories>
        <category>学生管理系统</category>
      </categories>
      <tags>
        <tag>学生管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数参数</title>
    <url>/2020/06/16/python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Sun Jul 12 2020 17:09:03 GMT+0800 (GMT+08:00) --><h1 id="Python函数参数"><a href="#Python函数参数" class="headerlink" title="Python函数参数"></a>Python函数参数</h1><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>我们以具体的例子来说明如何定义函数的默认参数。先写一个计算x^2的函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure><p>当我们调用<code>power</code>函数时，必须传入有且仅有的一个参数<code>x</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(15)</span><br><span class="line">225</span><br></pre></td></tr></table></figure><p>现在，如果我们要计算x^3怎么办？可以再定义一个<code>power3</code>函数，但是如果要计算x^4 x^5……怎么办？我们不可能定义无限多个函数。</p><p>你也许想到了，可以把<code>power(x)</code>修改为<code>power(x, n)</code>，用来计算x^n，说干就干：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><p>对于这个修改后的<code>power</code>函数，可以计算任意n次方：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 3)</span><br><span class="line">125</span><br></pre></td></tr></table></figure><p>但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码无法正常调用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: power() takes exactly 2 arguments (1 given)</span><br></pre></td></tr></table></figure><p>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n&#x3D;2):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>而对于<code>n &gt; 2</code>的其他情况，就必须明确地传入n，比如<code>power(5, 3)</code>。</p><p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</p><p>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</p><p>二是如何设置默认参数。</p><p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p><p>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p><p>举个例子，我们写个一年级小学生注册的函数，需要传入<code>name</code>和<code>gender</code>两个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enroll(name, gender):</span><br><span class="line">    print &#39;name:&#39;, name</span><br><span class="line">    print &#39;gender:&#39;, gender</span><br></pre></td></tr></table></figure><p>这样，调用<code>enroll()</code>函数只需要传入两个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&#39;Sarah&#39;, &#39;F&#39;)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br></pre></td></tr></table></figure><p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。</p><p>我们可以把年龄和城市设为默认参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enroll(name, gender, age&#x3D;6, city&#x3D;&#39;Beijing&#39;):</span><br><span class="line">    print &#39;name:&#39;, name</span><br><span class="line">    print &#39;gender:&#39;, gender</span><br><span class="line">    print &#39;age:&#39;, age</span><br><span class="line">    print &#39;city:&#39;, city</span><br></pre></td></tr></table></figure><p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&#39;Sarah&#39;, &#39;F&#39;)</span><br><span class="line">Student:</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br><span class="line">age: 6</span><br><span class="line">city: Beijing</span><br></pre></td></tr></table></figure><p>只有与默认参数不符的学生才需要提供额外的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enroll(&#39;Bob&#39;, &#39;M&#39;, 7)</span><br><span class="line">enroll(&#39;Adam&#39;, &#39;M&#39;, city&#x3D;&#39;Tianjin&#39;)</span><br></pre></td></tr></table></figure><p>可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p><p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll(&#39;Bob&#39;, &#39;M&#39;, 7)</code>，意思是，除了<code>name</code>，<code>gender</code>这两个参数外，最后1个参数应用在参数<code>age</code>上，<code>city</code>参数由于没有提供，仍然使用默认值。</p><p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)</code>，意思是，<code>city</code>参数用传进去的值，其他默认参数继续使用默认值。</p><p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：</p><p>先定义一个函数，传入一个list，添加一个<code>END</code>再返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add_end(L&#x3D;[]):</span><br><span class="line">    L.append(&#39;END&#39;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure><p>当你正常调用时，结果似乎不错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end([1, 2, 3])</span><br><span class="line">[1, 2, 3, &#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span><br><span class="line">[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;END&#39;]</span><br></pre></td></tr></table></figure><p>当你使用默认参数调用时，一开始结果也是对的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br></pre></td></tr></table></figure><p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;, &#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]</span><br></pre></td></tr></table></figure><p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了<code>&#39;END&#39;</code>后的list。</p><p>原因解释如下：</p><p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><p>所以，定义默认参数要牢记一点：默认参数必须指向不变对象！</p><p>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add_end(L&#x3D;None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L &#x3D; []</span><br><span class="line">    L.append(&#39;END&#39;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure><p>现在，无论调用多少次，都不会有问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br></pre></td></tr></table></figure><p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p><p>我们以数学题为例子，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……。</p><p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def calc(numbers):</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum &#x3D; sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>但是调用的时候，需要先组装出一个list或tuple：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br></pre></td></tr></table></figure><p>如果利用可变参数，调用函数的方式可以简化成这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2, 3)</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc(1, 3, 5, 7)</span><br><span class="line">84</span><br></pre></td></tr></table></figure><p>所以，我们把函数的参数改为可变参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum &#x3D; sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; calc()</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; nums &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; nums &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>这种写法相当有用，而且很常见。</p><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print &#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw</span><br></pre></td></tr></table></figure><p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#39;Michael&#39;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br></pre></td></tr></table></figure><p>也可以传入任意个数的关键字参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#39;Bob&#39;, 35, city&#x3D;&#39;Beijing&#39;)</span><br><span class="line">name: Bob age: 35 other: &#123;&#39;city&#39;: &#39;Beijing&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#39;Adam&#39;, 45, gender&#x3D;&#39;M&#39;, job&#x3D;&#39;Engineer&#39;)</span><br><span class="line">name: Adam age: 45 other: &#123;&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure><p>关键字参数有什么用？它可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; kw &#x3D; &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city&#x3D;kw[&#39;city&#39;], job&#x3D;kw[&#39;job&#39;])</span><br><span class="line">name: Jack age: 24 other: &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure><p>当然，上面复杂的调用可以用简化的写法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; kw &#x3D; &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, **kw)</span><br><span class="line">name: Jack age: 24 other: &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure><h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。</p><p>比如定义一个函数，包含上述4种参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(a, b, c&#x3D;0, *args, **kw):</span><br><span class="line">    print &#39;a &#x3D;&#39;, a, &#39;b &#x3D;&#39;, b, &#39;c &#x3D;&#39;, c, &#39;args &#x3D;&#39;, args, &#39;kw &#x3D;&#39;, kw</span><br></pre></td></tr></table></figure><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; func(1, 2)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 0 args &#x3D; () kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, c&#x3D;3)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; () kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3, &#39;a&#39;, &#39;b&#39;)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (&#39;a&#39;, &#39;b&#39;) kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3, &#39;a&#39;, &#39;b&#39;, x&#x3D;99)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (&#39;a&#39;, &#39;b&#39;) kw &#x3D; &#123;&#39;x&#39;: 99&#125;</span><br></pre></td></tr></table></figure><p>最神奇的是通过一个tuple和dict，你也可以调用该函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; args &#x3D; (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw &#x3D; &#123;&#39;x&#39;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; func(*args, **kw)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (4,) kw &#x3D; &#123;&#39;x&#39;: 99&#125;</span><br></pre></td></tr></table></figure><p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p><p>默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！</p><p>要注意定义可变参数和关键字参数的语法：</p><p><code>*args</code>是可变参数，args接收的是一个tuple；</p><p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p><p>以及调用函数时如何传入可变参数和关键字参数的语法：</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p><p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>初识python装饰器</title>
    <url>/2020/07/14/%E5%88%9D%E8%AF%86python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<!-- build time:Tue Jul 14 2020 22:29:27 GMT+0800 (GMT+08:00) --><h2 id="先来个形象比方"><a href="#先来个形象比方" class="headerlink" title="先来个形象比方"></a>先来个形象比方</h2><p>内裤可以用来遮羞，但是到了冬天它没法为我们防风御寒，聪明的人们发明了长裤，有了长裤后宝宝再也不冷了，装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。</p><p>再回到我们的主题<br>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。<br>先来看一个简单例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br></pre></td></tr></table></figure><p>现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br><span class="line">    logging.info(<span class="string">"foo is running"</span>)</span><br></pre></td></tr></table></figure><p>bar()、bar2()也有类似的需求，怎么做？再写一个logging在bar函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个函数：专门处理日志 ，日志处理完之后再执行真正的业务代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    logging.warn(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line"></span><br><span class="line">use_logging(bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>逻辑上不难理解， 但是这样的话，我们每次都要将一个函数作为参数传递给use_logging函数。而且这种方式已经破坏了原有的代码逻辑结构，之前执行业务逻辑时，执行运行bar()，但是现在不得不改成use_logging(bar)。那么有没有更好的方式的呢？当然有，答案就是装饰器。</p><h2 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a><strong>简单装饰器</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        logging.warn(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line"></span><br><span class="line">bar = use_logging(bar)</span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>函数use_logging就是装饰器，它把执行真正业务方法的func包裹在函数里面，看起来像bar被use_logging装饰了。==在这个例子中，函数进入和退出时 ，被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。==</p><p>@符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        logging.warn(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"i am foo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"i am bar"</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>如上所示，这样我们就可以省去bar = use_logging(bar)这一句了，直接调用bar()即可得到想要的结果。如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p><p>装饰器在Python使用如此方便都要归因于Python的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a><strong>带参数的装饰器</strong></h2><p>装饰器还有更大的灵活性，例如带参数的装饰器：在上面的装饰器调用中，比如@use_logging，该装饰器唯一的参数就是执行业务的函数。装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</span><br><span class="line">                logging.warn(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name=<span class="string">'foo'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"i am %s"</span> % name)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># WARNING:root:foo is running</span></span><br><span class="line"><span class="comment"># i am foo</span></span><br></pre></td></tr></table></figure><p>==上面的use_logging是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。==当我 们使用@use_logging(level=”warn”)调用的时候，Python能够发现这一层的封装，并把参数传递到装饰器的环境中。</p><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a><strong>类装饰器</strong></h2><p>==再来看看类装饰器，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。<strong>使用类装饰器还可以依靠类内部的__call__方法</strong>，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法（<strong>__call__</strong>）。==</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'class decorator runing'</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'class decorator ending'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># class decorator runing</span></span><br><span class="line"><span class="comment"># bar</span></span><br><span class="line"><span class="comment"># class decorator ending</span></span><br></pre></td></tr></table></figure><h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a><strong>functools.wraps</strong></h2><p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子：</p><p>装饰器</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> func.__name__ + <span class="string">" was called"</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">   <span class="string">"""does some math"""</span></span><br><span class="line">   <span class="keyword">return</span> x + x * x</span><br></pre></td></tr></table></figure><p>该函数完成等价于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""does some math"""</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br><span class="line">f = logged(f)</span><br></pre></td></tr></table></figure><p>不难发现，函数f被with_logging取代了，当然它的docstring，<strong>name</strong>就是变成了with_logging函数的信息了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> f.__name__    <span class="comment"># prints 'with_logging'</span></span><br><span class="line"><span class="keyword">print</span> f.__doc__     <span class="comment"># prints None</span></span><br></pre></td></tr></table></figure><p>这个问题就比较严重的，好在我们有functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> func.__name__ + <span class="string">" was called"</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""does some math"""</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> f.__name__  <span class="comment"># prints 'f'</span></span><br><span class="line"><span class="keyword">print</span> f.__doc__   <span class="comment"># prints 'does some math'</span></span><br></pre></td></tr></table></figure><h2 id="内置装饰器"><a href="#内置装饰器" class="headerlink" title="内置装饰器"></a><strong>内置装饰器</strong></h2><p>@staticmathod（静态方法）、@classmethod（类方法）、@property（定义后产生setter和deleter装饰器,这两个是由property本身创建）</p><h2 id="装饰器的顺序"><a href="#装饰器的顺序" class="headerlink" title="装饰器的顺序"></a>装饰器的顺序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> <span class="params">()</span>:</span></span><br></pre></td></tr></table></figure><p>等效于<br><code>f = a(b(c(f)))</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
        <category>装饰器</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python闭包</title>
    <url>/2020/07/14/Python%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<!-- build time:Tue Jul 14 2020 22:30:00 GMT+0800 (GMT+08:00) --><h1 id="Python闭包"><a href="#Python闭包" class="headerlink" title="Python闭包"></a><strong>Python闭包</strong></h1><p>由于闭包这个概念比较难以理解，尤其是初学者来说，相对难以掌握，所以我们通过示例去理解学习闭包。</p><p>给大家提个需求，然后用函数去实现：完成一个计算不断增加的系列值的平均值的需求。</p><p>例如：整个历史中的某个商品的平均收盘价。什么叫平局收盘价呢？就是从这个商品一出现开始，每天记录当天价格，然后计算他的平均值：平均值要考虑直至目前为止所有的价格。</p><p>比如大众推出了一款新车：小白轿车。</p><p>第一天价格为：100000元，平均收盘价：100000元</p><p>第二天价格为：110000元，平均收盘价：（100000 + 110000）/2 元</p><p>第三天价格为：120000元，平均收盘价：（100000 + 110000 + 120000）/3 元</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">series = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">    series.append(new_value)</span><br><span class="line">    total = sum(series)</span><br><span class="line">    <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">print(make_averager(<span class="number">100000</span>))</span><br><span class="line">print(make_averager(<span class="number">110000</span>))</span><br><span class="line">print(make_averager(<span class="number">120000</span>))</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，基本上完成了我们的要求，但是这个代码相对来说是不安全的，因为你的这个series列表是一个全局变量，只要是全局作用域的任何地方，都可能对这个列表进行改变。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">series = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">    series.append(new_value)</span><br><span class="line">    total = sum(series)</span><br><span class="line">    <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">print(make_averager(<span class="number">100000</span>))</span><br><span class="line">print(make_averager(<span class="number">110000</span>))</span><br><span class="line">series.append(<span class="number">666</span>)  <span class="comment"># 如果对数据进行相应改变，那么你的平均收盘价就会出现很大的问题。</span></span><br><span class="line">print(make_averager(<span class="number">120000</span>))</span><br></pre></td></tr></table></figure><p>那么怎么办呢？有人说，你把他放在函数中不就行了，这样不就是局部变量了么？数据不就相对安全了么？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">    series = []</span><br><span class="line">    series.append(new_value)</span><br><span class="line">    total = sum(series)</span><br><span class="line">    <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(make_averager(<span class="number">100000</span>))  <span class="comment"># 100000.0</span></span><br><span class="line">print(make_averager(<span class="number">110000</span>))  <span class="comment"># 110000.0</span></span><br><span class="line">print(make_averager(<span class="number">120000</span>))  <span class="comment"># 120000.0</span></span><br></pre></td></tr></table></figure><p>这样计算的结果是不正确的,那是因为执行函数，会开启一个临时的名称空间，随着函数的结束而消失，所以你每次执行函数的时候，都是重新创建这个列表，那么这怎么做呢？这种情况下，就需要用到我们讲的闭包了，我们用闭包的思想改一下这个代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    series = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line">print(avg(<span class="number">100000</span>))</span><br><span class="line">print(avg(<span class="number">110000</span>))</span><br><span class="line">print(avg(<span class="number">120000</span>))</span><br></pre></td></tr></table></figure><p><strong>大家仔细看一下这个代码，我是在函数中嵌套了一个函数。那么avg 这个变量接收的实际是averager函数名，也就是其对应的内存地址，我执行了三次avg 也就是执行了三次averager这个函数。那么此时你们有什么问题？</strong></p><p>肯定有学生就会问，那么我的make_averager这个函数只是执行了一次，为什么series这个列表没有消失？反而还可以被调用三次呢？这个就是最关键的地方，也是闭包的精华所在。我给大家说一下这个原理，以图为证：</p><p><img src="https://wx1.sbimg.cn/2020/07/14/CYggA.png" alt><br>上面被红色方框框起来的区域就是闭包，被蓝色圈起来的那个变量应该是make_averager()函数的局部变量，它应该是随着make_averager()函数的执行结束之后而消失。但是他没有，是因为此区域形成了闭包，series变量就变成了一个叫自由变量的东西，averager函数的作用域会延伸到包含自由变量series的绑定。也就是说，每次我调用avg对应的averager函数 时，都可以引用到这个自用变量series，这个就是闭包。</p><p>闭包的定义：</p><ol><li>闭包是嵌套在函数中的函数</li><li>闭包必须是内层函数对外层函数的变量（非全局变量）的引用。</li></ol><p>如何判断判断闭包？举例让同学回答：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例一：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">ret = wrapper()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例二：</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">ret = wrapper()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例三：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">ret = wrapper(a,b)</span><br></pre></td></tr></table></figure><p>以上三个例子，最难判断的是第三个，其实第三个也是闭包，如果我们每次去研究代码判断其是不是闭包，有一些不科学，或者过于麻烦了，那么有一些函数的属性是可以获取到此函数是否拥有自由变量的，如果此函数拥有自由变量，那么就可以侧面证明其是否是闭包函数了（了解）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    series = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line">avg = make_averager()</span><br><span class="line"><span class="comment"># 函数名.__code__.co_freevars 查看函数的自由变量</span></span><br><span class="line">print(avg.__code__.co_freevars)  <span class="comment"># ('series',)</span></span><br><span class="line">当然还有一些参数，仅供了解：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名.__code__.co_freevars 查看函数的自由变量</span></span><br><span class="line">print(avg.__code__.co_freevars)  <span class="comment"># ('series',)</span></span><br><span class="line"><span class="comment"># 函数名.__code__.co_varnames 查看函数的局部变量</span></span><br><span class="line">print(avg.__code__.co_varnames)  <span class="comment"># ('new_value', 'total')</span></span><br><span class="line"><span class="comment"># 函数名.__closure__ 获取具体的自由变量对象，也就是cell对象。</span></span><br><span class="line"><span class="comment"># (&lt;cell at 0x0000020070CB7618: int object at 0x000000005CA08090&gt;,)</span></span><br><span class="line"><span class="comment"># cell_contents 自由变量具体的值</span></span><br><span class="line">print(avg.__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># []</span></span><br></pre></td></tr></table></figure><p><strong>闭包的作用：保存局部信息不被销毁，保证数据的安全性。</strong></p><p><strong>闭包的应用：</strong></p><ol><li>可以保存一些非全局变量但是不易被销毁、改变的数据。</li><li>装饰器。</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Go问答101</title>
    <url>/2020/08/09/GO%E9%97%AE%E7%AD%94101/</url>
    <content><![CDATA[<!-- build time:Sun Aug 09 2020 21:11:33 GMT+0800 (GMT+08:00) --><h1 id="Go问答101"><a href="#Go问答101" class="headerlink" title="Go问答101"></a>Go问答101</h1><p><em>（这是一份非官方Go问答列表。官方版问答列表<a href="https://golang.google.cn/doc/faq" target="_blank" rel="noopener">在这里</a>。）</em></p><p>索引：</p><ul><li>编译器与运行时<ul><li><a href="https://gfw.go101.org/article/unofficial-faq.html#error-non-name" target="_blank" rel="noopener">编译器错误信息<code>non-name *** on left side of :=</code>意味着什么?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#error-missing-left-brace" target="_blank" rel="noopener">编译器错误信息<code>unexpected newline, expecting { after if clause</code>意味着什么?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#error-declared-not-used" target="_blank" rel="noopener">编译器错误信息<code>declared and not used</code>意味着什么?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#map-iteration-order" target="_blank" rel="noopener">Go运行时是否维护映射条目的遍历顺序？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#compiler-field-padding" target="_blank" rel="noopener">Go编译器是否会进行字节填充以确保结构体字段的地址对齐？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#final-zero-size-field" target="_blank" rel="noopener">为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体类型的尺寸？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#new-function" target="_blank" rel="noopener"><code>new(T)</code>是<code>var t T; (&amp;t)</code>的语法糖吗？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#fatal-error-deadlock" target="_blank" rel="noopener">运行时错误信息<code>all goroutines are asleep - deadlock</code>意味着什么?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#64-bit-alignment" target="_blank" rel="noopener">64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#atomical-assignment" target="_blank" rel="noopener">赋值是原子操作吗？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#zero-values-zero-bytes" target="_blank" rel="noopener">是否每一个零值在内存中占据的字节都是零？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#function-inline" target="_blank" rel="noopener">标准的Go编译器是否支持函数内联？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#finalizers" target="_blank" rel="noopener">终结器（finalizer）可以用做对象的析构函数吗？</a></li></ul></li><li>标准库<ul><li><a href="https://gfw.go101.org/article/unofficial-faq.html#get-days-of-month" target="_blank" rel="noopener">如何使用尽可能短的代码行数来获取任意月份的天数？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#time-sleep-after" target="_blank" rel="noopener">函数调用<code>time.Sleep(d)</code>和通道接收<code>&lt;-time.After(d)</code>操作之间有何区别？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#trim" target="_blank" rel="noopener">调用<code>strings</code>和<code>bytes</code>标准库包里<code>TrimLeft</code>和<code>TrimRight</code>函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#fmt-print-println" target="_blank" rel="noopener">函数<code>fmt.Print</code>和<code>fmt.Println</code>的区别是什么？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#log-print-println" target="_blank" rel="noopener">函数<code>log.Print</code>和函数<code>log.Println</code>有什么区别吗?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#fmt-print-synced" target="_blank" rel="noopener">函数<code>fmt.Print</code>、<code>fmt.Println</code>和<code>fmt.Printf</code>的实现进行同步了吗？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#print-builtin-fmt-log" target="_blank" rel="noopener">内置的<code>print</code>和<code>println</code>函数与<code>fmt</code>和<code>log</code>标准库包中相应的打印函数有什么区别？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#math-crypto-rand" target="_blank" rel="noopener">通过标准库包<code>math/rand</code>和<code>crypto/rand</code>生成的随机数之间有什么区别？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#math-round" target="_blank" rel="noopener">标准库中为什么没有<code>math.Round</code>函数？</a></li></ul></li><li>类型系统<ul><li><a href="https://gfw.go101.org/article/unofficial-faq.html#uncomparable-types" target="_blank" rel="noopener">哪些类型不支持比较？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#nil-equality" target="_blank" rel="noopener">为什么两个<code>nil</code>值有时候会不相等？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#slice-conversion" target="_blank" rel="noopener">为什么类型<code>[\]T1</code>和<code>[]T2</code>没有共享相同底层类型，即使不同的类型<code>T1</code>和<code>T2</code>共享相同的底层类型？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#unaddressable-values" target="_blank" rel="noopener">哪些值可以被取地址，哪些值不可以被取地址？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#map-elements-are-unaddressable" target="_blank" rel="noopener">为什么映射元素不可被取地址？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#slice-elements-always-addressable" target="_blank" rel="noopener">为什么非空切片的元素总是可被取地址，即便对于不可取地址的切片也是如此？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#method-set-relation" target="_blank" rel="noopener">对任意的非指针、非接口定义类型<code>T</code>，为什么类型<code>*T</code>的方法集总是类型<code>T</code>的方法集的超集，但是反之却不然？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#types-can-have-methods" target="_blank" rel="noopener">我们可以为哪些类型声明方法？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#declare-immutables" target="_blank" rel="noopener">在Go里如何声明不可变量？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#set-container-type" target="_blank" rel="noopener">为什么没有内置的<code>set</code>容器类型？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#byte-rune-slice-string" target="_blank" rel="noopener">什么是byte？什么是rune？如何将<code>[\]byte</code>和<code>[]rune</code>的值转换为字符串？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#pointer-atomic" target="_blank" rel="noopener">如何原子地操作指针值？</a></li></ul></li><li>其它<ul><li><a href="https://gfw.go101.org/article/unofficial-faq.html#about-iota" target="_blank" rel="noopener"><code>iota</code>是什么意思？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#check-if-channels-closed" target="_blank" rel="noopener">为什么没有一个内置的<code>closed</code>函数用来检查通道是否已经关闭？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#return-local-pointers" target="_blank" rel="noopener">函数返回局部变量的指针是否安全？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#gopher" target="_blank" rel="noopener">单词<strong><em>gopher\</em></strong>在Go社区中表示什么？</a></li></ul></li></ul><h3 id="编译器错误信息non-name-on-left-side-of-意味着什么"><a href="#编译器错误信息non-name-on-left-side-of-意味着什么" class="headerlink" title="编译器错误信息non-name *** on left side of :=意味着什么?"></a>编译器错误信息<code>non-name *** on left side of :=</code>意味着什么?</h3><p>直到目前（Go 1.15）, Go中对短变量声明有一个<a href="https://golang.google.cn/ref/spec#Short_variable_declarations" target="_blank" rel="noopener">强制性约束</a>：</p><p>所有位于<code>:=</code>符号左侧的条目都必须是纯<a href="https://golang.google.cn/ref/spec#Identifiers" target="_blank" rel="noopener">标识符</a>，并且其中至少有一个为新变量名称。</p><p>这意味着容器元素索引表达式（<code>x[i]</code>）、结构体的字段选择器（<code>x.f</code>）、指针解引用（<code>*p</code>）和限定标识符（<code>aPackage.Value</code>）都不能出现在<code>:=</code>符号的左侧。</p><p>目前，这还是一个<a href="https://github.com/golang/go/issues/377" target="_blank" rel="noopener">未解决问题</a>（已经和<a href="https://github.com/golang/go/issues/6842" target="_blank" rel="noopener">一个相关问题</a>合并）。而且感觉Go核心开发团队目前<a href="https://github.com/golang/go/issues/30318" target="_blank" rel="noopener">并未有立即解决此问题的打算</a>。</p><h3 id="编译器错误信息unexpected-newline-expecting-意味着什么"><a href="#编译器错误信息unexpected-newline-expecting-意味着什么" class="headerlink" title="编译器错误信息unexpected newline, expecting { ...意味着什么?"></a>编译器错误信息<code>unexpected newline, expecting { ...</code>意味着什么?</h3><p>在编写Go代码时，我们不能随意断行。 请阅读<a href="https://gfw.go101.org/article/line-break-rules.html" target="_blank" rel="noopener">代码断行规则</a>一文以了解Go代码断行规则。 一般来说，根据这些规则，在左括号之前断行是不合法的。</p><p>例如，下列代码片段</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = []<span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会被编译器解释成</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span>;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = []<span class="keyword">int</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go编译器将为每个左大括号<code>{</code>起始的代码行报告一个语法错误。 为避免这些报错，我们需要将上述代码重写为下面这样：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = []<span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译器错误信息declared-and-not-used意味着什么"><a href="#编译器错误信息declared-and-not-used意味着什么" class="headerlink" title="编译器错误信息declared and not used意味着什么?"></a>编译器错误信息<code>declared and not used</code>意味着什么?</h3><p>对于标准编译器，在局部代码块中声明的每一个变量必须被至少一次用做r-value（right-hand-side value，右值）。</p><p>因此，下列代码将编译失败，因为<code>y</code>只被用做目标值（目标值都为左值）。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">1</span> <span class="comment">// y被声明了但没有被用做右值</span></span><br><span class="line">	<span class="keyword">if</span> x &#123;</span><br><span class="line">		y = <span class="number">2</span> <span class="comment">// 这里，y被用做左值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go运行时是否维护映射条目的遍历顺序？"><a href="#Go运行时是否维护映射条目的遍历顺序？" class="headerlink" title="Go运行时是否维护映射条目的遍历顺序？"></a>Go运行时是否维护映射条目的遍历顺序？</h3><p>不。<a href="https://golang.google.cn/ref/spec#For_range" target="_blank" rel="noopener">Go白皮书</a>明确提到映射元素的迭代顺序时未定义的。 所以对于同一个映射值，它的一个遍历过程和下一个遍历过程中的元素呈现次序不保证是相同的。 对于标准编译器，映射元素的遍历顺序是随机的。 如果你需要固定的映射元素遍历顺序，那么你就需要自己来维护这个顺序。 更多信息请阅读Go官方博客文章<a href="https://blog.golang.com/go-maps-in-action#TOC_7." target="_blank" rel="noopener">Go maps in action</a>。</p><p>但是请注意：从Go 1.12开始，标准库包中的各个打印函数的结果中，映射条目总是排了序的。</p><h3 id="Go编译器是否会进行字节填充以确保结构体字段的地址对齐？"><a href="#Go编译器是否会进行字节填充以确保结构体字段的地址对齐？" class="headerlink" title="Go编译器是否会进行字节填充以确保结构体字段的地址对齐？"></a>Go编译器是否会进行字节填充以确保结构体字段的地址对齐？</h3><p>至少对于标准的Go编译器和gccgo，答案是肯定的。 具体需要填充多少个字节取决于操作系统和编译器实现。 请阅读<a href="https://gfw.go101.org/article/memory-layout.html#size-and-padding" target="_blank" rel="noopener">关于Go值的内存布局</a>一文获取详情。</p><p>Go编译器将不会重新排列结构体的字段来最小化结构体值的尺寸。 因为这样做会导致意想不到的结果。 但是，根据需要，程序员可以手工重新排序字段来实现填充最小化。</p><h3 id="为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？"><a href="#为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？" class="headerlink" title="为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？"></a>为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？</h3><p>一个可寻址的结构值的所有字段都可以被取地址。 如果非零尺寸的结构体值的最后一个字段的尺寸是零，那么取此最后一个字段的地址将会返回一个越出了为此结构体值分配的内存块的地址。 这个返回的地址可能指向另一个被分配的内存块。 在目前的官方Go标准运行时的实现中，如果一个内存块被至少一个依然活跃的指针引用，那么这个内存块将不会被视作垃圾因而肯定不会被回收。 所以只要有一个活跃的指针存储着此非零尺寸的结构体值的最后一个字段的越界地址，它将阻止垃圾收集器回收另一个内存块，从而可能导致内存泄漏。</p><p>为避免上述问题，标准的Go编译器会确保取一个非零尺寸的结构体值的最后一个字段的地址时，绝对不会返回越出分配给此结构体值的内存块的地址。 Go标准编译器通过在需要时在结构体最后的零尺寸字段之后填充一些字节来实现这一点。</p><p>如果一个结构体的全部字段的类型都是零尺寸的(因此整个结构体也是零尺寸的)，那么就不需要再填充字节，因为标准编译器会专门处理零尺寸的内存块。</p><p>一个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">		a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">		x <span class="keyword">int64</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(unsafe.Sizeof(T1&#123;&#125;)) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">		x <span class="keyword">int64</span></span><br><span class="line">		a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(unsafe.Sizeof(T2&#123;&#125;)) <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-T-是var-t-T-amp-t-的语法糖吗？"><a href="#new-T-是var-t-T-amp-t-的语法糖吗？" class="headerlink" title="new(T)是var t T; (&amp;t)的语法糖吗？"></a><code>new(T)</code>是<code>var t T; (&amp;t)</code>的语法糖吗？</h3><p>虽然这两者在实现上会有一些微妙的差别，取决于编译器的具体实现，但是我们基本上可以认为这两者是等价的。 即，通过<code>new</code>函数分配的内存块可以在栈上，也可以在堆上。</p><h3 id="运行时错误信息all-goroutines-are-asleep-deadlock意味着什么"><a href="#运行时错误信息all-goroutines-are-asleep-deadlock意味着什么" class="headerlink" title="运行时错误信息all goroutines are asleep - deadlock意味着什么?"></a>运行时错误信息<code>all goroutines are asleep - deadlock</code>意味着什么?</h3><p>用词<strong><em>asleep\</em></strong>在这里其实并不准确，实际上它的意思是<strong><em>处于阻塞状态\</em></strong>。</p><p>因为一个处于阻塞状态的协程只能被另一个协程解除阻塞，如果程序中所有的协程都进入了阻塞状态，则它们将永远都处于阻塞状态。 这意味着程序死锁了。一个正常运行的程序永远不应该死锁，一个死锁的程序肯定是由于逻辑实现上的bug造成的。 因此官方Go标准运行时将在一个程序死锁时令其崩溃退出。</p><h3 id="64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？"><a href="#64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？" class="headerlink" title="64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？"></a>64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？</h3><p>传递给<code>sync/atomic</code>标准库包中的64位函数的地址必须是64位对齐的，否则调用这些函数将在运行时导致恐慌产生。</p><p>对于标准编译器和gccgo编译器，在64位架构下，64位整数的地址将保证总是64位对齐的。 所以它们总是可以被安全地原子访问。 但在32位架构下，64位整数的地址仅保证是32位对齐的。 所以原子访问某些64位整数可能会导致恐慌。 但是，有一些方法可以保证一些64位整数总是可以被安全地原子访问。 请阅读<a href="https://gfw.go101.org/article/memory-layout.html#64bit-atomic-operation" target="_blank" rel="noopener">关于Go值的内存布局</a>一文以获得详情。</p><h3 id="赋值是原子操作吗？"><a href="#赋值是原子操作吗？" class="headerlink" title="赋值是原子操作吗？"></a>赋值是原子操作吗？</h3><p>对于标准编译器来说，赋值不是原子操作。</p><p>请阅读<a href="https://golang.google.cn/doc/faq#What_operations_are_atomic_What_about_mutexes" target="_blank" rel="noopener">官方FAQ中的此问答</a>以了解更多。</p><h3 id="是否每一个零值在内存中占据的字节都是零？"><a href="#是否每一个零值在内存中占据的字节都是零？" class="headerlink" title="是否每一个零值在内存中占据的字节都是零？"></a>是否每一个零值在内存中占据的字节都是零？</h3><p>对于大部分类型，答案是肯定的。不过事实上，这依赖于编译器。 例如，对于标准编译器，对于某些字符串类型的零值，此结论并不十分正确。</p><p>比如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 <span class="keyword">string</span></span><br><span class="line">	fmt.Println(s1 == <span class="string">""</span>) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1))) <span class="comment">// 0</span></span><br><span class="line">	<span class="keyword">var</span> s2 = <span class="string">"abc"</span>[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">	fmt.Println(s2 == <span class="string">""</span>) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s2))) <span class="comment">// 4869856</span></span><br><span class="line">	fmt.Println(s1 == s2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反过来，对于标准编译器已经支持的所有架构，如果一个值的所有字节都是零，那么这个值肯定是它的类型的零值。 然而，Go规范并没有保证这一点。我曾听说在某些比较老的处理器上，空指针表示的内存地址并不为零。</p><h3 id="标准的Go编译器是否支持函数内联？"><a href="#标准的Go编译器是否支持函数内联？" class="headerlink" title="标准的Go编译器是否支持函数内联？"></a>标准的Go编译器是否支持函数内联？</h3><p>是的，标准编译器支持函数内联。编译器会自动的内联短小的并且不调用其它函数的函数。 内联规则可能会在不同编译器版本之间发生变化。</p><p>目前（Go 1.15），对于标准编译器，</p><ul><li><p>没有显式的方式来在用户代码中指定哪些函数应该被内联。</p></li><li><p>尽管编译参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-gcflags &quot;-l&quot;</span><br></pre></td></tr></table></figure><p>可以阻止任何函数被内联， 但是并没有正式的方式来避免某个特定的用户函数被内联。 目前有以下两种非正式的方法来避免一个函数被内联（这两种方式都有有可能在未来的Go标准编译器版本中失效）：</p><ol><li>你可以在函数声明前增加一行<code>//go:noinline</code> 指令来避免这个函数被内联。</li><li>由于包含循环块的函数不会内联，所以你可以再函数里增加一个空循环 <code>for false {}</code>来避免该函数被内联。 （但是这个方法<a href="https://github.com/golang/go/issues/14768" target="_blank" rel="noopener">从以后的某个Go官方工具链版本开始将不再有效</a>。）</li></ol></li></ul><h3 id="终结器（finalizer）可以用做对象的析构函数吗？"><a href="#终结器（finalizer）可以用做对象的析构函数吗？" class="headerlink" title="终结器（finalizer）可以用做对象的析构函数吗？"></a>终结器（finalizer）可以用做对象的析构函数吗？</h3><p>在Go程序里，我们可以通过调用<code>runtime.SetFinalizer</code>函数来给一个对象设置一个终结器函数。 一般说来，此终结器函数将在此对象被垃圾回收之前调用。 但是终结器并非被设计为对象的析构函数。 通过<code>runtime.SetFinalizer</code>函数设置的终结器函数并不保证总会被运行。 因此我们不应该依赖于终结器来保证程序的正确性。</p><p>终结器的主要用途是为了库包的维护者能够尽可能地避免因为库包使用者不正确地使用库包而带来的危害。 例如，我们知道，当在程序中使用完某个文件后，我们应该将其关闭。 但是有时候因为种种原因，比如经验不足或者粗心大意，导致一些文件在使用完成后并未被关闭，那么和这些文件相关的很多资源只有在此程序退出之后才能得到释放。这属于资源泄漏。 为了尽可能地避免防止资源泄露，<code>os</code>库包的维护者将会在一个<code>os.File</code>对象被被创建的时候为之设置一个终结器。 此终结器函数将关闭此<code>os.File</code>对象。当此<code>os.File</code>对象因为不再被使用而被垃圾回收的时候，此终结器函数将被调用。</p><p>请记住，有一些终结器函数永远不会被调用，并且有时候不当的设置终结器函数将会阻止对象被垃圾回收。 关于更多细节，请阅读<a href="https://golang.google.cn/pkg/runtime/#SetFinalizer" target="_blank" rel="noopener">runtime.SetFinalizer函数的文档</a>。</p><h3 id="如何使用尽可能短的代码行数来获取任意月份的天数？"><a href="#如何使用尽可能短的代码行数来获取任意月份的天数？" class="headerlink" title="如何使用尽可能短的代码行数来获取任意月份的天数？"></a>如何使用尽可能短的代码行数来获取任意月份的天数？</h3><p>假设输入的年份是一个自然年，并且输入的月份也是一个自然月（1代表1月）。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">days := time.Date(year, month+<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC).Day()</span><br></pre></td></tr></table></figure><p>对于Go中的<code>time</code>标准库包，正常月份的去值范围为<code>[1, 12]</code>，并且每个月的起始日是<code>1</code>。 所以，<code>y</code>年的<code>m</code>月的起始时间就是<code>time.Date(y, m, 1, 0, 0, 0, 0, time.UTC)</code>。</p><p>传递给<code>time.Date</code>函数的实参可以超出它们的正常范围，此函数将这些实参进行规范化。 例如，1月32日会被转换成2月1日。</p><p>以下是一些Go语言里的日期使用示例：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 2017-02-01 00:00:00 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2017-01-31 23:59:59.999999999 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, time.UTC))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2017-01-31 00:00:00 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2016-12-31 00:00:00 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2016</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2017-02-01 00:00:00 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2016</span>, <span class="number">13</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用time-Sleep-d-和通道接收-lt-time-After-d-操作之间有何区别？"><a href="#函数调用time-Sleep-d-和通道接收-lt-time-After-d-操作之间有何区别？" class="headerlink" title="函数调用time.Sleep(d)和通道接收&lt;-time.After(d)操作之间有何区别？"></a>函数调用<code>time.Sleep(d)</code>和通道接收<code>&lt;-time.After(d)</code>操作之间有何区别？</h3><p>两者都会将当前的goroutine执行暂停一段时间。 区别在于<code>time.Sleep(d)</code>函数调用将使当前的协程进入睡眠字状态，但是当前协程的<a href="https://gfw.go101.org/article/control-flows-more.html#states-of-goroutine" target="_blank" rel="noopener">（主）状态</a>依然为运行状态； 而通道接收<code>&lt;-time.After(d)</code>操作将使当前协程进入阻塞状态。</p><h3 id="调用strings和bytes标准库包里TrimLeft和TrimRight函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？"><a href="#调用strings和bytes标准库包里TrimLeft和TrimRight函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？" class="headerlink" title="调用strings和bytes标准库包里TrimLeft和TrimRight函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？"></a>调用<code>strings</code>和<code>bytes</code>标准库包里<code>TrimLeft</code>和<code>TrimRight</code>函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？</h3><p>哈，我们不能保证这些函数的实现绝对没有bug，但是如果这些函数返回的结果是不符你的预期，更有可能的是你的期望是不正确的。</p><p>标准包<code>strings</code>和<code>bytes</code>里有多个修剪（trim）函数。 这些函数可以被分类为两组：</p><ol><li><code>Trim</code>、<code>TrimLeft</code>、<code>TrimRight</code>、<code>TrimSpace</code>、<code>TrimFunc</code>、<code>TrimLeftFunc</code>和<code>TrimRightFunc</code>。 这些函数将修剪首尾所有满足指定（或隐含）条件的utf-8编码的Unicode码点(即rune)。（<code>TrimSpace</code>隐含了修剪各种空格符。） 这些函数将检查每个开头或结尾的rune值，直到遇到一个不满足条件的rune值为止。</li><li><code>TrimPrefix</code>和<code>TrimSuffix</code>。 这两个函数会把指定前缀或后缀的子字符串（或子切片）作为一个整体进行修剪。</li></ol><p><a href="https://github.com/golang/go/issues/19172" target="_blank" rel="noopener">部分</a><a href="https://github.com/golang/go/issues/18160" target="_blank" rel="noopener">程序员</a><a href="https://github.com/golang/go/issues/14657" target="_blank" rel="noopener">会</a>把<code>TrimLeft</code>和<code>TrimRight</code>函数当作<code>TrimPrefix</code>和<code>TrimSuffix</code>函数而<a href="https://github.com/golang/go/issues/19371" target="_blank" rel="noopener">误用</a>。 自然地，函数返回的结果很可能不是预期的那样。</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s = <span class="string">"abaay森z众xbbab"</span></span><br><span class="line">	o := fmt.Println</span><br><span class="line">	o(strings.TrimPrefix(s, <span class="string">"ab"</span>)) <span class="comment">// aay森z众xbbab</span></span><br><span class="line">	o(strings.TrimSuffix(s, <span class="string">"ab"</span>)) <span class="comment">// abaay森z众xbb</span></span><br><span class="line">	o(strings.TrimLeft(s, <span class="string">"ab"</span>))   <span class="comment">// y森z众xbbab</span></span><br><span class="line">	o(strings.TrimRight(s, <span class="string">"ab"</span>))  <span class="comment">// abaay森z众x</span></span><br><span class="line">	o(strings.Trim(s, <span class="string">"ab"</span>))       <span class="comment">// y森z众x</span></span><br><span class="line">	o(strings.TrimFunc(s, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r &lt; <span class="number">128</span> <span class="comment">// trim all ascii chars</span></span><br><span class="line">	&#125;)) <span class="comment">// 森z众</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数fmt-Print和fmt-Println-的区别是什么？"><a href="#函数fmt-Print和fmt-Println-的区别是什么？" class="headerlink" title="函数fmt.Print和fmt.Println 的区别是什么？"></a>函数<code>fmt.Print</code>和<code>fmt.Println</code> 的区别是什么？</h3><p><code>fmt.Println</code>函数总会在两个相邻的参数之间输出一个空格，然而<code>fmt.Print</code>函数仅当两个相邻的参数（的具体值）都不是字符串类型时才会在它们之间输出一个空格。</p><p>另外一个区别是<code>fmt.Println</code>函数会在结尾写入一个换行符，但是<code>fmt.Print</code>函数不会。</p><h3 id="函数log-Print-和函数-log-Println-有什么区别吗"><a href="#函数log-Print-和函数-log-Println-有什么区别吗" class="headerlink" title="函数log.Print 和函数 log.Println 有什么区别吗?"></a>函数<code>log.Print</code> 和函数 <code>log.Println</code> 有什么区别吗?</h3><p>函数<code>log.Print</code>与<code>log.Println</code>的区别与上一个问题里描述的关于函数<code>fmt.Print</code>和<code>fmt.Println</code>的第一个区别点类似。</p><p>这两个函数都会在结尾输出一个换行符。</p><h3 id="函数fmt-Print、fmt-Println和fmt-Printf的实现进行同步了吗？"><a href="#函数fmt-Print、fmt-Println和fmt-Printf的实现进行同步了吗？" class="headerlink" title="函数fmt.Print、fmt.Println和fmt.Printf的实现进行同步了吗？"></a>函数<code>fmt.Print</code>、<code>fmt.Println</code>和<code>fmt.Printf</code>的实现进行同步了吗？</h3><p>没有。 如果有同步的需求，请使用<code>log</code>标准库包里的相应函数。 你可以调用<code>log.SetFlags(0)</code>来避免每一个日志行的前缀输出。</p><h3 id="内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？"><a href="#内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？" class="headerlink" title="内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？"></a>内置的<code>print</code>和<code>println</code>函数与<code>fmt</code>和<code>log</code>标准库包中相应的打印函数有什么区别？</h3><p>除了上一个问题里提到的区别之外，这三组函数之间还有一些其他区别。</p><ol><li>内置的<code>print</code>/<code>println</code>函数总是写入标准错误。 <code>fmt</code>标准包里的打印函数总是写入标准输出。<code>log</code>标准包里的打印函数会默认写入标准错误，然而也可以通过<code>log.SetOutput</code>函数来配置。</li><li>内置<code>print</code>/<code>println</code>函数的调用不能接受数组和结构体参数。</li><li>对于组合类型的参数，内置的<code>print</code>/<code>println</code>函数将输出参数的底层值部的地址，而<code>fmt</code>和<code>log</code>标准库包中的打印函数将输出接口参数的动态值的字面形式。</li><li>目前（Go 1.15），对于标准编译器，调用内置的<code>print</code>/<code>println</code>函数不会使调用参数引用的值逃逸到堆上，而<code>fmt</code>和<code>log</code>标准库包中的打印函数将使调用参数引用的值逃逸到堆上。</li><li>如果一个实参有<code>String() string</code>或<code>Error() string</code>方法，那么<code>fmt</code>和<code>log</code>标准库包里的打印函数在打印参数时会调用这两个方法，而内置的<code>print</code>/<code>println</code>函数则会忽略参数的这些方法。</li><li>内置的<code>print</code>/<code>println</code>函数不保证在未来的Go版本中继续存在。</li></ol><h3 id="标准库包math-rand和crypto-rand生成的随机数之间有什么区别？"><a href="#标准库包math-rand和crypto-rand生成的随机数之间有什么区别？" class="headerlink" title="标准库包math/rand和crypto/rand生成的随机数之间有什么区别？"></a>标准库包<code>math/rand</code>和<code>crypto/rand</code>生成的随机数之间有什么区别？</h3><p>通过<code>math/rand</code>标准库包生成的伪随机数序列对于给定的种子是确定的。 这样生成的随机数不适用于安全敏感的环境中。 如果处于加密安全目的，我们应该使用<code>crypto/rand</code>标准库包生成的伪随机数序列。</p><h3 id="标准库中为什么没有math-Round函数"><a href="#标准库中为什么没有math-Round函数" class="headerlink" title="标准库中为什么没有math.Round函数?"></a>标准库中为什么没有<code>math.Round</code>函数?</h3><p><code>math.Round</code>函数是有的，但是只是从Go 1.10开始才有这个函数。 从Go 1.10开始，标准库添加了两个新函数<code>math.Round</code>和<code>math.RoundToEven</code>。</p><p>在Go 1.10之前，关于 <code>math.Round</code>函数是否应该被添加进标准包，经历了<a href="https://github.com/golang/go/issues/4594" target="_blank" rel="noopener">很长时候的讨论</a>。</p><h3 id="哪些类型不支持比较？"><a href="#哪些类型不支持比较？" class="headerlink" title="哪些类型不支持比较？"></a>哪些类型不支持比较？</h3><p>下列类型不支持比较：</p><ul><li>映射（map）</li><li>切片</li><li>函数</li><li>包含不可比较字段的结构体类型</li><li>元素类型为不可比较类型的数组类型</li></ul><p>不支持比较的类型不能用做映射类型的键值类型。</p><p>请注意：</p><ul><li>尽管映射，切片和函数值不支持比较，但是它们的值可以与类型不确定的<code>nil</code>标识符比较。</li><li>如果两个接口值的动态类型相同且不可比较，那么在运行时<a href="https://gfw.go101.org/article/interface.html#comparison" target="_blank" rel="noopener">比较这两个接口的值</a>会产生一个恐慌。</li></ul><p>关于为什么映射，切片和函数不支持比较，请阅读Go的官方FAQ中<a href="https://golang.google.cn/doc/faq#map_keys" target="_blank" rel="noopener">关于这个问答</a>。</p><h3 id="为什么两个nil值有时候会不相等？"><a href="#为什么两个nil值有时候会不相等？" class="headerlink" title="为什么两个nil值有时候会不相等？"></a>为什么两个<code>nil</code>值有时候会不相等？</h3><p><em>（Go官方FAQ中的<a href="https://golang.google.cn/doc/faq#nil_error" target="_blank" rel="noopener">这个答案</a>也回答了这个问题。）</em></p><p>一个接口值可以看作是一个包裹非接口值的盒子。被包裹在一个接口值中的非接口值的类型必须实现了此接口值的类型。 在Go中，很多种类型的类型的零值都是用<code>nil</code>来表示的。 一个什么都没包裹的接口值为一个零值接口值，即nil接口值。 一个包裹着其它非接口类型的nil值的接口值并非什么都没包裹，所以它不是（或者说它不等于）一个nil接口值。</p><p>当对一个nil接口值和一个nil非接口值进行比较时（假设它们可以比较），此nil非接口值将先被转换为nil接口值的类型，然后再进行比较； 此转换的结果为一个包裹了此nil非接口值的一个副本的接口值，此接口值不是（或者说它不等于）一个nil接口值，所以此比较不相等。</p><p>关于更详细的解释请阅读<a href="https://gfw.go101.org/article/interface.html" target="_blank" rel="noopener">接口</a>和<a href="https://gfw.go101.org/article/nil.html" target="_blank" rel="noopener">关于Go中的<code>nil</code></a>两篇文章。</p><p>一个示例：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pi *<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> pb *<span class="keyword">bool</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = pi</span><br><span class="line">	<span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125; = pb</span><br><span class="line">	<span class="keyword">var</span> z <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(x == y)   <span class="comment">// false</span></span><br><span class="line">	fmt.Println(x == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">	fmt.Println(y == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">	fmt.Println(x == z)   <span class="comment">// false</span></span><br><span class="line">	fmt.Println(y == z)   <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么类型-T1和-T2没有共享相同底层类型，即使不同的类型T1和T2共享相同的底层类型？"><a href="#为什么类型-T1和-T2没有共享相同底层类型，即使不同的类型T1和T2共享相同的底层类型？" class="headerlink" title="为什么类型[]T1和[]T2没有共享相同底层类型，即使不同的类型T1和T2共享相同的底层类型？"></a>为什么类型<code>[]T1</code>和<code>[]T2</code>没有共享相同底层类型，即使不同的类型<code>T1</code>和<code>T2</code>共享相同的底层类型？</h3><p><em>（不久前，Go官方FAQ也增加了<a href="https://golang.google.cn/doc/faq#convert_slice_with_same_underlying_type" target="_blank" rel="noopener">一个相似的问题</a>。）</em></p><p>在Go语言中，仅当两个切片类型共享相同的<a href="https://gfw.go101.org/article/type-system-overview.html#underlying-type" target="_blank" rel="noopener">底层类型</a>时，其中一个切片类型才可以转换成另一个切片的类型而不需要使用<a href="https://gfw.go101.org/article/unsafe.html" target="_blank" rel="noopener"><code>unsafe</code>机制</a>。</p><p>一个非定义组合类型的底层类型是此组合类型本身。 所以即便两个不同的类型<code>T1</code>和<code>T2</code>共享相同的底层类型，类型<code>[]T1</code>和<code>[]T2</code>也依然是不同的类型，因此它们的底层类型也是不同的。这意味着其中一个的值不能转换为另一个。</p><p>底层类型<code>[]T1</code>和<code>[]T2</code>不同的原因是：</p><ul><li>把<code>[]T1</code>和<code>[]T2</code>的值相互转换的需求在实践中并不常见。</li><li>使得<a href="https://gfw.go101.org/article/type-system-overview.html#underlying-type" target="_blank" rel="noopener">底层类型的溯源规则</a>更加简单。</li></ul><p>同样的原因也适用于其它组合类型。 例如：类型<code>map[T]T1</code> 和 <code>map[T]T2</code>同样不共享相同的底层类型，即便<code>T1</code> 和 <code>T2</code>共享相同的底层类型。</p><p>类型<code>[]T1</code>的值时候有可能通过使用<code>unsafe</code>机制转换成<code>[]T2</code>的，但是一般不建议这么做：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b = *(*[]MyInt)(unsafe.Pointer(&amp;a))</span><br><span class="line">	b[<span class="number">0</span>]= <span class="number">123</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// [123 8 9]</span></span><br><span class="line">	fmt.Println(b) <span class="comment">// [123 8 9]</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T \n"</span>, a) <span class="comment">// []int</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T \n"</span>, b) <span class="comment">// []main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哪些值可以被取地址，哪些值不可以被取地址？"><a href="#哪些值可以被取地址，哪些值不可以被取地址？" class="headerlink" title="哪些值可以被取地址，哪些值不可以被取地址？"></a>哪些值可以被取地址，哪些值不可以被取地址？</h3><p>以下的值是不可以寻址的：</p><ul><li>字符串的字节元素</li><li>映射元素</li><li>接口值的动态值（类型断言的结果）</li><li>常量（包括有名常量和字面量）</li><li>声明的包级别函数</li><li>方法（用做函数值）</li><li>中间结果值<ul><li>函数调用</li><li>显式值转换</li><li>各种操作，不包含指针解引用（dereference）操作，但是包含：<ul><li>通道接收操作</li><li>子字符串操作</li><li>子切片操作</li><li>加法、减法、乘法、以及除法等等。</li></ul></li></ul></li></ul><p>请注意：<code>&amp;T{}</code>在Go里是一个语法糖，它是<code>tmp := T{}; (&amp;tmp)</code>的简写形式。 所以<code>&amp;T{}</code>是合法的并不代表字面量<code>T{}</code>是可寻址的。</p><p>以下的值是可寻址的，因此可以被取地址：</p><ul><li>变量</li><li>可寻址的结构体的字段</li><li>可寻址的数组的元素</li><li>任意切片的元素（无论是可寻址切片或不可寻址切片）</li><li>指针解引用（dereference）操作</li></ul><h3 id="为什么映射元素不可被取地址？"><a href="#为什么映射元素不可被取地址？" class="headerlink" title="为什么映射元素不可被取地址？"></a>为什么映射元素不可被取地址？</h3><p>在Go中，映射的设计保证一个映射值在内存允许的情况下可以加入任意个条目。 另外为了防止一个映射中为其条目开辟的内存段支离破碎，官方标准编译器使用了哈希表来实现映射。 并且为了保证元素索引的效率，一个映射值的底层哈希表只为其中的所有条目维护一段连续的内存段。 因此，一个映射值随着其中的条目数量逐渐增加时，其维护的连续的内存段需要不断重新开辟来增容，并把原来内存段上的条目全部复制到新开辟的内存段上。 另外，即使一个映射值维护的内存段没有增容，某些哈希表实现也可能在当前内存段中移动其中的条目。 总之，映射中的元素的地址会因为各种原因而改变。 如果映射元素可以被取地址，则Go运行时（runtime）必须在元素地址改变的时候修改所有存储了元素地址的指针值。 这极大得增加了Go编译器和运行时的实现难度，并且严重影响了程序运行效率。 因此，目前，Go中禁止取映射元素的地址。</p><p>映射元素不可被取地址的另一个原因是表达式<code>aMap[key]</code>可能返回一个存储于<code>aMap</code>中的元素，也可能返回一个不存储于其中的元素零值。 这意味着表达式<code>aMap[key]</code>在<code>(&amp;aMap[key]).Modify()</code>调用执行之后可能仍然被估值为元素零值。 这将使很多人感到困惑，因此在Go中禁止取映射元素的地址。</p><h3 id="为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？"><a href="#为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？" class="headerlink" title="为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？"></a>为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？</h3><p>切片的内部类型是一个结构体，类似于</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	elements unsafe.Pointer <span class="comment">// 引用着一个元素序列</span></span><br><span class="line">	length   <span class="keyword">int</span></span><br><span class="line">	capacity <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个切片间接引用一个元素序列。 尽管一个非空切片是不可取地址的，它的内部元素序列需要开辟在内存中的某处因而必须是可取地址的。 取一个切片的元素地址事实上是取内部元素序列上的元素地址。 因此，不可寻址的非空切片的元素也是可以被取地址的。</p><h3 id="对任意的非指针和非接口定义类型T，为什么类型-T的方法集总是类型T的方法集的超集，但是反之却不然？"><a href="#对任意的非指针和非接口定义类型T，为什么类型-T的方法集总是类型T的方法集的超集，但是反之却不然？" class="headerlink" title="对任意的非指针和非接口定义类型T，为什么类型*T的方法集总是类型T的方法集的超集，但是反之却不然？"></a>对任意的非指针和非接口定义类型<code>T</code>，为什么类型<code>*T</code>的方法集总是类型<code>T</code>的方法集的超集，但是反之却不然？</h3><p>在Go语言中，为了方便，对于一个非指针和非接口定义类型<code>T</code>，</p><ul><li>一个<code>T</code>类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此<code>T</code>的值是可寻址的情况下。 编译器在调用指针属主方法前，会自动取此<code>T</code>值的地址。 因为不是任何<code>T</code>值都是可寻址的，所以并非任何<code>T</code>值都能够调用为类型<code>*T</code>声明的方法。 这种便利只是一个语法糖，而不是一种固有的规则。</li><li>一个<code>*T</code>类型的值可以调用为类型<code>T</code>声明的方法。 这是因为解引用指针总是合法的。 这种便利不仅仅是一个语法糖，它也是一种固有的规则。</li></ul><p>所以很合理的， <code>*T</code>的方法集总是<code>T</code>方法集的超集，但反之不然。</p><p>事实上，你可以认为对于每一个为类型<code>T</code>声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。 详见<a href="https://gfw.go101.org/article/method.html#implicit-pointer-methods" target="_blank" rel="noopener">方法</a>一文。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">MethodX</span><span class="params">(v0 ParamType0, ...)</span> <span class="params">(ResultType0, ...)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器将会为*T隐式声明一个如下的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pt *T)</span> <span class="title">MethodX</span><span class="params">(v0 ParamType0, ...)</span> <span class="params">(ResultType0, ...)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (*pt).MethodX(v0, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多解释请阅读Go官方FAQ中的<a href="https://golang.google.cn/doc/faq#different_method_sets" target="_blank" rel="noopener">这个问答</a>。</p><h3 id="我们可以为哪些类型声明方法？"><a href="#我们可以为哪些类型声明方法？" class="headerlink" title="我们可以为哪些类型声明方法？"></a>我们可以为哪些类型声明方法？</h3><p>请阅读<a href="https://gfw.go101.org/article/method.html" target="_blank" rel="noopener">方法</a>一文获取答案。</p><h3 id="在Go里如何声明不可变量？"><a href="#在Go里如何声明不可变量？" class="headerlink" title="在Go里如何声明不可变量？"></a>在Go里如何声明不可变量？</h3><p>如下是三种<strong><em>不可变值\</em></strong>的定义：</p><ol><li>没有地址的值（所以它们不可以寻址）。</li><li>有地址但是因为种种原因在语法上不可以寻址的值。</li><li>可寻址但不允许在语法上被修改的值。</li></ol><p>在Go语言中，直到现在（Go 1.15），没有值满足第三种定义。</p><p>有名常量值满足第一种定义。</p><p>方法和声明的函数可以被视为声明的不可变值。 它们满足第二种定义。字符串的字节元素同样满足第二种定义。</p><p>在Go中没有办法声明其它不可变值。</p><h3 id="为什么没有内置的set容器类型？"><a href="#为什么没有内置的set容器类型？" class="headerlink" title="为什么没有内置的set容器类型？"></a>为什么没有内置的<code>set</code>容器类型？</h3><p>集合（set）可以看作是不关心元素值的映射。 在Go语言里，<code>map[Tkey]struct{}</code>经常被用做一个集合类型。</p><h3 id="什么是byte？什么是rune？-如何将-byte和-rune类型的值转换为字符串？"><a href="#什么是byte？什么是rune？-如何将-byte和-rune类型的值转换为字符串？" class="headerlink" title="什么是byte？什么是rune？ 如何将[]byte和[]rune类型的值转换为字符串？"></a>什么是byte？什么是rune？ 如何将<code>[]byte</code>和<code>[]rune</code>类型的值转换为字符串？</h3><p>在Go语言里，<code>byte</code>是<code>uint8</code>类型的一个别名。 换言之，<code>byte</code> 和 <code>uint8</code>是相同的类型。 <code>rune</code>和<code>int32</code>属于同样类似的关系。</p><p>一个<code>rune</code>值通常被用来存储一个Unicode码点。</p><p><code>[]byte</code>和<code>[]rune</code>类型的值可以被显式地直接转换成字符串，反之亦然。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s0 = <span class="string">"Go"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> bs = []<span class="keyword">byte</span>(s0)</span><br><span class="line">	<span class="keyword">var</span> s1 = <span class="keyword">string</span>(bs)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> rs = []<span class="keyword">rune</span>(s0)</span><br><span class="line">	<span class="keyword">var</span> s2 = <span class="keyword">string</span>(rs)</span><br><span class="line"></span><br><span class="line">	fmt.Println(s0 == s1) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(s0 == s2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于字符串的信息，请阅读<a href="https://gfw.go101.org/article/string.html" target="_blank" rel="noopener">Go中的字符串</a>一文。</p><h3 id="如何原子地操作指针值？"><a href="#如何原子地操作指针值？" class="headerlink" title="如何原子地操作指针值？"></a>如何原子地操作指针值？</h3><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">	<span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">int</span> <span class="comment">// just a demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(newP *T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加载（读取）</span></span><br><span class="line">	<span class="keyword">var</span> _ = (*T)(atomic.LoadPointer(</span><br><span class="line">		(*unsafe.Pointer)(unsafe.Pointer(&amp;p)),</span><br><span class="line">		))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储（修改）</span></span><br><span class="line">	atomic.StorePointer(</span><br><span class="line">		(*unsafe.Pointer)(unsafe.Pointer(&amp;p)),</span><br><span class="line">		unsafe.Pointer(newP),</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换</span></span><br><span class="line">	<span class="keyword">var</span> oldP = (*T)(atomic.SwapPointer(</span><br><span class="line">		(*unsafe.Pointer)(unsafe.Pointer(&amp;p)),</span><br><span class="line">		unsafe.Pointer(newP),</span><br><span class="line">		))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 比较并交换</span></span><br><span class="line">	<span class="keyword">var</span> swapped = atomic.CompareAndSwapPointer(</span><br><span class="line">		(*unsafe.Pointer)(unsafe.Pointer(&amp;p)),</span><br><span class="line">		unsafe.Pointer(oldP),</span><br><span class="line">		unsafe.Pointer(newP),</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">	_ = swapped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，目前指针的原子操作使用起来非常得繁琐。</p><h3 id="iota是什么意思？"><a href="#iota是什么意思？" class="headerlink" title="iota是什么意思？"></a><code>iota</code>是什么意思？</h3><p>Iota是希腊字母表中的第九个字母。 在Go语言中，<code>iota</code>用在常量声明中。 在每一个常量声明组中，其值在该常量声明组的第<strong><em>N\</em></strong>个常量规范中的值为<code>N</code>。</p><h3 id="为什么没有一个内置的closed函数用来检查通道是否已经关闭？"><a href="#为什么没有一个内置的closed函数用来检查通道是否已经关闭？" class="headerlink" title="为什么没有一个内置的closed函数用来检查通道是否已经关闭？"></a>为什么没有一个内置的<code>closed</code>函数用来检查通道是否已经关闭？</h3><p>原因是此函数的实用性非常有限。 此类函数调用的返回结果不能总是反映输入通道实参的最新状态。 所以依靠此函数的返回结果来做决定不是一个好主意。</p><p>如果你确实需要这种函数，你可以不怎么费功夫地自己写一个。 请阅读<a href="https://gfw.go101.org/article/channel-closing.html" target="_blank" rel="noopener">如何优雅地关闭通道</a>一文来了解如何编写一个<code>closed</code>函数以及如何避免使用这样的函数。</p><h3 id="函数返回局部变量的指针是否安全？"><a href="#函数返回局部变量的指针是否安全？" class="headerlink" title="函数返回局部变量的指针是否安全？"></a>函数返回局部变量的指针是否安全？</h3><p>是的，在Go中这是绝对安全的。</p><p>支持栈的Go编译器将会对每个局部变量进行逃逸分析。 如果编译器发现某个局部变量开辟在栈上不是绝对安全的，则此局部变量将被开辟在堆上。 请阅读<a href="https://gfw.go101.org/article/memory-block.html" target="_blank" rel="noopener">内存块</a>一文了解更多。</p><h3 id="单词gopher-在Go社区中表示什么？"><a href="#单词gopher-在Go社区中表示什么？" class="headerlink" title="单词gopher\在Go社区中表示什么？"></a>单词<strong><em>gopher\</em></strong>在Go社区中表示什么？</h3><p>在Go社区中，<strong><em>gopher\</em></strong>表示Go程序员。 这个昵称可能是源自于Go语言采用了<a href="https://blog.golang.com/gopher" target="_blank" rel="noopener">一个卡通小地鼠（gopher）</a>做为吉祥物。 顺便说一下，这个卡通小地鼠是由<em>Renee French</em>设计的。 <em>Renee French</em>是Go项目首任负责人<em>Rob Pike</em>的妻子。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode下的GO扩展工具安装</title>
    <url>/2020/08/09/VsCode%E4%B8%8B%E7%9A%84GO%E6%89%A9%E5%B1%95%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<!-- build time:Sun Aug 09 2020 23:06:44 GMT+0800 (GMT+08:00) --><p>由于vscode对go语言的支持还是很不错滴，所以我日常学习go都用vscode，但这货有个毛病，各种lint、补全、nav、调试都依赖go语言的其他扩展工具，如果安装补全，会给出类似提示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The <span class="string">"gocode"</span> <span class="built_in">command</span> is not available. Use <span class="string">"go get -v github.com/mdempsky/gocode"</span> to install.</span><br></pre></td></tr></table></figure><p>但如果按照vscode的提示点击“安装”后，经过漫长等待，会迎来进一步提示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gocode:</span><br><span class="line">Error: Command failed: /usr/local/<span class="keyword">go</span>/bin/<span class="keyword">go</span> get -u -v github.com/mdempsky/gocode</span><br><span class="line">github.com/mdempsky/gocode (download)</span><br><span class="line">Fetching https:<span class="comment">//golang.org/x/tools/go/gcexportdata?go-get=1</span></span><br><span class="line">https fetch failed: Get https:<span class="comment">//golang.org/x/tools/go/gcexportdata?go-get=1: dial tcp 216.239.37.1:443: i/o timeout</span></span><br><span class="line"><span class="keyword">package</span> golang.org/x/tools/<span class="keyword">go</span>/gcexportdata: unrecognized <span class="keyword">import</span> path <span class="string">"golang.org/x/tools/go/gcexportdata"</span> (https fetch: Get https:<span class="comment">//golang.org/x/tools/go/gcexportdata?go-get=1: dial tcp 216.239.37.1:443: i/o timeout)</span></span><br></pre></td></tr></table></figure><p>What’s the fuuuuuuu!!!</p><p>必须说明我是在科学上网的前提下执行的安装命令，所以猜测不是网络问题，具体原因没深究，我参考了<a href="https://github.com/Microsoft/vscode-go/wiki/Go-tools-that-the-Go-extension-depends-on" target="_blank" rel="noopener">官方指导</a>以及<a href="http://www.pythonsite.com/?p=429" target="_blank" rel="noopener">一篇博文</a>解决的该问题，博客写得有点绕，我挑简单的总结一下。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>从官方文档中可以明确，VSCode依赖的几款工具完成不同功能：</p><table><thead><tr><th>名称</th><th>描述</th><th>链接</th></tr></thead><tbody><tr><td>gocode</td><td>代码自动补全</td><td><a href="https://github.com/mdempsky/gocode" target="_blank" rel="noopener">https://github.com/mdempsky/gocode</a></td></tr><tr><td>go-outline</td><td>在当前文件中查找</td><td><a href="https://github.com/ramya-rao-a/go-outline" target="_blank" rel="noopener">https://github.com/ramya-rao-a/go-outline</a></td></tr><tr><td>go-symbols</td><td>在项目路径下查找</td><td><a href="https://github.com/acroca/go-symbols" target="_blank" rel="noopener">https://github.com/acroca/go-symbols</a></td></tr><tr><td>gopkgs</td><td>自动补全未导入包</td><td><a href="https://github.com/uudashr/gopkgs" target="_blank" rel="noopener">https://github.com/uudashr/gopkgs</a></td></tr><tr><td>guru</td><td>查询所有引用</td><td><a href="https://golang.org/x/tools/cmd/guru" target="_blank" rel="noopener">https://golang.org/x/tools/cmd/guru</a></td></tr><tr><td>gorename</td><td>重命名符号</td><td><a href="https://golang.org/x/tools/cmd/gorename" target="_blank" rel="noopener">https://golang.org/x/tools/cmd/gorename</a></td></tr><tr><td>goreturns</td><td>格式化代码</td><td><a href="https://github.com/sqs/goreturns" target="_blank" rel="noopener">https://github.com/sqs/goreturns</a></td></tr><tr><td>godef</td><td>跳转到声明</td><td><a href="https://github.com/rogpeppe/godef" target="_blank" rel="noopener">https://github.com/rogpeppe/godef</a></td></tr><tr><td>godoc</td><td>鼠标悬浮时文档提示</td><td><a href="https://golang.org/x/tools/cmd/godoc" target="_blank" rel="noopener">https://golang.org/x/tools/cmd/godoc</a></td></tr><tr><td>golint</td><td>就是lint</td><td><a href="https://golang.org/x/lint/golint" target="_blank" rel="noopener">https://golang.org/x/lint/golint</a></td></tr><tr><td>dlv</td><td>调试功能</td><td><a href="https://github.com/derekparker/delve/tree/master/cmd/dlv" target="_blank" rel="noopener">https://github.com/derekparker/delve/tree/master/cmd/dlv</a></td></tr><tr><td>gomodifytags</td><td>修改结构体标签</td><td><a href="https://github.com/fatih/gomodifytags" target="_blank" rel="noopener">https://github.com/fatih/gomodifytags</a></td></tr><tr><td>goplay</td><td>运行当前go文件</td><td><a href="https://github.com/haya14busa/goplay/" target="_blank" rel="noopener">https://github.com/haya14busa/goplay/</a></td></tr><tr><td>impl</td><td>新建接口</td><td><a href="https://github.com/josharian/impl" target="_blank" rel="noopener">https://github.com/josharian/impl</a></td></tr><tr><td>gotype-live</td><td>类型诊断</td><td><a href="https://github.com/tylerb/gotype-live" target="_blank" rel="noopener">https://github.com/tylerb/gotype-live</a></td></tr><tr><td>gotests</td><td>单元测试</td><td><a href="https://github.com/cweill/gotests/" target="_blank" rel="noopener">https://github.com/cweill/gotests/</a></td></tr><tr><td>go-langserver</td><td>语言服务</td><td><a href="https://github.com/sourcegraph/go-langserver" target="_blank" rel="noopener">https://github.com/sourcegraph/go-langserver</a></td></tr><tr><td>filstruct</td><td>结构体成员默认值</td><td><a href="https://github.com/davidrjenni/reftools/tree/master/cmd/fillstruct" target="_blank" rel="noopener">https://github.com/davidrjenni/reftools/tree/master/cmd/fillstruct</a></td></tr></tbody></table><p>以上的工具可以有选择地安装，但为了开发过程中不要出什么岔子，我一般选择全部安装，很不幸的是安装过程中80%的工具会出现<code>timeout</code>的提示。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>为了统一每个人的开发环境，下文中<code>GOPATH</code>表示自己电脑go的安装路径，例如我的电脑默认安装路径为<code>~/go</code>，如果没有的话建议先执行命令<code>export GOPATH=~/go</code>，Windows用户…👋</p><ol><li>创建目录<code>$GOPATH/src/golang.org/x</code>，并切换到该目录</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$GOPATH</span>/src/golang.org/x/</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/golang.org/x/</span><br></pre></td></tr></table></figure><ol><li>克隆golang.org工具源码<br>如果不克隆的话，<code>go get -u -v golang.org/xxx</code>肯定是timeout的，所以只能先把它们下载到本地<code>src/golang.org/x/tools</code></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/golang/tools.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/lint.git</span><br></pre></td></tr></table></figure><ol><li>下载github源码<br>按照<code>go get -u -v</code>命令，从GitHub上下载代码后还会<code>fetch</code>，我们很可能会在<code>fetch https://golang.org/xxx</code>的时候挂掉，原因你懂的。所以去掉<code>-u</code>选项，禁止从网络更新现有代码。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先从github下载依赖工具的源码，fetch提示timeout不要管</span></span><br><span class="line">go get -v github.com/ramya-rao<span class="_">-a</span>/go-outline</span><br><span class="line">go get -v github.com/acroca/go-symbols</span><br><span class="line">go get -v github.com/mdempsky/gocode</span><br><span class="line">go get -v github.com/rogpeppe/godef</span><br><span class="line">go get -v github.com/zmb3/gogetdoc</span><br><span class="line">go get -v github.com/fatih/gomodifytags</span><br><span class="line">go get -v sourcegraph.com/sqs/goreturns  <span class="comment"># 无响应 但是确实下载下来了</span></span><br><span class="line">go get -v github.com/cweill/gotests/... <span class="comment"># 和上面一样</span></span><br><span class="line">go get -v github.com/josharian/impl</span><br><span class="line">go get -v github.com/haya14busa/goplay/cmd/goplay</span><br><span class="line">go get -v github.com/uudashr/gopkgs/cmd/gopkgs</span><br><span class="line">go get -v github.com/davidrjenni/reftools/cmd/fillstruct <span class="comment"># 响应慢但是可以下载成功</span></span><br><span class="line">go get -v github.com/alecthomas/gometalinter <span class="comment"># 巨慢 能下下来</span></span><br></pre></td></tr></table></figure><ol><li>安装工具</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有问题的地方先用find找到位置(和下面对应) 然后进入位置使用go get 之后再使用下面的命令安装 我淦-_-</span></span><br><span class="line">go install github.com/ramya-rao<span class="_">-a</span>/go-outline</span><br><span class="line">go install github.com/acroca/go-symbols</span><br><span class="line">go install github.com/mdempsky/gocode</span><br><span class="line">go install github.com/rogpeppe/godef</span><br><span class="line">go install github.com/zmb3/gogetdoc</span><br><span class="line">go install github.com/fatih/gomodifytags</span><br><span class="line">go install sourcegraph.com/sqs/goreturns <span class="comment"># 这个好像是需要在golang。org/x/下先下好在传上去</span></span><br><span class="line">go install github.com/cweill/gotests/... </span><br><span class="line"><span class="comment"># 有问题  包的路径选 ./src/github.com/cweill/gotests/gotests 再go get和go install</span></span><br><span class="line">go install github.com/josharian/impl</span><br><span class="line">go install github.com/haya14busa/goplay/cmd/goplay</span><br><span class="line">go install github.com/uudashr/gopkgs/cmd/gopkgs</span><br><span class="line">go install github.com/davidrjenni/reftools/cmd/fillstruct</span><br><span class="line">go install github.com/alecthomas/gometalinter</span><br><span class="line"><span class="variable">$GOPATH</span>/bin/gometalinter --install</span><br><span class="line">go install golang.org/x/tools/cmd/godoc <span class="comment"># 有问题 用上面方法可以解决</span></span><br><span class="line">go install golang.org/x/lint/golint</span><br><span class="line">go install golang.org/x/tools/cmd/gorename</span><br><span class="line">go install golang.org/x/tools/cmd/goimports <span class="comment"># 有问题  用上面方法可以解决</span></span><br><span class="line">go install golang.org/x/tools/cmd/guru <span class="comment"># 有问题  用上面方法可以解决</span></span><br></pre></td></tr></table></figure><ol><li>集成到系统环境中<br>由于我是在用户目录下临时安装的，真正的GO环境是<code>/usr/local/go</code>，所以最后一步无比注意，把<code>~/go/bin</code>下面生成的所有执行文件拷贝到系统环境中</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -af <span class="variable">$GOPATH</span>/bin/* /usr/<span class="built_in">local</span>/go/bin/</span><br></pre></td></tr></table></figure><p>打完收工！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
</search>
