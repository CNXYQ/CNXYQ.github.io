<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图解算法</title>
      <link href="/2020/06/17/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95/"/>
      <url>/2020/06/17/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jun 17 2020 12:07:19 GMT+0800 (GMT+08:00) --><h1 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h1><p><strong>一，第一章 算法简介</strong></p><p>1.2 二分查找<br>二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。使用二分查找时，每次都排除一半的数字。<br>一般而言，对于包含n个元素的列表，用二分查找最多需要<strong>log2n</strong>步，而简单查找最多需要<strong>n</strong>步。仅当列表是有序的时候，二分查找才管用。<br>二分法代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list)—<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high: <span class="comment">#只要范围没有缩小到只包含一个元素，就检查中间的元素</span></span><br><span class="line">        mid = (low + high)</span><br><span class="line">        guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == item:  <span class="comment">#找到了元素</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:  <span class="comment">#猜的数字大了</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:            <span class="comment">#猜的数字小了</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>   <span class="comment">#没有指定的元素</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">3</span>)  <span class="comment"># =&gt; 1</span></span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">-1</span>)  <span class="comment"># =&gt; None</span></span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><p>1.2.2 运行时间<br>二分查找的运行时间为对数时间（或log时间）。简单查找的运行时间为线性时间。</p><p>1.3 大 O表示法<br>算法的运行时间以不同的速度增加。<br>大O表示法指出了算法有多快，大O表示法指的并非以秒为单位的速度。 大O表示法让你能够比较操作数，它指出了算法运行时间的增速。二分查找需要执行log n次操作，使用大O表示法，O(log n)。简单查找的运行时间为O(n)。大O表示法说的是最糟的情形。</p><p>1.3.4 一些常见的大 O 运行时间（“阶指幂对”）<br>O(log n)，也叫对数时间，这样的算法包括二分查找。<br>O(n)，也叫线性时间，这样的算法包括简单查找。<br>O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。<br>O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。<br>O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</p><blockquote><p>小结：<br>\1. 算法的速度指的并非时间，而是操作数的增速。谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。<br>\2. 算法的运行时间用大O表示法表示。 O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。 算法运行时间并不以秒为单位。<br>\3. 算法运行时间是从其增速的角度度量的。</p></blockquote><p><strong>二，第二章 选择排序</strong></p><p>2.1 内存的工作原理<br>计算机就像是很多抽屉的集合体，每个抽屉都有地址。<br>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——<strong>数组和链表</strong>。<br>2.2 数组和链表<br>使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。<br>需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。<br>需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。<br>2.2.3 术语<br>元素的位置称为索引。<br><img src="https://img-blog.csdn.net/20180702203705464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>2.2.4 在中间插入<br>需要在中间插入元素时，数组和链表哪个更好呢？使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。</p><p>2.3 选择排序<br>需要的总时间为 O(n × n)，即O(n2)。<br>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSmallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ar</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    newArr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        smallest = findSmallest(arr)</span><br><span class="line">        newArr.append(arr.pop(smallest))</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line"><span class="keyword">print</span> selectionSort([<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>])</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><p><strong>第三章 递归</strong></p><p>3.2 基线条件和递归条件<br>编写递归函数时，必须告诉它何时停止递归。正因为如此， 每个递归函数都有两部分：基线条件（ base case）和递归条件（ recursive case） 。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">0</span>:   <span class="comment">#基线条件</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:    <span class="comment">#递归条件</span></span><br><span class="line">        countdown(i<span class="number">-1</span>)</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>3.3 栈<br>栈是一种简单的数据结构，栈有两种操作：压入（插入）和弹出（删除并读取）。<br>每当调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。这个栈用于存储多个函数的变量，被称为调用栈。 调用栈可能很长，这将占用大量的内存。所有函数调用都进入调用栈。</p><p><strong>第四章 快速排序</strong></p><p>4.1 分而治之<br>D&amp;C算法包括两个步骤：<br>(1) 找出基线条件，这种条件必须尽可能简单。<br>(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。<br>D&amp;C的工作原理：<br>(1) 找出简单的基线条件；<br>(2) 确定如何缩小问题的规模，使其符合基线条件。</p><p>快速排序的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"><span class="keyword">print</span> quicksort([<span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>4.3 再谈大 O 表示法<br>快速排序的独特之处在于，其速度取决于选择的基准值。选择排序，其运行时间为O(n2)，速度非常慢。<br><img src="https://img-blog.csdn.net/20180703205638308?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>合并排序（ merge sort） 的排序算法，其运行时间为O(n log n)。比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。<br>4.4 小结<br>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。<br>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。<br>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， O(log n)的速度比O(n)快得多。</p><p><strong>第五章 散列表</strong></p><p>运行时间O(n)和O(log n)之间有天壤之别！</p><ol><li>散列函数总是将同样的输入映射到相同的索引。</li><li>散列函数将不同的输入映射到不同的索引。</li><li>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。</li></ol><p>散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。</p><p>5.2.3 将散列表用作缓存<br>缓存的工作原理：网站将数据记住，而不再重新计算。<br>缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！</p><blockquote><p>散列表适合用于：</p><ol><li>模拟映射关系；</li><li>防止重复；</li><li>缓存/记住数据，以免服务器再通过处理来生成它们。</li></ol></blockquote><p>5.3 冲突<br>冲突（ collision） ：给两个键分配的位置相同。<br>处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。<br>散列函数很重要，好的散列函数很少导致冲突。</p><p>5.4 性能<br>在平均情况下，散列表执行各种操作的时间都为O(1)。 O(1)被称为常量时间。简单查找的运行时间为线性时间。二分查找的速度更快，所需时间为对数时间。在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。<br>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。<br>因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：<br> 较低的填装因子；<br> 良好的散列函数。</p><p><strong>第六章 广度优先搜索（ breadth-first search， BFS）</strong></p><p>广度优先搜索让你能够找出两样东西之间的最短距离，广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。<br>第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？）<br>第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？）<br>使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。<br><strong>广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。</strong></p><p>6.3.2 队列<br>队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作： 入队和出队。<br><strong>队列是一种先进先出（ First In First Out， FIFO）的数据结构，而栈是一种后进先出（ Last InFirst Out， LIFO）的数据结构。</strong><br>运行时间<br>如果你在你的整个人际关系网中搜索芒果销售商，就意味着你将沿每条边前行（记住，边是从一个人到另一个人的箭头或连接），因此运行时间至少为O(边数)。<br>你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（ vertice）数， E为边数。<br>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。</p><p><strong>第七章 狄克斯特拉算法</strong></p><p>应用场景：路由协议选路<br>广度优先搜索，它找出的是段数最少的路径，狄克斯特拉算法（ Dijkstra’s algorithm）找的是最快的路径。广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是段数最少。<strong>在狄克斯特拉算法中，你给每段都分配了一个数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。</strong><br>狄克斯特拉算法包含4个步骤。<br>(1) 找出“代价最低”的节点，即可在最短时间内到达的节点。<br>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。<br>(3) 重复这个过程，直到对图中的每个节点都这样做了。<br>(4) 计算最终路径。<br>带权重的图称为加权图（ weighted graph），不带权重的图称为非加权图（unweighted graph）。<br>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。<strong>狄克斯特拉算法只适用于有向无环图</strong>。<br>最短路径指的并不一定是物理距离，也可能是让某种度量指标最小。如果有负权边，就不能使用狄克斯特拉算法。因为负权边会导致这种算法不管用。</p><blockquote><p>7.6 小结</p><ol><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径。</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ol></blockquote><p><strong>第八章 贪婪算法</strong></p><p>贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。<br>8.2 背包问题<br>在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。<br>背包问题就是有若干物品，每个物品有自己的价值和重量。背包有总重量。问题就是怎样将背包装的最大价值。背包问题也分很多种，贪心算法解决的是物品可以拆分的背包问题（就是物品可以分成几份装入）。这个问题用贪心还是比较好解决的。贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。此问题就是将每次的放入看成每一步，要想解决问题，就是将每一步都放入最优解。也就是说，每一次的放入都要放入最佳的选择。讲到这里，就要说一说最佳的选择，每一次的放入的最佳的选择就是每次放入的物品都是剩余的物品中价值最大且质量最小的，这里就要引入一个物品的属性，物品的权重值。物品的权重值就是指物品的价值除以物品的质量。所以，本问题的每一次的最佳选择就是每次都选出权重值最大的物品。<br>近似算法<br>在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：<br> 速度有多快；<br> 得到的近似解与最优解的接近程度。</p><p>8.4 NP 完全问题(Non-deterministic Polynomial多项式的不确定性)<br>NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。<br>如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。</p><p> 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。<br> 涉及“所有组合”的问题通常是NP完全问题。<br> 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。<br> 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。<br> 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。<br> 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</p><blockquote><p>8.5 小结</p><ol><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。</li><li>对于NP完全问题，还没有找到快速解决方案。</li><li>面临NP完全问题时，最佳的做法是使用近似算法。</li><li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li></ol></blockquote><p>9.1.2 动态规划<br>动态规划先解决子问题，再逐步解决大问题。<br>对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。<br>每个动态规划算法都从一个网格开始，网格的各行为商品，各列为不同容量（ 1～4磅）的背包。所有这些列你都需要，因为它们将帮助你计算子背包的价值。<br>动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。 但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。</p><blockquote><ol><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。</li><li>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。要设计出动态规划解决方案可能很难，这正是本节要介绍的。下面是一些通用的小贴士。</li><li>每种动态规划解决方案都涉及网格。</li></ol></blockquote><p>9.3.1 绘制网格<br>对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。</p><blockquote><p>9.4 小结</p><ol><li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li><li>问题可分解为离散子问题时，可使用动态规划来解决。</li><li>每种动态规划解决方案都涉及网格。</li><li>单元格中的值通常就是你要优化的值。</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li><li>没有放之四海皆准的计算动态规划解决方案的公式。</li></ol></blockquote><p><strong>第十章 K最近邻算法</strong></p><p>KNN可以用来做两项基本工作——分类和回归：</p><ol><li>分类就是编组；</li><li>回归就是预测结果（如一个数字）。</li></ol><p><strong>余弦相似度（ cosine similarity）</strong><br>余弦相似度不计算两个矢量的距离，而比较它们的角度。<br>余弦相似度。余弦相似度被广泛用于协同过滤算法中，尤其是Item-base的协同过滤。<br>余弦相似度衡量的是两个向量间的夹角大小，通过夹角的余弦值表示结果，假设A向量是（x1, y1），B向量是(x2, y2)，那么两个向量的余弦相似度为：</p><p>分子为向量A与向量B的点乘，分母为二者各自的L2相乘，即将所有维度值的平方相加后开方。 余弦相似度的取值为[-1,1]，值越大表示越相似。</p><p>10.3.1 OCR<br>OCR指的是光学字符识别（ optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。 一般而言， OCR算法提取线段、点和曲线等特征。<br>OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（ training）。大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。</p><p>10.3.2 创建垃圾邮件过滤器<br>垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（ Naive Bayes classifier）。</p><blockquote><p>10.4 小结</p><ol><li>KNN用于分类和回归，需要考虑最近的邻居。</li><li>分类就是编组。</li><li>回归就是预测结果（如数字）。</li><li>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。</li><li>能否挑选合适的特征事关KNN算法的成败。</li></ol></blockquote><p><strong>第十一章 接下来如何做</strong></p><p>二叉查找树（ binary search tree）<br>在二叉查找树中查找节点时，平均运行时间为O(log n)，但在最糟的情况下所需时间为O(n)；而在有序数组中查找时，即便是在最糟情况下所需的时间也只有O(log n)，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。<br><img src="https://img-blog.csdn.net/2018070419575199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>二叉查找树也存在一些缺点，例如，不能随机访问，在二叉查找树处于平衡状态时，平均访问时间也为O(log n)。</p><p>11.2 反向索引<br>一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（ inverted index），常用于创建搜索引擎。</p><p>11.4 并行算法<br>并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。<br>并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。<br>负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易， 10秒钟就完成了，而分配给内核B的任务都很难， 1分钟才完成。这意味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？</p><p>11.5 MapReduce<br>MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（ map）函数和归并（ reduce）函数。<br>11.5.2 映射函数<br>映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。<br>11.5.3 归并函数<br>归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。<br>MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。<br>11.6 布隆过滤器和 HyperLogLog<br>布隆过滤器是一种概率型数据结构，布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况，前面所有的示例都是这样的。<br>HyperLogLog是一种类似于布隆过滤器的算法。<br>HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。<br>面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！</p><p>11.7 SHA 算法<br>另一种散列函数是安全散列算法（ secure hash algorithm， SHA）函数。给定一个字符串， SHA返回其散列值。<br>SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。对于每个不同的字符串， SHA生成的散列值都不同。<br>你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。</p><p><strong>斐波那契数列</strong><br>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p><p>递归方式实现斐波那契数列 前n项:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归方式实现 生成前20项</span></span><br><span class="line">lis =[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">0</span> <span class="keyword">or</span> i ==<span class="number">1</span>:<span class="comment">#第1,2项 都为1</span></span><br><span class="line">        lis.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lis.append(lis[i<span class="number">-2</span>]+lis[i<span class="number">-1</span>])<span class="comment">#从第3项开始每项值为前两项值之和</span></span><br><span class="line">print(lis)<span class="number">12345678</span></span><br><span class="line"> <span class="comment">#递归函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_function_tool</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Fibonacci_function_tool(n - <span class="number">1</span>) + Fibonacci_function_tool(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_function</span><span class="params">(n)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>): result_list.append(Fibonacci_function_tool(i))</span><br><span class="line">    <span class="keyword">return</span> result_list1234567891011121314</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python中的is 和 == 你真的搞对对象了吗？</title>
      <link href="/2020/06/09/Python%E7%9A%84%20is%20%E5%92%8C%20==%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>/2020/06/09/Python%E7%9A%84%20is%20%E5%92%8C%20==%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jun 16 2020 16:34:55 GMT+0800 (GMT+08:00) --><p>首先我先放一张简单总结的图</p><p><img src="https://wx2.sbimg.cn/2020/06/09/image-20200608161408086.png" alt="image-20200608161408086"></p><p>下面是我做的一个题目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已知x &#x3D; [[]]*3 执行语句x[0].append(1)后x的值为_____  #[[1],[1],[1]]</span><br><span class="line">已知x &#x3D; [[] for in i range(3)] 执行语句x[0].append(1)后x的值为_____  # [[1],[],[]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;b&#x3D;[[]]*3</span><br><span class="line">&gt;&gt;&gt;b</span><br><span class="line">[[], [], []]</span><br><span class="line">&gt;&gt;&gt;[id(b[i]) for i in range(3)]#查看地址</span><br><span class="line">[2637926546248, 2637926546248, 2637926546248]</span><br><span class="line">&gt;&gt;&gt;a &#x3D; [[] for i in range(3)]</span><br><span class="line">&gt;&gt;&gt;[id(a[i]) for i in range(3)]#查看地址</span><br><span class="line">[2637624332232, 2637909035016, 2637926538824]</span><br></pre></td></tr></table></figure><h3 id="下面开始正文，在Python中一切都是对象"><a href="#下面开始正文，在Python中一切都是对象" class="headerlink" title="下面开始正文，在Python中一切都是对象"></a>下面开始正文，在Python中一切都是对象</h3><p>Python中对象包含的三个基本要素，分别是：</p><ul><li>id(身份标识)</li><li>type(数据类型)</li><li>value(值)</li></ul><p>对象之间比较是否相等可以用 == ，也可以用 is 。</p><p>is 和 == 都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。下面来看看具体区别在哪?</p><p>is 比较的是两个对象的id值是否相等，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址。</p><p>== 比较的是两个对象的内容是否相等，默认会调用对象的 <code>__eq__</code> 方法。</p><p>== 是python标准操作符中的比较操作符，用来比较判断两个对象的值是否相等。</p><p>先来看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br><span class="line">&gt;&gt;&gt; b is a </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b &#x3D;&#x3D; a</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a[:]</span><br><span class="line">&gt;&gt;&gt; b is a</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; b &#x3D;&#x3D; a</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>is 也被叫做同一性运算符，也就是id是否相同。</p><p>看下面代码， a和b变量的id不同， 所以 b == a 是True， b is a 是False.</p><p>再来看一下他们的id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4364243328</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4364202696</span><br></pre></td></tr></table></figure><p>哪些情况下 is 和 == 结果是完全相同的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 256</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 256</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a &#x3D; 1000</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 10**3</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>所以数字类型不完全相同。</p><p>那为什么256时相同， 而1000时不同呢？</p><p>因为出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫 small_ints 的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。</p><p>Python把这些可能频繁使用的整数对象规定在范围 [-5, 256] 之间的小对象放在 small_ints 中，但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c &#x3D; &#39;miracle.young&#39;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &#39;miracle.young&#39;</span><br><span class="line">&gt;&gt;&gt; c is d</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; c &#x3D;&#x3D; d</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D; &#39;miracleyoung&#39;</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &#39;miracleyoung&#39;</span><br><span class="line">&gt;&gt;&gt; c is c</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c &#x3D;&#x3D; d</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>所以字符串类型不完全相同，这个和解释器实现有关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; (1,2,3) # a和b为元组类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; (1,2,3)</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1,2,3] # a和b为list类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; &#123;&#39;miracle&#39;:100,&#39;young&#39;:1&#125; # a和b为dict类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#123;&#39;miracle&#39;:100,&#39;young&#39;:1&#125;</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a &#x3D; set([1,2,3]) # a和b为set类型</span><br><span class="line">&gt;&gt;&gt; b &#x3D; set([1,2,3])</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>所以当变量是数字、字符串、元组，列表，字典时，is 和 == 都不相同， 不能互换使用！当比较值时，要使用 ==，比较是否是同一个内存地址时应该使用is。</p><p>当然，开发中比较值的情况比较多。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中深拷贝和浅拷贝</title>
      <link href="/2020/06/09/%E8%B0%88%E8%B0%88python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/06/09/%E8%B0%88%E8%B0%88python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jun 16 2020 16:34:55 GMT+0800 (GMT+08:00) --><h1 id="Python中深拷贝和浅拷贝"><a href="#Python中深拷贝和浅拷贝" class="headerlink" title="Python中深拷贝和浅拷贝"></a>Python中深拷贝和浅拷贝</h1><p>python中深拷贝和浅拷贝的知识这里进行下总结，以便今后复习<br><code>python</code>中的深拷贝和浅拷贝和<code>java</code>里面的概念是一样的，所谓浅拷贝就是对引用的拷贝，所谓深拷贝就是对对象的资源的拷贝。<br>首先，对<strong>赋值</strong>操作我们要有以下认识：</p><ol><li>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址（ 旧瓶装旧酒 ）。</li><li>修改不可变对象（<code>str</code>、<code>tuple</code>）需要开辟新的空间</li><li>修改可变对象（<code>list</code>等）不需要开辟新的空间</li></ol><ul><li><strong>浅拷贝</strong>仅仅复制了容器中元素的地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">'hello'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">6444104</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">6444104</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="string">'world'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">[<span class="string">'hello'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>这里可以看出，未修改前，<code>a</code>和<code>b</code>中元素的地址都是相同的，不可变的<code>hello</code><br>和可变的<code>list</code>地址都一样，说明浅拷贝知识将容器内的元素的地址复制了一份。这可以通过修改后，<code>b</code>中字符串没改变，但是<code>list</code>元素随着<code>a</code>相应改变得到验证。</p><blockquote><p>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。</p></blockquote><ul><li><strong>深拷贝</strong>，完全拷贝了一个副本，容器内部元素地址都不一样</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">'hello'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">55645000</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">55792504</span>, <span class="number">58338824</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="string">'world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="string">'world'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">[<span class="string">'hello'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>这里可以看出，深拷贝后，<code>a</code>和<code>b</code>的地址以及<code>a</code>和<code>b</code>中的元素地址均不同，这是完全拷贝的一个副本，修改<code>a</code>后，发现<code>b</code>没有发生任何改变，因为<code>b</code>是一个完全的副本，元素地址与<code>a</code>均不同，<code>a</code>修改不影响<code>b</code>。</p><blockquote><p>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说（ 新瓶装新酒 ）。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stay hungry. Stay Foolish.</title>
      <link href="/2020/03/18/Stay-hungry-Stay-Foolish/"/>
      <url>/2020/03/18/Stay-hungry-Stay-Foolish/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jun 16 2020 16:34:55 GMT+0800 (GMT+08:00) --><div id="article_content" class="article_content clearfix"><link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css"><div id="content_views" class="markdown_views prism-atom-one-light"><svg xmlns="http://www.w3.org/2000/svg" style="display:none"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color:transparent"/></svg><p>Thank you. I am honored to be with you today at your commencement from one of the finest universities in the world. Truth be told, I never graduated from college. This is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.</p><p>很荣幸和大家一道参加这所世界上最好的一座大学的毕业典礼。我大学没毕业，说实话，这是我第一次离大学毕业典礼这么近。今天我想给大家讲三个我自己的故事，不讲别的，也不讲大道理，就讲三个故事。</p><p>The first story is about connecting the dots. I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?</p><p>第一个故事讲的是点与点之间的关系。我在里德学院(Reed College)只读了六个月就退学了，此后便在学校里旁听，又过了大约一年半，我彻底离开。那么，我为什么退学呢?</p><p>It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife.</p><p>这得从我出生前讲起。我的生母是一名年轻的未婚在校研究生，她决定将我送给别人收养。她非常希望收养我的是有大学学历的人，所以把一切都安排好了，我一出生就交给一对律师夫妇收养。</p><p>Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.”</p><p>没想到我落地的霎那间，那对夫妇却决定收养一名女孩。就这样，我的养父母─当时他们还在登记册上排队等着呢─半夜三更接到一个电话: “我们这儿有一个没人要的男婴，你们要么?”“当然要”他们回答。</p><p>My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.</p><p>但是，我的生母后来发现我的养母不是大学毕业生，我的养父甚至连中学都没有毕业，所以她拒绝在最后的收养文件上签字。不过，没过几个月她就心软了，因为我的养父母许诺日后一定送我上大学。</p><p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition.</p><p>17 年后，我真的进了大学。当时我很天真，选了一所学费几乎和斯坦福大学一样昂贵的学校，当工人的养父母倾其所有的积蓄为我支付了大学学费。</p><p>After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life.</p><p>读了六个月后，我却看不出上学有什么意义。我既不知道自己这一生想干什么，也不知道大学是否能够帮我弄明白自己想干什么。这时，我就要花光父母一辈子节省下来的钱了。</p><p>So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting。</p><p>所以，我决定退学，并且坚信日后会证明我这样做是对的。当年做出这个决定时心里直打鼓，但现在回想起来，这还真是我有生以来做出的最好的决定之一。从退学那一刻起，我就可以不再选那些我毫无兴趣的必修课，开始旁听一些看上去有意思的课。</p><p>It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5? deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p><p>那些日子一点儿都不浪漫。我没有宿舍，只能睡在朋友房间的地板上。我去退还可乐瓶，用那五分钱的押金来买吃的。每个星期天晚上我都要走七英里，到城那头的黑尔-科里施纳礼拜堂去，吃每周才能享用一次的美餐。我喜欢这样。我凭著好奇心和直觉所干的这些事情，有许多后来都证明是无价之宝。我给大家举个例子:</p><p>Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.</p><p>当时，里德学院的书法课大概是全国最好的。校园里所有的公告栏和每个抽屉标签上的字都写得非常漂亮。当时我已经退学，不用正常上课，所以我决定选一门书法课，学学怎么写好字。</p><p>I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.</p><p>我学习写带短截线和不带短截线的印刷字体，根据不同字母组合调整其间距，以及怎样把版式调整得好上加好。这门课太棒了，既有历史价值，又有艺术造诣，这一点科学就做不到，而我觉得它妙不可言。</p><p>None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac.</p><p>当时我并不指望书法在以后的生活中能有什么实用价值。但是，十年之后，我们在设计第一台 Macintosh 计算机时，它一下子浮现在我眼前。于是，我们把这些东西全都设计进了计算机中。</p><p>It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, its likely that no personal computer would have them.</p><p>这是第一台有这么漂亮的文字版式的计算机。要不是我当初在大学里偶然选了这么一门课，Macintosh 计算机绝不会有那么多种印刷字体或间距安排合理的字号。要不是 Windows 照搬了 Macintosh，个人电脑可能不会有这些字体和字号。</p><p>If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.</p><p>要不是退了学，我决不会碰巧选了这门书法课，个人电脑也可能不会有现在这些漂亮的版式了。当然，我在大学里不可能从这一点上看到它与将来的关系。十年之后再回头看，两者之间的关系就非常、非常清楚了。</p><p>Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something — your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.</p><p>你们同样不可能从现在这个点上看到将来；只有回头看时，才会发现它们之间的关系。所以，要相信这些点迟早会连接到一起。你们必须信赖某些东西─直觉、归宿、生命，还有业力，等等。这样做从来没有让我的希望落空过，而且还彻底改变了我的生活。</p><p>My second story is about love and loss. I was lucky — I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees.</p><p>我的第二个故事是关于好恶与得失。幸运的是，我在很小的时候就发现自己喜欢做什么。我在 20 岁时和沃兹在我父母的车库里办起了苹果公司。我们干得很卖力，十年后，苹果公司就从车库里我们两个人发展成为一个拥有 20 亿元资产、4,000 名员工的大企业。</p><p>We had just released our finest creation — the Macintosh — a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well.</p><p>那时，我们刚刚推出了我们最好的产品─ Macintosh 电脑─那是在第 9 年，我刚满 30 岁。可后来，我被解雇了。你怎么会被自己办的公司解雇呢?是这样，随著苹果公司越做越大，我们聘了一位我认为非常有才华的人与我一道管理公司。在开始的一年多里，一切都很顺利。</p><p>But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.</p><p>可是，随后我俩对公司前景的看法开始出现分歧，最后我俩反目了。这时，董事会站在了他那一边，所以在 30 岁那年，我离开了公司，而且这件事闹得满城风雨。我成年后的整个生活重心都没有了，这使我心力交瘁。</p><p>I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley.</p><p>一连几个月，我真的不知道应该怎么办。我感到自己给老一代的创业者丢了脸─因为我扔掉了交到自己手里的接力棒。我去见了戴维帕卡德和鲍勃.诺伊斯，想为把事情搞得这么糟糕说声道歉。这次失败弄得沸沸扬扬的，我甚至想过逃离硅谷。</p><p>But something slowly began to dawn on me — I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.</p><p>但是，渐渐地，我开始有了一个想法─我仍然热爱我过去做的一切。在苹果公司发生的这些风波丝毫没有改变这一点。我虽然被拒之门外，但我仍然深爱我的事业。于是，我决定从头开始。</p><p>I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.</p><p>虽然当时我并没有意识到，但事实证明，被苹果公司炒鱿鱼是我一生中碰到的最好的事情。尽管前景未卜，但从头开始的轻松感取代了保持成功的沉重感。这使我进入了一生中最富有创造力的时期之一。</p><p>During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.</p><p>在此后的五年里，我开了一家名叫 NeXT 的公司和一家叫皮克斯的公司，我还爱上一位了不起的女人，后来娶了她。皮克斯公司推出了世界上第一部用电脑制作的动画片《玩具总动员》(Toy Story)，它现在是全球最成功的动画制作室。</p><p>In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.</p><p>世道轮回，苹果公司买下 NeXT 后，我又回到了苹果公司，我们在 NeXT 公司开发的技术成了苹果公司这次重新崛起的核心。我和劳伦娜(Laurene)也建立了美满的家庭。</p><p>I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did.</p><p>我确信，如果不是被苹果公司解雇，这一切决不可能发生。这是一剂苦药，可我认为苦药利于病。有时生活会当头给你一棒，但不要灰心。我坚信让我一往无前的唯一力量就是我热爱我所做的一切。</p><p>You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do.</p><p>所以，一定得知道自己喜欢什么，选择爱人时如此，选择工作时同样如此。工作将是生活中的一大部分，让自己真正满意的唯一办法，是做自己认为是有意义的工作;做有意义的工作的唯一办法，是热爱自己的工作。</p><p>If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.</p><p>你们如果还没有发现自己喜欢什么，那就不断地去寻找，不要急于做出决定。就像一切要凭着感觉去做的事情一样，一旦找到了自己喜欢的事，感觉就会告诉你。就像任何一种美妙的东西，历久弥新。所以说，要不断地寻找，直到找到自己喜欢的东西。不要半途而废。</p><p>My third story is about death. When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something.</p><p>我的第三个故事与死亡有关。17 岁那年，我读到过这样一段话，大意是:“如果把每一天都当作生命的最后一天，总有一天你会如愿以偿。”我记住了这句话，从那时起，33 年过去了，我每天早晨都对着镜子自问: “假如今天是生命的最后一天，我还会去做今天要做的事吗?”如果一连许多天我的回答都是“不”，我知道自己应该有所改变了。</p><p>Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything — all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.</p><p>让我能够做出人生重大抉择的最主要办法是，记住生命随时都有可能结束。因为几乎所有的东西─所有对自身之外的希求、所有的尊严、所有对困窘和失败的恐惧─在死亡来临时都将不复存在，只剩下真正重要的东西。记住自己随时都会死去，这是我所知道的防止患得患失的最好方法。你已经一无所有了，还有什么理由不跟着自己的感觉走呢。</p><p>About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months.</p><p>大约一年前，我被诊断患了癌症。那天早上七点半，我做了一次扫描检查，结果清楚地表明我的胰腺上长了一个瘤子，可那时我连胰腺是什么还不知道呢!医生告诉我说，几乎可以确诊这是一种无法治愈的恶性肿瘤，我最多还能活 3 到 6 个月。</p><p>My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.</p><p>医生建议我回去把一切都安排好，其实这是在暗示“准备后事”。也就是说，把今后十年要跟孩子们说的事情在这几个月内嘱咐完;也就是说，把一切都安排妥当，尽可能不给家人留麻烦；也就是说，去跟大家诀别。</p><p>I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now.</p><p>那一整天里，我的脑子一直没离开这个诊断。到了晚上，我做了一次组织切片检查，他们把一个内窥镜通过喉咙穿过我的胃进入肠子，用针头在胰腺的瘤子上取了一些细胞组织。当时我用了麻醉剂，陪在一旁的妻子后来告诉我，医生在显微镜里看了细胞之后叫了起来，原来这是一种少见的可以通过外科手术治愈的恶性肿瘤。我做了手术，现在好了。</p><p>This was the closest I’ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share.</p><p>这是我和死神离得最近的一次，我希望也是今后几十年里最近的一次。有了这次经历之后，现在我可以更加实在地和你们谈论死亡，而不是纯粹纸上谈兵，那就是: 谁都不愿意死。就是那些想进天堂的人也不愿意死后再进。然而，死亡是我们共同的归宿，没人能摆脱。</p><p>No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.</p><p>我们注定会死，因为死亡很可能是生命最好的一项发明。它推进生命的变迁，旧的不去，新的不来。现在，你们就是新的，但在不久的将来，你们也会逐渐成为旧的，也会被淘汰。对不起，话说得太过分了，不过这是千真万确的。</p><p>Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.</p><p>你们的时间都有限，所以不要按照别人的意愿去活，这是浪费时间。不要囿于成见，那是在按照别人设想的结果而活。不要让别人观点的聒噪声淹没自己的心声。最主要的是，要有跟着自己感觉和直觉走的勇气。无论如何，感觉和直觉早就知道你到底想成为什么样的人，其他都是次要的。</p><p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch.</p><p>我年轻时有一本非常好的刊物，叫《全球概览》，这是我那代人的宝书之一，创办人名叫斯图尔特布兰德，就住在离这儿不远的门洛帕克市。他用诗一般的语言把刊物办得生动活泼。</p><p>This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.</p><p>那是 20 世纪 60 年代末，还没有个人电脑和桌面印刷系统，全靠打字机、剪刀和宝丽莱照相机。它就像一种纸质的 Google，却比 Google 早问世了 35 年。这份刊物太完美了，查阅手段齐备、构思不凡。</p><p>Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age.</p><p>斯图尔特和他的同事们出了好几期《全球概览》，到最后办不下去时，他们出了最后一期。那是 20 世纪 70 年代中期，我也就是你们现在的年纪。</p><p>On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself.</p><p>最后一期的封底上是一张清晨乡间小路的照片，就是那种爱冒险的人等在那儿搭便车的那种小路。照片下面写道: 求知若饥、虚心若愚。那是他们停刊前的告别语。求知若渴，大智若愚。这也是我一直想做到的。</p><p>And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish.</p><p>眼下正值诸位大学毕业、开始新生活之际，我同样愿大家：求知若饥、虚心若愚。</p><p><img src="https://img-blog.csdnimg.cn/20190922204331298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></div></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> TED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TED </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python列表生成式</title>
      <link href="/2020/03/05/python%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/"/>
      <url>/2020/03/05/python%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jun 16 2020 16:34:55 GMT+0800 (GMT+08:00) --><h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>举个例子，要生成list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>可以用<code>list(range(1, 11))</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>但如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>   L.append(x * x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure><p>三层和三层以上的循环就很少用到了。</p><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></span><br><span class="line">[<span class="string">'.emacs.d'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'Adlm'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, <span class="string">'Documents'</span>, <span class="string">'Downloads'</span>, <span class="string">'Library'</span>, <span class="string">'Movies'</span>, <span class="string">'Music'</span>, <span class="string">'Pictures'</span>, <span class="string">'Public'</span>, <span class="string">'VirtualBox VMs'</span>, <span class="string">'Workspace'</span>, <span class="string">'XCode'</span>]</span><br></pre></td></tr></table></figure><p><code>for</code>循环其实可以同时使用两个甚至多个变量，比如<code>dict</code>的<code>items()</code>可以同时迭代key和value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span>    print(k, <span class="string">'='</span>, v)</span><br><span class="line">...</span><br><span class="line">y = B</span><br><span class="line">x = A</span><br><span class="line">z = C</span><br></pre></td></tr></table></figure><p>因此，列表生成式也可以使用两个变量来生成list：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br></pre></td></tr></table></figure><p>最后把一个list中所有的字符串变成小写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</span><br></pre></td></tr></table></figure><h3 id="if-…-else"><a href="#if-…-else" class="headerlink" title="if … else"></a>if … else</h3><p>使用列表生成式的时候，有些童鞋经常搞不清楚<code>if...else</code>的用法。</p><p>例如，以下代码正常输出偶数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>但是，我们不能在最后的<code>if</code>加上<code>else</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">                                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这是因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code>，否则如何筛选？</p><p>另一些童鞋发现把<code>if</code>写在<code>for</code>前面必须加<code>else</code>，否则报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">                       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这是因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">-7</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>上述<code>for</code>前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。</p><p>可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传大文件或者PDF或者二进制文件无法上传</title>
      <link href="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/"/>
      <url>/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jun 16 2020 16:34:55 GMT+0800 (GMT+08:00) --><p><span style="color:red;background:#fff;font-size:15;font-family:字体">提醒：git commit –hard commit_id 会把commit对应的文件从本地库删除！谨慎使用此命令！</span></p><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>​ push大文件失败，在将大文件删除之后，其余小文件仍然受到之前大文件push失败的影响，无法正常push。</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><p>​ 需要将之前含有大文件的commit记录删除（全部删除）</p><h2 id="3-详细过程"><a href="#3-详细过程" class="headerlink" title="3. 详细过程"></a>3. 详细过程</h2><ol><li><p>将git切换到之前提交的git项目所在目录</p></li><li><p>使用<code>git log</code>命令查看commit的历史记录及其对应的commit_id，查看结果如图：</p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/1.JPG" alt="1.JPG"></p></li><li><p>复制commit_id，使用Ctrl+C退出log查看页面，进入正常git可输入命令界面，输入下面命令，使git回退到commit_id的状态。 <code>git reset --hard //前面3个单词不需改变，将改成对应的commit_id的值</code></p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/2.JPG" alt="2.JPG"></p></li><li><p>使用下列命令使本地和远程的内容都回退到commit_id对应的状态。 <code>git push origin HEAD --force //固定模式，不需要改变单词</code></p><p><img src="/2020/03/04/git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85PDF%E6%88%96%E8%80%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0/3.JPG" alt="3.JPG"></p></li></ol><h2 id="4-参数解释"><a href="#4-参数解释" class="headerlink" title="4. 参数解释"></a>4. 参数解释</h2><p>根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:</p><ul><li><p>git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息。</p></li><li><p>git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可。</p></li><li><p>git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容。</p></li><li><p>git status :查看未被传送到远程代码库的提交状态</p></li><li><p>git cherry -v 查看未被传送到远程代码库的提交描述和说明</p></li><li><p>git reset commit_id 撤销未被传送到远程代码库的提交</p></li><li><p>HEAD 最近一个提交</p></li><li><p>HEAD^ 上一次提交</p></li><li><p>每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到。</p></li></ul><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.douban.com/note/189603387/" target="_blank" rel="noopener">git 删除错误提交的commit</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学生管理系统</title>
      <link href="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jun 16 2020 16:34:55 GMT+0800 (GMT+08:00) --><h1 id="学生管理系统"><a href="#学生管理系统" class="headerlink" title="学生管理系统"></a>学生管理系统</h1><h2 id="（第1阶段）学生信息管理系统部分截图"><a href="#（第1阶段）学生信息管理系统部分截图" class="headerlink" title="（第1阶段）学生信息管理系统部分截图"></a>（第1阶段）学生信息管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1-1.JPG" alt="1-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1-2.JPG" alt="1-2.JPG"></p><h2 id="（第2阶段）学生选课管理系统部分截图"><a href="#（第2阶段）学生选课管理系统部分截图" class="headerlink" title="（第2阶段）学生选课管理系统部分截图"></a>（第2阶段）学生选课管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-1.JPG" alt="2-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-2.JPG" alt="2-2.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-3.JPG" alt="2-3.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-4.JPG" alt="2-4.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2-5.JPG" alt="2-5.JPG"></p><h2 id="（第3阶段）学生签到考勤系统截图-略"><a href="#（第3阶段）学生签到考勤系统截图-略" class="headerlink" title="（第3阶段）学生签到考勤系统截图(略)"></a>（第3阶段）学生签到考勤系统截图(略)</h2><h2 id="（第4阶段）学生成绩管理系统部分截图"><a href="#（第4阶段）学生成绩管理系统部分截图" class="headerlink" title="（第4阶段）学生成绩管理系统部分截图"></a>（第4阶段）学生成绩管理系统部分截图</h2><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-1.JPG" alt="4-1.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-2.JPG" alt="4-2.JPG"></p><p><img src="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/4-3.JPG" alt="4-3.JPG"></p><h4 id="完整源代码和视频教学资源：百度云链接-百度网盘，提取码：3jbh"><a href="#完整源代码和视频教学资源：百度云链接-百度网盘，提取码：3jbh" class="headerlink" title="完整源代码和视频教学资源：百度云链接:百度网盘，提取码：3jbh"></a><strong><em>完整源代码和视频教学资源：百度云链接:<a href="https://pan.baidu.com/s/1vwebuzdVTBmSc-bHdbEnSg" target="_blank" rel="noopener">百度网盘</a>，提取码：3jbh</em></strong></h4><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 学生管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学生管理系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新日志</title>
      <link href="/2020/03/01/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
      <url>/2020/03/01/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jun 16 2020 16:34:55 GMT+0800 (GMT+08:00) --><h1 id="1-更新："><a href="#1-更新：" class="headerlink" title="1. 更新："></a>1. 更新：</h1><h2 id="2020-2-29"><a href="#2020-2-29" class="headerlink" title="2020.2.29"></a>2020.2.29</h2><ol><li><em>页面加载性能优化</em></li><li><em>图片懒加载</em></li><li><em>发布新博客</em></li><li><em>优化背景</em></li><li><em>压缩代码</em></li></ol><h2 id="2020-6-09"><a href="#2020-6-09" class="headerlink" title="2020.6.09"></a>2020.6.09</h2><ul><li>更换Butterfly主题</li></ul><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> 更新日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, I am</title>
      <link href="/2020/01/07/hello-world/"/>
      <url>/2020/01/07/hello-world/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jun 16 2020 16:34:55 GMT+0800 (GMT+08:00) --><p>Welcome to Qing-Bei’s blog!</p><p>I am Qing-Bei, a contemporary college student and future programmer who loves programming and mining various technologies.I hope to find the answer in my heart through my own efforts.</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World！ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
