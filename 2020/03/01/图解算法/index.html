<!-- build time:Wed Jun 17 2020 15:19:51 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>图解算法 | 路漫漫其修远兮 吾将上下而求索</title><meta name="description" content="图解算法1. 第一章 算法简介1.2 二分查找二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。使用二分查找时，每次都排除一半的数字。一般而言，对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。仅当列表是有序的时候，二分查找才管用。二分法代码实现：123456789101112"><meta name="keywords" content="算法,python"><meta name="author" content="轻北"><meta name="copyright" content="轻北"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="dns-prefetch" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="https://ziyuan.baidu.com/property/index?site=http://www.qing-bei.com/#/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="图解算法"><meta name="twitter:description" content="图解算法1. 第一章 算法简介1.2 二分查找二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。使用二分查找时，每次都排除一半的数字。一般而言，对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。仅当列表是有序的时候，二分查找才管用。二分法代码实现：123456789101112"><meta name="twitter:image" content="https://wx1.sbimg.cn/2020/06/16/pexels-photo-2422293.jpg"><meta property="og:type" content="article"><meta property="og:title" content="图解算法"><meta property="og:url" content="http://www.qing-bei.com/2020/03/01/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="路漫漫其修远兮 吾将上下而求索"><meta property="og:description" content="图解算法1. 第一章 算法简介1.2 二分查找二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。使用二分查找时，每次都排除一半的数字。一般而言，对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。仅当列表是有序的时候，二分查找才管用。二分法代码实现：123456789101112"><meta property="og:image" content="https://wx1.sbimg.cn/2020/06/16/pexels-photo-2422293.jpg"><meta property="article:published_time" content="2020-03-01T09:28:37.000Z"><meta property="article:modified_time" content="2020-06-17T07:19:28.320Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>function activateDarkMode(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#000")}function activateLightMode(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#fff")}var autoChangeMode="1",t=Cookies.get("theme");if("1"==autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){console.log("You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.");var now=new Date,hour=now.getHours(),isNight=hour<6||hour>=18;isNight?activateDarkMode():activateLightMode()}}else"light"==t?activateLightMode():activateDarkMode()}else"2"==autoChangeMode?(now=new Date,hour=now.getHours(),isNight=hour<6||hour>=18,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"==t?activateDarkMode():"light"==t&&activateLightMode()</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.qing-bei.com/2020/03/01/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95/"><link rel="prev" title="一篇文章让你彻底掌握 shell 语言" href="http://www.qing-bei.com/2020/03/01/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Shell/"><link rel="next" title="学生管理系统" href="http://www.qing-bei.com/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"We didn't find any results for the search: ${query}"}},translate:{defaultEncoding:2,translateDelay:0,cookieDomain:"https://xxx/",msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"},bookmark:{message_prev:"Press",message_next:"to bookmark this page"},runtime_unit:"days",runtime:!0,copyright:void 0,ClickShowText:{text:"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善",fontSize:"15px"},medium_zoom:!1,fancybox:!0,Snackbar:void 0,baiduPush:!0,highlightCopy:!0,highlightLang:!0,highlightShrink:"false",isFontAwesomeV5:!1,isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script>var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isSidebar:!0}</script><noscript><style>#page-header{opacity:1}.justified-gallery img{opacity:1}</style></noscript><link rel="stylesheet" href="/css/footerjianbian.css"><link rel="stylesheet" href="/css/siderbargundong.css"><link rel="stylesheet" href="/css/backgroundRgba.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="路漫漫其修远兮 吾将上下而求索" type="application/atom+xml"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://wx1.sbimg.cn/2020/06/08/me.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#图解算法"><span class="toc-number">1.</span> <span class="toc-text">图解算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-第一章-算法简介"><span class="toc-number">1.1.</span> <span class="toc-text">1. 第一章 算法简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-第二章-选择排序"><span class="toc-number">1.2.</span> <span class="toc-text">2. 第二章 选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-第三章-递归"><span class="toc-number">1.3.</span> <span class="toc-text">3. 第三章 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-第四章-快速排序"><span class="toc-number">1.4.</span> <span class="toc-text">4. 第四章 快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-第五章-散列表"><span class="toc-number">1.5.</span> <span class="toc-text">5. 第五章 散列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-第六章-广度优先搜索（-breadth-first-search，-BFS）"><span class="toc-number">1.6.</span> <span class="toc-text">6. 第六章 广度优先搜索（ breadth-first search， BFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-第七章-狄克斯特拉算法"><span class="toc-number">1.7.</span> <span class="toc-text">7. 第七章 狄克斯特拉算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-第八章-贪婪算法"><span class="toc-number">1.8.</span> <span class="toc-text">8. 第八章 贪婪算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-第九章-动态规划"><span class="toc-number">1.9.</span> <span class="toc-text">9. 第九章 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-第十章-K最近邻算法"><span class="toc-number">1.10.</span> <span class="toc-text">10. 第十章 K最近邻算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-第十一章-接下来如何做"><span class="toc-number">1.11.</span> <span class="toc-text">11. 第十一章 接下来如何做</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image:url(https://wx1.sbimg.cn/2020/06/16/pexels-photo-2422293.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">路漫漫其修远兮 吾将上下而求索</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">图解算法</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-03-01 17:28:37"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-03-01</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-06-17 15:19:28"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-06-17</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>Word count:</span><span class="word-count">6.8k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>Reading time: 21 min</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h1><h2 id="1-第一章-算法简介"><a href="#1-第一章-算法简介" class="headerlink" title="1. 第一章 算法简介"></a><strong>1. 第一章 算法简介</strong></h2><p>1.2 二分查找<br>二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。使用二分查找时，每次都排除一半的数字。<br>一般而言，对于包含n个元素的列表，用二分查找最多需要<strong>log2n</strong>步，而简单查找最多需要<strong>n</strong>步。仅当列表是有序的时候，二分查找才管用。<br>二分法代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list)—<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high: <span class="comment">#只要范围没有缩小到只包含一个元素，就检查中间的元素</span></span><br><span class="line">        mid = (low + high)</span><br><span class="line">        guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == item:  <span class="comment">#找到了元素</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:  <span class="comment">#猜的数字大了</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:            <span class="comment">#猜的数字小了</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>   <span class="comment">#没有指定的元素</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">3</span>)  <span class="comment"># =&gt; 1</span></span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">-1</span>)  <span class="comment"># =&gt; None</span></span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><p>1.2.2 运行时间<br>二分查找的运行时间为对数时间（或log时间）。简单查找的运行时间为线性时间。</p><p>1.3 大 O表示法<br>算法的运行时间以不同的速度增加。<br>大O表示法指出了算法有多快，大O表示法指的并非以秒为单位的速度。 大O表示法让你能够比较操作数，它指出了算法运行时间的增速。二分查找需要执行log n次操作，使用大O表示法，O(log n)。简单查找的运行时间为O(n)。大O表示法说的是最糟的情形。</p><p>1.3.4 一些常见的大 O 运行时间（“阶指幂对”）<br>O(log n)，也叫对数时间，这样的算法包括二分查找。<br>O(n)，也叫线性时间，这样的算法包括简单查找。<br>O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。<br>O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。<br>O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</p><blockquote><p>小结：<br>\1. 算法的速度指的并非时间，而是操作数的增速。谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。<br>\2. 算法的运行时间用大O表示法表示。 O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。 算法运行时间并不以秒为单位。<br>\3. 算法运行时间是从其增速的角度度量的。</p></blockquote><h2 id="2-第二章-选择排序"><a href="#2-第二章-选择排序" class="headerlink" title="2. 第二章 选择排序"></a><strong>2. 第二章 选择排序</strong></h2><p>2.1 内存的工作原理<br>计算机就像是很多抽屉的集合体，每个抽屉都有地址。<br>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——<strong>数组和链表</strong>。<br>2.2 数组和链表<br>使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。<br>需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。<br>需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。<br>2.2.3 术语<br>元素的位置称为索引。<br><img src="https://img-blog.csdn.net/20180702203705464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>2.2.4 在中间插入<br>需要在中间插入元素时，数组和链表哪个更好呢？使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。</p><p>2.3 选择排序<br>需要的总时间为 O(n × n)，即O(n2)。<br>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSmallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ar</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    newArr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        smallest = findSmallest(arr)</span><br><span class="line">        newArr.append(arr.pop(smallest))</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line"><span class="keyword">print</span> selectionSort([<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>])</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><h2 id="3-第三章-递归"><a href="#3-第三章-递归" class="headerlink" title="3. 第三章 递归"></a><strong>3. 第三章 递归</strong></h2><p>3.2 基线条件和递归条件<br>编写递归函数时，必须告诉它何时停止递归。正因为如此， 每个递归函数都有两部分：基线条件（ base case）和递归条件（ recursive case） 。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">0</span>:   <span class="comment">#基线条件</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:    <span class="comment">#递归条件</span></span><br><span class="line">        countdown(i<span class="number">-1</span>)</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>3.3 栈<br>栈是一种简单的数据结构，栈有两种操作：压入（插入）和弹出（删除并读取）。<br>每当调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。这个栈用于存储多个函数的变量，被称为调用栈。 调用栈可能很长，这将占用大量的内存。所有函数调用都进入调用栈。</p><h2 id="4-第四章-快速排序"><a href="#4-第四章-快速排序" class="headerlink" title="4. 第四章 快速排序"></a><strong>4. 第四章 快速排序</strong></h2><p>4.1 分而治之<br>D&amp;C算法包括两个步骤：<br>(1) 找出基线条件，这种条件必须尽可能简单。<br>(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。<br>D&amp;C的工作原理：<br>(1) 找出简单的基线条件；<br>(2) 确定如何缩小问题的规模，使其符合基线条件。</p><p>快速排序的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"><span class="keyword">print</span> quicksort([<span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>4.3 再谈大 O 表示法<br>快速排序的独特之处在于，其速度取决于选择的基准值。选择排序，其运行时间为O(n2)，速度非常慢。<br><img src="https://img-blog.csdn.net/20180703205638308?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>合并排序（ merge sort） 的排序算法，其运行时间为O(n log n)。比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。<br>4.4 小结<br>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。<br>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。<br>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， O(log n)的速度比O(n)快得多。</p><h2 id="5-第五章-散列表"><a href="#5-第五章-散列表" class="headerlink" title="5. 第五章 散列表"></a><strong>5. 第五章 散列表</strong></h2><p>运行时间O(n)和O(log n)之间有天壤之别！</p><ol><li>散列函数总是将同样的输入映射到相同的索引。</li><li>散列函数将不同的输入映射到不同的索引。</li><li>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。</li></ol><p>散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。</p><p>5.2.3 将散列表用作缓存<br>缓存的工作原理：网站将数据记住，而不再重新计算。<br>缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！</p><blockquote><p>散列表适合用于：</p><ol><li>模拟映射关系；</li><li>防止重复；</li><li>缓存/记住数据，以免服务器再通过处理来生成它们。</li></ol></blockquote><p>5.3 冲突<br>冲突（ collision） ：给两个键分配的位置相同。<br>处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。<br>散列函数很重要，好的散列函数很少导致冲突。</p><p>5.4 性能<br>在平均情况下，散列表执行各种操作的时间都为O(1)。 O(1)被称为常量时间。简单查找的运行时间为线性时间。二分查找的速度更快，所需时间为对数时间。在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。<br>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。<br>因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：<br> 较低的填装因子；<br> 良好的散列函数。</p><h2 id="6-第六章-广度优先搜索（-breadth-first-search，-BFS）"><a href="#6-第六章-广度优先搜索（-breadth-first-search，-BFS）" class="headerlink" title="6. 第六章 广度优先搜索（ breadth-first search， BFS）"></a><strong>6. 第六章 广度优先搜索（ breadth-first search， BFS）</strong></h2><p>广度优先搜索让你能够找出两样东西之间的最短距离，广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。<br>第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？）<br>第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？）<br>使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。<br><strong>广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。</strong></p><p>6.3.2 队列<br>队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作： 入队和出队。<br><strong>队列是一种先进先出（ First In First Out， FIFO）的数据结构，而栈是一种后进先出（ Last InFirst Out， LIFO）的数据结构。</strong><br>运行时间<br>如果你在你的整个人际关系网中搜索芒果销售商，就意味着你将沿每条边前行（记住，边是从一个人到另一个人的箭头或连接），因此运行时间至少为O(边数)。<br>你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（ vertice）数， E为边数。<br>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。</p><h2 id="7-第七章-狄克斯特拉算法"><a href="#7-第七章-狄克斯特拉算法" class="headerlink" title="7. 第七章 狄克斯特拉算法"></a><strong>7. 第七章 狄克斯特拉算法</strong></h2><p>应用场景：路由协议选路<br>广度优先搜索，它找出的是段数最少的路径，狄克斯特拉算法（ Dijkstra’s algorithm）找的是最快的路径。广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是段数最少。<strong>在狄克斯特拉算法中，你给每段都分配了一个数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。</strong><br>狄克斯特拉算法包含4个步骤。<br>(1) 找出“代价最低”的节点，即可在最短时间内到达的节点。<br>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。<br>(3) 重复这个过程，直到对图中的每个节点都这样做了。<br>(4) 计算最终路径。<br>带权重的图称为加权图（ weighted graph），不带权重的图称为非加权图（unweighted graph）。<br>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。<strong>狄克斯特拉算法只适用于有向无环图</strong>。<br>最短路径指的并不一定是物理距离，也可能是让某种度量指标最小。如果有负权边，就不能使用狄克斯特拉算法。因为负权边会导致这种算法不管用。</p><blockquote><p>7.6 小结</p><ol><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径。</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ol></blockquote><h2 id="8-第八章-贪婪算法"><a href="#8-第八章-贪婪算法" class="headerlink" title="8. 第八章 贪婪算法"></a><strong>8. 第八章 贪婪算法</strong></h2><p>贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。<br>8.2 背包问题<br>在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。<br>背包问题就是有若干物品，每个物品有自己的价值和重量。背包有总重量。问题就是怎样将背包装的最大价值。背包问题也分很多种，贪心算法解决的是物品可以拆分的背包问题（就是物品可以分成几份装入）。这个问题用贪心还是比较好解决的。贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。此问题就是将每次的放入看成每一步，要想解决问题，就是将每一步都放入最优解。也就是说，每一次的放入都要放入最佳的选择。讲到这里，就要说一说最佳的选择，每一次的放入的最佳的选择就是每次放入的物品都是剩余的物品中价值最大且质量最小的，这里就要引入一个物品的属性，物品的权重值。物品的权重值就是指物品的价值除以物品的质量。所以，本问题的每一次的最佳选择就是每次都选出权重值最大的物品。<br>近似算法<br>在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：<br> 速度有多快；<br> 得到的近似解与最优解的接近程度。</p><p>8.4 NP 完全问题(Non-deterministic Polynomial多项式的不确定性)<br>NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。<br>如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。</p><p> 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。<br> 涉及“所有组合”的问题通常是NP完全问题。<br> 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。<br> 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。<br> 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。<br> 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</p><blockquote><p>8.5 小结</p><ol><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。</li><li>对于NP完全问题，还没有找到快速解决方案。</li><li>面临NP完全问题时，最佳的做法是使用近似算法。</li><li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li></ol></blockquote><h2 id="9-第九章-动态规划"><a href="#9-第九章-动态规划" class="headerlink" title="9. 第九章 动态规划"></a><strong>9. 第九章 动态规划</strong></h2><p>9.1.2 动态规划<br>动态规划先解决子问题，再逐步解决大问题。<br>对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。<br>每个动态规划算法都从一个网格开始，网格的各行为商品，各列为不同容量（ 1～4磅）的背包。所有这些列你都需要，因为它们将帮助你计算子背包的价值。<br>动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。 但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。</p><blockquote><ol><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。</li><li>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。要设计出动态规划解决方案可能很难，这正是本节要介绍的。下面是一些通用的小贴士。</li><li>每种动态规划解决方案都涉及网格。</li></ol></blockquote><p>9.3.1 绘制网格<br>对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。</p><blockquote><p>9.4 小结</p><ol><li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li><li>问题可分解为离散子问题时，可使用动态规划来解决。</li><li>每种动态规划解决方案都涉及网格。</li><li>单元格中的值通常就是你要优化的值。</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li><li>没有放之四海皆准的计算动态规划解决方案的公式。</li></ol></blockquote><h2 id="10-第十章-K最近邻算法"><a href="#10-第十章-K最近邻算法" class="headerlink" title="10. 第十章 K最近邻算法"></a><strong>10. 第十章 K最近邻算法</strong></h2><p>KNN可以用来做两项基本工作——分类和回归：</p><ol><li>分类就是编组；</li><li>回归就是预测结果（如一个数字）。</li></ol><p><strong>余弦相似度（ cosine similarity）</strong><br>余弦相似度不计算两个矢量的距离，而比较它们的角度。<br>余弦相似度。余弦相似度被广泛用于协同过滤算法中，尤其是Item-base的协同过滤。<br>余弦相似度衡量的是两个向量间的夹角大小，通过夹角的余弦值表示结果，假设A向量是（x1, y1），B向量是(x2, y2)，那么两个向量的余弦相似度为：</p><p>分子为向量A与向量B的点乘，分母为二者各自的L2相乘，即将所有维度值的平方相加后开方。 余弦相似度的取值为[-1,1]，值越大表示越相似。</p><p>10.3.1 OCR<br>OCR指的是光学字符识别（ optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。 一般而言， OCR算法提取线段、点和曲线等特征。<br>OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（ training）。大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。</p><p>10.3.2 创建垃圾邮件过滤器<br>垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（ Naive Bayes classifier）。</p><blockquote><p>10.4 小结</p><ol><li>KNN用于分类和回归，需要考虑最近的邻居。</li><li>分类就是编组。</li><li>回归就是预测结果（如数字）。</li><li>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。</li><li>能否挑选合适的特征事关KNN算法的成败。</li></ol></blockquote><h2 id="11-第十一章-接下来如何做"><a href="#11-第十一章-接下来如何做" class="headerlink" title="11. 第十一章 接下来如何做"></a><strong>11. 第十一章 接下来如何做</strong></h2><p>二叉查找树（ binary search tree）<br>在二叉查找树中查找节点时，平均运行时间为O(log n)，但在最糟的情况下所需时间为O(n)；而在有序数组中查找时，即便是在最糟情况下所需的时间也只有O(log n)，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。<br><img src="https://img-blog.csdn.net/2018070419575199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzc5MDA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>二叉查找树也存在一些缺点，例如，不能随机访问，在二叉查找树处于平衡状态时，平均访问时间也为O(log n)。</p><p>11.2 反向索引<br>一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（ inverted index），常用于创建搜索引擎。</p><p>11.4 并行算法<br>并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。<br>并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。<br>负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易， 10秒钟就完成了，而分配给内核B的任务都很难， 1分钟才完成。这意味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？</p><p>11.5 MapReduce<br>MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（ map）函数和归并（ reduce）函数。<br>11.5.2 映射函数<br>映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。<br>11.5.3 归并函数<br>归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。<br>MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。<br>11.6 布隆过滤器和 HyperLogLog<br>布隆过滤器是一种概率型数据结构，布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况，前面所有的示例都是这样的。<br>HyperLogLog是一种类似于布隆过滤器的算法。<br>HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。<br>面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！</p><p>11.7 SHA 算法<br>另一种散列函数是安全散列算法（ secure hash algorithm， SHA）函数。给定一个字符串， SHA返回其散列值。<br>SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。对于每个不同的字符串， SHA生成的散列值都不同。<br>你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。</p><p><strong>斐波那契数列</strong><br>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p><p>递归方式实现斐波那契数列 前n项:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归方式实现 生成前20项</span></span><br><span class="line">lis =[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">0</span> <span class="keyword">or</span> i ==<span class="number">1</span>:<span class="comment">#第1,2项 都为1</span></span><br><span class="line">        lis.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lis.append(lis[i<span class="number">-2</span>]+lis[i<span class="number">-1</span>])<span class="comment">#从第3项开始每项值为前两项值之和</span></span><br><span class="line">print(lis)<span class="number">12345678</span></span><br><span class="line"> <span class="comment">#递归函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_function_tool</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Fibonacci_function_tool(n - <span class="number">1</span>) + Fibonacci_function_tool(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_function</span><span class="params">(n)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>): result_list.append(Fibonacci_function_tool(i))</span><br><span class="line">    <span class="keyword">return</span> result_list1234567891011121314</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">轻北</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.qing-bei.com/2020/03/01/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95/">http://www.qing-bei.com/2020/03/01/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post_share"><div class="social-share" data-image="https://wx1.sbimg.cn/2020/06/16/pexels-photo-2657669.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://wx2.sbimg.cn/2020/06/09/IMG_20200609_094422.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://wx2.sbimg.cn/2020/06/09/IMG_20200609_094512.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/01/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Shell/"><img class="prev_cover" src="https://wx1.sbimg.cn/2020/06/16/pexels-photo-374074.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">一篇文章让你彻底掌握 shell 语言</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/01/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><img class="next_cover" src="https://wx1.sbimg.cn/2020/06/09/16pic_4218291_b.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">学生管理系统</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/09/Python的 is 和 == 你真的搞对对象了吗？/" title="python中的is 和 == 你真的搞对对象了吗？"><img class="relatedPosts_cover" src="https://wx1.sbimg.cn/2020/06/16/pexels-photo-2657669.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-09</div><div class="relatedPosts_title">python中的is 和 == 你真的搞对对象了吗？</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/09/谈谈python中的深拷贝和浅拷贝/" title="Python中深拷贝和浅拷贝"><img class="relatedPosts_cover" src="https://wx1.sbimg.cn/2020/06/09/16pic_4218291_b.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-09</div><div class="relatedPosts_title">Python中深拷贝和浅拷贝</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/05/python列表生成式/" title="python列表生成式"><img class="relatedPosts_cover" src="https://wx1.sbimg.cn/2020/06/09/16pic_6826865_b.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-05</div><div class="relatedPosts_title">python列表生成式</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting=function(e,a){var e=e,d=a.split(",").filter(function(a){return e.indexOf(a)>-1});return d=0==d.length?e:d},guestInfo=requestSetting(["nick","mail","link"],"nick,mail,link"),requiredFields=requestSetting(["nick","mail","link"],"nick,mail");window.valine=new Valine({el:"#vcomment",appId:"SOztNhjDgvdFwsXY09QPjNwU-gzGzoHsz",appKey:"RhybWYtt4u2WNJhzFkrVgoJ2",notify:!1,verify:!1,placeholder:"Please leave your footprints",avatar:"monsterid",meta:guestInfo,pageSize:"10",lang:"en",recordIP:!0,serverURLs:"",emojiCDN:"//i0.hdslb.com/bfs/emote/",emojiMaps:{tv_doge:"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},enableQQ:!0,requiredFields:requiredFields})</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 轻北</div><div class="icp"><a href="http://www.beian.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="https://wx2.sbimg.cn/2020/06/08/74537af458689411e284d6441c415a44.png"><span>湘公网安备4301240200591号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="159195086280" m="1"></script></body></html><!-- rebuild by neat -->