<!-- build time:Sun Aug 09 2020 21:11:37 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go问答101 | 路漫漫其修远兮 吾将上下而求索</title><meta name="description" content="Go问答101（这是一份非官方Go问答列表。官方版问答列表在这里。）索引：编译器与运行时编译器错误信息non-name *** on left side of :&#x3D;意味着什么?编译器错误信息unexpected newline, expecting { after if clause意味着什么?编译器错误信息declared and not used意味着什么?Go运行时是否维护映射条目的遍历顺序"><meta name="keywords" content="GO"><meta name="author" content="轻北"><meta name="copyright" content="轻北"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="dns-prefetch" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="https://ziyuan.baidu.com/property/index?site=http://www.qing-bei.com/#/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go问答101"><meta name="twitter:description" content="Go问答101（这是一份非官方Go问答列表。官方版问答列表在这里。）索引：编译器与运行时编译器错误信息non-name *** on left side of :&#x3D;意味着什么?编译器错误信息unexpected newline, expecting { after if clause意味着什么?编译器错误信息declared and not used意味着什么?Go运行时是否维护映射条目的遍历顺序"><meta name="twitter:image" content="https://wx2.sbimg.cn/2020/06/16/pexels-photo-1148820.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Go问答101"><meta property="og:url" content="http://www.qing-bei.com/2020/08/09/GO%E9%97%AE%E7%AD%94101/"><meta property="og:site_name" content="路漫漫其修远兮 吾将上下而求索"><meta property="og:description" content="Go问答101（这是一份非官方Go问答列表。官方版问答列表在这里。）索引：编译器与运行时编译器错误信息non-name *** on left side of :&#x3D;意味着什么?编译器错误信息unexpected newline, expecting { after if clause意味着什么?编译器错误信息declared and not used意味着什么?Go运行时是否维护映射条目的遍历顺序"><meta property="og:image" content="https://wx2.sbimg.cn/2020/06/16/pexels-photo-1148820.jpg"><meta property="article:published_time" content="2020-08-09T09:28:37.000Z"><meta property="article:modified_time" content="2020-08-09T13:10:55.322Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>function activateDarkMode(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#000")}function activateLightMode(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#fff")}var autoChangeMode="1",t=Cookies.get("theme");if("1"==autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){console.log("You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.");var now=new Date,hour=now.getHours(),isNight=hour<6||hour>=18;isNight?activateDarkMode():activateLightMode()}}else"light"==t?activateLightMode():activateDarkMode()}else"2"==autoChangeMode?(now=new Date,hour=now.getHours(),isNight=hour<6||hour>=18,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"==t?activateDarkMode():"light"==t&&activateLightMode()</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.qing-bei.com/2020/08/09/GO%E9%97%AE%E7%AD%94101/"><link rel="next" title="初识python装饰器" href="http://www.qing-bei.com/2020/07/14/%E5%88%9D%E8%AF%86python%E8%A3%85%E9%A5%B0%E5%99%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"We didn't find any results for the search: ${query}"}},translate:{defaultEncoding:2,translateDelay:0,cookieDomain:"https://xxx/",msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"},bookmark:{message_prev:"Press",message_next:"to bookmark this page"},runtime_unit:"days",runtime:!0,copyright:void 0,ClickShowText:{text:"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善",fontSize:"15px"},medium_zoom:!1,fancybox:!0,Snackbar:void 0,baiduPush:!0,highlightCopy:!0,highlightLang:!0,highlightShrink:"false",isFontAwesomeV5:!1,isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script>var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isSidebar:!0}</script><noscript><style>#page-header{opacity:1}.justified-gallery img{opacity:1}</style></noscript><link rel="stylesheet" href="/css/footerjianbian.css"><link rel="stylesheet" href="/css/siderbargundong.css"><link rel="stylesheet" href="/css/backgroundRgba.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="路漫漫其修远兮 吾将上下而求索" type="application/atom+xml"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://wx1.sbimg.cn/2020/06/08/me.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go问答101"><span class="toc-number">1.</span> <span class="toc-text">Go问答101</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编译器错误信息non-name-on-left-side-of-意味着什么"><span class="toc-number">1.0.1.</span> <span class="toc-text">编译器错误信息non-name *** on left side of :&#x3D;意味着什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译器错误信息unexpected-newline-expecting-意味着什么"><span class="toc-number">1.0.2.</span> <span class="toc-text">编译器错误信息unexpected newline, expecting { ...意味着什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译器错误信息declared-and-not-used意味着什么"><span class="toc-number">1.0.3.</span> <span class="toc-text">编译器错误信息declared and not used意味着什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go运行时是否维护映射条目的遍历顺序？"><span class="toc-number">1.0.4.</span> <span class="toc-text">Go运行时是否维护映射条目的遍历顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go编译器是否会进行字节填充以确保结构体字段的地址对齐？"><span class="toc-number">1.0.5.</span> <span class="toc-text">Go编译器是否会进行字节填充以确保结构体字段的地址对齐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？"><span class="toc-number">1.0.6.</span> <span class="toc-text">为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-T-是var-t-T-amp-t-的语法糖吗？"><span class="toc-number">1.0.7.</span> <span class="toc-text">new(T)是var t T; (&amp;t)的语法糖吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时错误信息all-goroutines-are-asleep-deadlock意味着什么"><span class="toc-number">1.0.8.</span> <span class="toc-text">运行时错误信息all goroutines are asleep - deadlock意味着什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？"><span class="toc-number">1.0.9.</span> <span class="toc-text">64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值是原子操作吗？"><span class="toc-number">1.0.10.</span> <span class="toc-text">赋值是原子操作吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#是否每一个零值在内存中占据的字节都是零？"><span class="toc-number">1.0.11.</span> <span class="toc-text">是否每一个零值在内存中占据的字节都是零？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准的Go编译器是否支持函数内联？"><span class="toc-number">1.0.12.</span> <span class="toc-text">标准的Go编译器是否支持函数内联？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终结器（finalizer）可以用做对象的析构函数吗？"><span class="toc-number">1.0.13.</span> <span class="toc-text">终结器（finalizer）可以用做对象的析构函数吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用尽可能短的代码行数来获取任意月份的天数？"><span class="toc-number">1.0.14.</span> <span class="toc-text">如何使用尽可能短的代码行数来获取任意月份的天数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用time-Sleep-d-和通道接收-lt-time-After-d-操作之间有何区别？"><span class="toc-number">1.0.15.</span> <span class="toc-text">函数调用time.Sleep(d)和通道接收&lt;-time.After(d)操作之间有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用strings和bytes标准库包里TrimLeft和TrimRight函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？"><span class="toc-number">1.0.16.</span> <span class="toc-text">调用strings和bytes标准库包里TrimLeft和TrimRight函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数fmt-Print和fmt-Println-的区别是什么？"><span class="toc-number">1.0.17.</span> <span class="toc-text">函数fmt.Print和fmt.Println 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数log-Print-和函数-log-Println-有什么区别吗"><span class="toc-number">1.0.18.</span> <span class="toc-text">函数log.Print 和函数 log.Println 有什么区别吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数fmt-Print、fmt-Println和fmt-Printf的实现进行同步了吗？"><span class="toc-number">1.0.19.</span> <span class="toc-text">函数fmt.Print、fmt.Println和fmt.Printf的实现进行同步了吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？"><span class="toc-number">1.0.20.</span> <span class="toc-text">内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准库包math-rand和crypto-rand生成的随机数之间有什么区别？"><span class="toc-number">1.0.21.</span> <span class="toc-text">标准库包math&#x2F;rand和crypto&#x2F;rand生成的随机数之间有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准库中为什么没有math-Round函数"><span class="toc-number">1.0.22.</span> <span class="toc-text">标准库中为什么没有math.Round函数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哪些类型不支持比较？"><span class="toc-number">1.0.23.</span> <span class="toc-text">哪些类型不支持比较？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么两个nil值有时候会不相等？"><span class="toc-number">1.0.24.</span> <span class="toc-text">为什么两个nil值有时候会不相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么类型-T1和-T2没有共享相同底层类型，即使不同的类型T1和T2共享相同的底层类型？"><span class="toc-number">1.0.25.</span> <span class="toc-text">为什么类型[]T1和[]T2没有共享相同底层类型，即使不同的类型T1和T2共享相同的底层类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哪些值可以被取地址，哪些值不可以被取地址？"><span class="toc-number">1.0.26.</span> <span class="toc-text">哪些值可以被取地址，哪些值不可以被取地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么映射元素不可被取地址？"><span class="toc-number">1.0.27.</span> <span class="toc-text">为什么映射元素不可被取地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？"><span class="toc-number">1.0.28.</span> <span class="toc-text">为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对任意的非指针和非接口定义类型T，为什么类型-T的方法集总是类型T的方法集的超集，但是反之却不然？"><span class="toc-number">1.0.29.</span> <span class="toc-text">对任意的非指针和非接口定义类型T，为什么类型*T的方法集总是类型T的方法集的超集，但是反之却不然？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我们可以为哪些类型声明方法？"><span class="toc-number">1.0.30.</span> <span class="toc-text">我们可以为哪些类型声明方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在Go里如何声明不可变量？"><span class="toc-number">1.0.31.</span> <span class="toc-text">在Go里如何声明不可变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么没有内置的set容器类型？"><span class="toc-number">1.0.32.</span> <span class="toc-text">为什么没有内置的set容器类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是byte？什么是rune？-如何将-byte和-rune类型的值转换为字符串？"><span class="toc-number">1.0.33.</span> <span class="toc-text">什么是byte？什么是rune？ 如何将[]byte和[]rune类型的值转换为字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何原子地操作指针值？"><span class="toc-number">1.0.34.</span> <span class="toc-text">如何原子地操作指针值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iota是什么意思？"><span class="toc-number">1.0.35.</span> <span class="toc-text">iota是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么没有一个内置的closed函数用来检查通道是否已经关闭？"><span class="toc-number">1.0.36.</span> <span class="toc-text">为什么没有一个内置的closed函数用来检查通道是否已经关闭？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数返回局部变量的指针是否安全？"><span class="toc-number">1.0.37.</span> <span class="toc-text">函数返回局部变量的指针是否安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单词gopher-在Go社区中表示什么？"><span class="toc-number">1.0.38.</span> <span class="toc-text">单词gopher\在Go社区中表示什么？</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image:url(https://wx2.sbimg.cn/2020/06/16/pexels-photo-1148820.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">路漫漫其修远兮 吾将上下而求索</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Go问答101</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-08-09 17:28:37"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-08-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-08-09 21:10:55"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-08-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/GO/">GO</a></span></div><div class="meta-secondline"><span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>Word count:</span><span class="word-count">8.2k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>Reading time: 27 min</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Go问答101"><a href="#Go问答101" class="headerlink" title="Go问答101"></a>Go问答101</h1><p><em>（这是一份非官方Go问答列表。官方版问答列表<a href="https://golang.google.cn/doc/faq" target="_blank" rel="noopener">在这里</a>。）</em></p><p>索引：</p><ul><li>编译器与运行时<ul><li><a href="https://gfw.go101.org/article/unofficial-faq.html#error-non-name" target="_blank" rel="noopener">编译器错误信息<code>non-name *** on left side of :=</code>意味着什么?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#error-missing-left-brace" target="_blank" rel="noopener">编译器错误信息<code>unexpected newline, expecting { after if clause</code>意味着什么?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#error-declared-not-used" target="_blank" rel="noopener">编译器错误信息<code>declared and not used</code>意味着什么?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#map-iteration-order" target="_blank" rel="noopener">Go运行时是否维护映射条目的遍历顺序？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#compiler-field-padding" target="_blank" rel="noopener">Go编译器是否会进行字节填充以确保结构体字段的地址对齐？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#final-zero-size-field" target="_blank" rel="noopener">为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体类型的尺寸？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#new-function" target="_blank" rel="noopener"><code>new(T)</code>是<code>var t T; (&amp;t)</code>的语法糖吗？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#fatal-error-deadlock" target="_blank" rel="noopener">运行时错误信息<code>all goroutines are asleep - deadlock</code>意味着什么?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#64-bit-alignment" target="_blank" rel="noopener">64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#atomical-assignment" target="_blank" rel="noopener">赋值是原子操作吗？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#zero-values-zero-bytes" target="_blank" rel="noopener">是否每一个零值在内存中占据的字节都是零？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#function-inline" target="_blank" rel="noopener">标准的Go编译器是否支持函数内联？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#finalizers" target="_blank" rel="noopener">终结器（finalizer）可以用做对象的析构函数吗？</a></li></ul></li><li>标准库<ul><li><a href="https://gfw.go101.org/article/unofficial-faq.html#get-days-of-month" target="_blank" rel="noopener">如何使用尽可能短的代码行数来获取任意月份的天数？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#time-sleep-after" target="_blank" rel="noopener">函数调用<code>time.Sleep(d)</code>和通道接收<code>&lt;-time.After(d)</code>操作之间有何区别？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#trim" target="_blank" rel="noopener">调用<code>strings</code>和<code>bytes</code>标准库包里<code>TrimLeft</code>和<code>TrimRight</code>函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#fmt-print-println" target="_blank" rel="noopener">函数<code>fmt.Print</code>和<code>fmt.Println</code>的区别是什么？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#log-print-println" target="_blank" rel="noopener">函数<code>log.Print</code>和函数<code>log.Println</code>有什么区别吗?</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#fmt-print-synced" target="_blank" rel="noopener">函数<code>fmt.Print</code>、<code>fmt.Println</code>和<code>fmt.Printf</code>的实现进行同步了吗？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#print-builtin-fmt-log" target="_blank" rel="noopener">内置的<code>print</code>和<code>println</code>函数与<code>fmt</code>和<code>log</code>标准库包中相应的打印函数有什么区别？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#math-crypto-rand" target="_blank" rel="noopener">通过标准库包<code>math/rand</code>和<code>crypto/rand</code>生成的随机数之间有什么区别？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#math-round" target="_blank" rel="noopener">标准库中为什么没有<code>math.Round</code>函数？</a></li></ul></li><li>类型系统<ul><li><a href="https://gfw.go101.org/article/unofficial-faq.html#uncomparable-types" target="_blank" rel="noopener">哪些类型不支持比较？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#nil-equality" target="_blank" rel="noopener">为什么两个<code>nil</code>值有时候会不相等？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#slice-conversion" target="_blank" rel="noopener">为什么类型<code>[\]T1</code>和<code>[]T2</code>没有共享相同底层类型，即使不同的类型<code>T1</code>和<code>T2</code>共享相同的底层类型？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#unaddressable-values" target="_blank" rel="noopener">哪些值可以被取地址，哪些值不可以被取地址？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#map-elements-are-unaddressable" target="_blank" rel="noopener">为什么映射元素不可被取地址？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#slice-elements-always-addressable" target="_blank" rel="noopener">为什么非空切片的元素总是可被取地址，即便对于不可取地址的切片也是如此？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#method-set-relation" target="_blank" rel="noopener">对任意的非指针、非接口定义类型<code>T</code>，为什么类型<code>*T</code>的方法集总是类型<code>T</code>的方法集的超集，但是反之却不然？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#types-can-have-methods" target="_blank" rel="noopener">我们可以为哪些类型声明方法？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#declare-immutables" target="_blank" rel="noopener">在Go里如何声明不可变量？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#set-container-type" target="_blank" rel="noopener">为什么没有内置的<code>set</code>容器类型？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#byte-rune-slice-string" target="_blank" rel="noopener">什么是byte？什么是rune？如何将<code>[\]byte</code>和<code>[]rune</code>的值转换为字符串？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#pointer-atomic" target="_blank" rel="noopener">如何原子地操作指针值？</a></li></ul></li><li>其它<ul><li><a href="https://gfw.go101.org/article/unofficial-faq.html#about-iota" target="_blank" rel="noopener"><code>iota</code>是什么意思？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#check-if-channels-closed" target="_blank" rel="noopener">为什么没有一个内置的<code>closed</code>函数用来检查通道是否已经关闭？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#return-local-pointers" target="_blank" rel="noopener">函数返回局部变量的指针是否安全？</a></li><li><a href="https://gfw.go101.org/article/unofficial-faq.html#gopher" target="_blank" rel="noopener">单词<strong><em>gopher\</em></strong>在Go社区中表示什么？</a></li></ul></li></ul><h3 id="编译器错误信息non-name-on-left-side-of-意味着什么"><a href="#编译器错误信息non-name-on-left-side-of-意味着什么" class="headerlink" title="编译器错误信息non-name *** on left side of :=意味着什么?"></a>编译器错误信息<code>non-name *** on left side of :=</code>意味着什么?</h3><p>直到目前（Go 1.15）, Go中对短变量声明有一个<a href="https://golang.google.cn/ref/spec#Short_variable_declarations" target="_blank" rel="noopener">强制性约束</a>：</p><p>所有位于<code>:=</code>符号左侧的条目都必须是纯<a href="https://golang.google.cn/ref/spec#Identifiers" target="_blank" rel="noopener">标识符</a>，并且其中至少有一个为新变量名称。</p><p>这意味着容器元素索引表达式（<code>x[i]</code>）、结构体的字段选择器（<code>x.f</code>）、指针解引用（<code>*p</code>）和限定标识符（<code>aPackage.Value</code>）都不能出现在<code>:=</code>符号的左侧。</p><p>目前，这还是一个<a href="https://github.com/golang/go/issues/377" target="_blank" rel="noopener">未解决问题</a>（已经和<a href="https://github.com/golang/go/issues/6842" target="_blank" rel="noopener">一个相关问题</a>合并）。而且感觉Go核心开发团队目前<a href="https://github.com/golang/go/issues/30318" target="_blank" rel="noopener">并未有立即解决此问题的打算</a>。</p><h3 id="编译器错误信息unexpected-newline-expecting-意味着什么"><a href="#编译器错误信息unexpected-newline-expecting-意味着什么" class="headerlink" title="编译器错误信息unexpected newline, expecting { ...意味着什么?"></a>编译器错误信息<code>unexpected newline, expecting { ...</code>意味着什么?</h3><p>在编写Go代码时，我们不能随意断行。 请阅读<a href="https://gfw.go101.org/article/line-break-rules.html" target="_blank" rel="noopener">代码断行规则</a>一文以了解Go代码断行规则。 一般来说，根据这些规则，在左括号之前断行是不合法的。</p><p>例如，下列代码片段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = []<span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会被编译器解释成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span>;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = []<span class="keyword">int</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go编译器将为每个左大括号<code>{</code>起始的代码行报告一个语法错误。 为避免这些报错，我们需要将上述代码重写为下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = []<span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译器错误信息declared-and-not-used意味着什么"><a href="#编译器错误信息declared-and-not-used意味着什么" class="headerlink" title="编译器错误信息declared and not used意味着什么?"></a>编译器错误信息<code>declared and not used</code>意味着什么?</h3><p>对于标准编译器，在局部代码块中声明的每一个变量必须被至少一次用做r-value（right-hand-side value，右值）。</p><p>因此，下列代码将编译失败，因为<code>y</code>只被用做目标值（目标值都为左值）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">1</span> <span class="comment">// y被声明了但没有被用做右值</span></span><br><span class="line">	<span class="keyword">if</span> x &#123;</span><br><span class="line">		y = <span class="number">2</span> <span class="comment">// 这里，y被用做左值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go运行时是否维护映射条目的遍历顺序？"><a href="#Go运行时是否维护映射条目的遍历顺序？" class="headerlink" title="Go运行时是否维护映射条目的遍历顺序？"></a>Go运行时是否维护映射条目的遍历顺序？</h3><p>不。<a href="https://golang.google.cn/ref/spec#For_range" target="_blank" rel="noopener">Go白皮书</a>明确提到映射元素的迭代顺序时未定义的。 所以对于同一个映射值，它的一个遍历过程和下一个遍历过程中的元素呈现次序不保证是相同的。 对于标准编译器，映射元素的遍历顺序是随机的。 如果你需要固定的映射元素遍历顺序，那么你就需要自己来维护这个顺序。 更多信息请阅读Go官方博客文章<a href="https://blog.golang.com/go-maps-in-action#TOC_7." target="_blank" rel="noopener">Go maps in action</a>。</p><p>但是请注意：从Go 1.12开始，标准库包中的各个打印函数的结果中，映射条目总是排了序的。</p><h3 id="Go编译器是否会进行字节填充以确保结构体字段的地址对齐？"><a href="#Go编译器是否会进行字节填充以确保结构体字段的地址对齐？" class="headerlink" title="Go编译器是否会进行字节填充以确保结构体字段的地址对齐？"></a>Go编译器是否会进行字节填充以确保结构体字段的地址对齐？</h3><p>至少对于标准的Go编译器和gccgo，答案是肯定的。 具体需要填充多少个字节取决于操作系统和编译器实现。 请阅读<a href="https://gfw.go101.org/article/memory-layout.html#size-and-padding" target="_blank" rel="noopener">关于Go值的内存布局</a>一文获取详情。</p><p>Go编译器将不会重新排列结构体的字段来最小化结构体值的尺寸。 因为这样做会导致意想不到的结果。 但是，根据需要，程序员可以手工重新排序字段来实现填充最小化。</p><h3 id="为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？"><a href="#为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？" class="headerlink" title="为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？"></a>为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？</h3><p>一个可寻址的结构值的所有字段都可以被取地址。 如果非零尺寸的结构体值的最后一个字段的尺寸是零，那么取此最后一个字段的地址将会返回一个越出了为此结构体值分配的内存块的地址。 这个返回的地址可能指向另一个被分配的内存块。 在目前的官方Go标准运行时的实现中，如果一个内存块被至少一个依然活跃的指针引用，那么这个内存块将不会被视作垃圾因而肯定不会被回收。 所以只要有一个活跃的指针存储着此非零尺寸的结构体值的最后一个字段的越界地址，它将阻止垃圾收集器回收另一个内存块，从而可能导致内存泄漏。</p><p>为避免上述问题，标准的Go编译器会确保取一个非零尺寸的结构体值的最后一个字段的地址时，绝对不会返回越出分配给此结构体值的内存块的地址。 Go标准编译器通过在需要时在结构体最后的零尺寸字段之后填充一些字节来实现这一点。</p><p>如果一个结构体的全部字段的类型都是零尺寸的(因此整个结构体也是零尺寸的)，那么就不需要再填充字节，因为标准编译器会专门处理零尺寸的内存块。</p><p>一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">		a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">		x <span class="keyword">int64</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(unsafe.Sizeof(T1&#123;&#125;)) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">		x <span class="keyword">int64</span></span><br><span class="line">		a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(unsafe.Sizeof(T2&#123;&#125;)) <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-T-是var-t-T-amp-t-的语法糖吗？"><a href="#new-T-是var-t-T-amp-t-的语法糖吗？" class="headerlink" title="new(T)是var t T; (&amp;t)的语法糖吗？"></a><code>new(T)</code>是<code>var t T; (&amp;t)</code>的语法糖吗？</h3><p>虽然这两者在实现上会有一些微妙的差别，取决于编译器的具体实现，但是我们基本上可以认为这两者是等价的。 即，通过<code>new</code>函数分配的内存块可以在栈上，也可以在堆上。</p><h3 id="运行时错误信息all-goroutines-are-asleep-deadlock意味着什么"><a href="#运行时错误信息all-goroutines-are-asleep-deadlock意味着什么" class="headerlink" title="运行时错误信息all goroutines are asleep - deadlock意味着什么?"></a>运行时错误信息<code>all goroutines are asleep - deadlock</code>意味着什么?</h3><p>用词<strong><em>asleep\</em></strong>在这里其实并不准确，实际上它的意思是<strong><em>处于阻塞状态\</em></strong>。</p><p>因为一个处于阻塞状态的协程只能被另一个协程解除阻塞，如果程序中所有的协程都进入了阻塞状态，则它们将永远都处于阻塞状态。 这意味着程序死锁了。一个正常运行的程序永远不应该死锁，一个死锁的程序肯定是由于逻辑实现上的bug造成的。 因此官方Go标准运行时将在一个程序死锁时令其崩溃退出。</p><h3 id="64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？"><a href="#64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？" class="headerlink" title="64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？"></a>64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？</h3><p>传递给<code>sync/atomic</code>标准库包中的64位函数的地址必须是64位对齐的，否则调用这些函数将在运行时导致恐慌产生。</p><p>对于标准编译器和gccgo编译器，在64位架构下，64位整数的地址将保证总是64位对齐的。 所以它们总是可以被安全地原子访问。 但在32位架构下，64位整数的地址仅保证是32位对齐的。 所以原子访问某些64位整数可能会导致恐慌。 但是，有一些方法可以保证一些64位整数总是可以被安全地原子访问。 请阅读<a href="https://gfw.go101.org/article/memory-layout.html#64bit-atomic-operation" target="_blank" rel="noopener">关于Go值的内存布局</a>一文以获得详情。</p><h3 id="赋值是原子操作吗？"><a href="#赋值是原子操作吗？" class="headerlink" title="赋值是原子操作吗？"></a>赋值是原子操作吗？</h3><p>对于标准编译器来说，赋值不是原子操作。</p><p>请阅读<a href="https://golang.google.cn/doc/faq#What_operations_are_atomic_What_about_mutexes" target="_blank" rel="noopener">官方FAQ中的此问答</a>以了解更多。</p><h3 id="是否每一个零值在内存中占据的字节都是零？"><a href="#是否每一个零值在内存中占据的字节都是零？" class="headerlink" title="是否每一个零值在内存中占据的字节都是零？"></a>是否每一个零值在内存中占据的字节都是零？</h3><p>对于大部分类型，答案是肯定的。不过事实上，这依赖于编译器。 例如，对于标准编译器，对于某些字符串类型的零值，此结论并不十分正确。</p><p>比如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 <span class="keyword">string</span></span><br><span class="line">	fmt.Println(s1 == <span class="string">""</span>) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s1))) <span class="comment">// 0</span></span><br><span class="line">	<span class="keyword">var</span> s2 = <span class="string">"abc"</span>[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">	fmt.Println(s2 == <span class="string">""</span>) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s2))) <span class="comment">// 4869856</span></span><br><span class="line">	fmt.Println(s1 == s2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反过来，对于标准编译器已经支持的所有架构，如果一个值的所有字节都是零，那么这个值肯定是它的类型的零值。 然而，Go规范并没有保证这一点。我曾听说在某些比较老的处理器上，空指针表示的内存地址并不为零。</p><h3 id="标准的Go编译器是否支持函数内联？"><a href="#标准的Go编译器是否支持函数内联？" class="headerlink" title="标准的Go编译器是否支持函数内联？"></a>标准的Go编译器是否支持函数内联？</h3><p>是的，标准编译器支持函数内联。编译器会自动的内联短小的并且不调用其它函数的函数。 内联规则可能会在不同编译器版本之间发生变化。</p><p>目前（Go 1.15），对于标准编译器，</p><ul><li><p>没有显式的方式来在用户代码中指定哪些函数应该被内联。</p></li><li><p>尽管编译参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gcflags &quot;-l&quot;</span><br></pre></td></tr></table></figure><p>可以阻止任何函数被内联， 但是并没有正式的方式来避免某个特定的用户函数被内联。 目前有以下两种非正式的方法来避免一个函数被内联（这两种方式都有有可能在未来的Go标准编译器版本中失效）：</p><ol><li>你可以在函数声明前增加一行<code>//go:noinline</code> 指令来避免这个函数被内联。</li><li>由于包含循环块的函数不会内联，所以你可以再函数里增加一个空循环 <code>for false {}</code>来避免该函数被内联。 （但是这个方法<a href="https://github.com/golang/go/issues/14768" target="_blank" rel="noopener">从以后的某个Go官方工具链版本开始将不再有效</a>。）</li></ol></li></ul><h3 id="终结器（finalizer）可以用做对象的析构函数吗？"><a href="#终结器（finalizer）可以用做对象的析构函数吗？" class="headerlink" title="终结器（finalizer）可以用做对象的析构函数吗？"></a>终结器（finalizer）可以用做对象的析构函数吗？</h3><p>在Go程序里，我们可以通过调用<code>runtime.SetFinalizer</code>函数来给一个对象设置一个终结器函数。 一般说来，此终结器函数将在此对象被垃圾回收之前调用。 但是终结器并非被设计为对象的析构函数。 通过<code>runtime.SetFinalizer</code>函数设置的终结器函数并不保证总会被运行。 因此我们不应该依赖于终结器来保证程序的正确性。</p><p>终结器的主要用途是为了库包的维护者能够尽可能地避免因为库包使用者不正确地使用库包而带来的危害。 例如，我们知道，当在程序中使用完某个文件后，我们应该将其关闭。 但是有时候因为种种原因，比如经验不足或者粗心大意，导致一些文件在使用完成后并未被关闭，那么和这些文件相关的很多资源只有在此程序退出之后才能得到释放。这属于资源泄漏。 为了尽可能地避免防止资源泄露，<code>os</code>库包的维护者将会在一个<code>os.File</code>对象被被创建的时候为之设置一个终结器。 此终结器函数将关闭此<code>os.File</code>对象。当此<code>os.File</code>对象因为不再被使用而被垃圾回收的时候，此终结器函数将被调用。</p><p>请记住，有一些终结器函数永远不会被调用，并且有时候不当的设置终结器函数将会阻止对象被垃圾回收。 关于更多细节，请阅读<a href="https://golang.google.cn/pkg/runtime/#SetFinalizer" target="_blank" rel="noopener">runtime.SetFinalizer函数的文档</a>。</p><h3 id="如何使用尽可能短的代码行数来获取任意月份的天数？"><a href="#如何使用尽可能短的代码行数来获取任意月份的天数？" class="headerlink" title="如何使用尽可能短的代码行数来获取任意月份的天数？"></a>如何使用尽可能短的代码行数来获取任意月份的天数？</h3><p>假设输入的年份是一个自然年，并且输入的月份也是一个自然月（1代表1月）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">days := time.Date(year, month+<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC).Day()</span><br></pre></td></tr></table></figure><p>对于Go中的<code>time</code>标准库包，正常月份的去值范围为<code>[1, 12]</code>，并且每个月的起始日是<code>1</code>。 所以，<code>y</code>年的<code>m</code>月的起始时间就是<code>time.Date(y, m, 1, 0, 0, 0, 0, time.UTC)</code>。</p><p>传递给<code>time.Date</code>函数的实参可以超出它们的正常范围，此函数将这些实参进行规范化。 例如，1月32日会被转换成2月1日。</p><p>以下是一些Go语言里的日期使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 2017-02-01 00:00:00 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2017-01-31 23:59:59.999999999 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, time.UTC))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2017-01-31 00:00:00 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2016-12-31 00:00:00 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2016</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2017-02-01 00:00:00 +0000 UTC</span></span><br><span class="line">	fmt.Println(time.Date(<span class="number">2016</span>, <span class="number">13</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用time-Sleep-d-和通道接收-lt-time-After-d-操作之间有何区别？"><a href="#函数调用time-Sleep-d-和通道接收-lt-time-After-d-操作之间有何区别？" class="headerlink" title="函数调用time.Sleep(d)和通道接收&lt;-time.After(d)操作之间有何区别？"></a>函数调用<code>time.Sleep(d)</code>和通道接收<code>&lt;-time.After(d)</code>操作之间有何区别？</h3><p>两者都会将当前的goroutine执行暂停一段时间。 区别在于<code>time.Sleep(d)</code>函数调用将使当前的协程进入睡眠字状态，但是当前协程的<a href="https://gfw.go101.org/article/control-flows-more.html#states-of-goroutine" target="_blank" rel="noopener">（主）状态</a>依然为运行状态； 而通道接收<code>&lt;-time.After(d)</code>操作将使当前协程进入阻塞状态。</p><h3 id="调用strings和bytes标准库包里TrimLeft和TrimRight函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？"><a href="#调用strings和bytes标准库包里TrimLeft和TrimRight函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？" class="headerlink" title="调用strings和bytes标准库包里TrimLeft和TrimRight函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？"></a>调用<code>strings</code>和<code>bytes</code>标准库包里<code>TrimLeft</code>和<code>TrimRight</code>函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？</h3><p>哈，我们不能保证这些函数的实现绝对没有bug，但是如果这些函数返回的结果是不符你的预期，更有可能的是你的期望是不正确的。</p><p>标准包<code>strings</code>和<code>bytes</code>里有多个修剪（trim）函数。 这些函数可以被分类为两组：</p><ol><li><code>Trim</code>、<code>TrimLeft</code>、<code>TrimRight</code>、<code>TrimSpace</code>、<code>TrimFunc</code>、<code>TrimLeftFunc</code>和<code>TrimRightFunc</code>。 这些函数将修剪首尾所有满足指定（或隐含）条件的utf-8编码的Unicode码点(即rune)。（<code>TrimSpace</code>隐含了修剪各种空格符。） 这些函数将检查每个开头或结尾的rune值，直到遇到一个不满足条件的rune值为止。</li><li><code>TrimPrefix</code>和<code>TrimSuffix</code>。 这两个函数会把指定前缀或后缀的子字符串（或子切片）作为一个整体进行修剪。</li></ol><p><a href="https://github.com/golang/go/issues/19172" target="_blank" rel="noopener">部分</a><a href="https://github.com/golang/go/issues/18160" target="_blank" rel="noopener">程序员</a><a href="https://github.com/golang/go/issues/14657" target="_blank" rel="noopener">会</a>把<code>TrimLeft</code>和<code>TrimRight</code>函数当作<code>TrimPrefix</code>和<code>TrimSuffix</code>函数而<a href="https://github.com/golang/go/issues/19371" target="_blank" rel="noopener">误用</a>。 自然地，函数返回的结果很可能不是预期的那样。</p><p>例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s = <span class="string">"abaay森z众xbbab"</span></span><br><span class="line">	o := fmt.Println</span><br><span class="line">	o(strings.TrimPrefix(s, <span class="string">"ab"</span>)) <span class="comment">// aay森z众xbbab</span></span><br><span class="line">	o(strings.TrimSuffix(s, <span class="string">"ab"</span>)) <span class="comment">// abaay森z众xbb</span></span><br><span class="line">	o(strings.TrimLeft(s, <span class="string">"ab"</span>))   <span class="comment">// y森z众xbbab</span></span><br><span class="line">	o(strings.TrimRight(s, <span class="string">"ab"</span>))  <span class="comment">// abaay森z众x</span></span><br><span class="line">	o(strings.Trim(s, <span class="string">"ab"</span>))       <span class="comment">// y森z众x</span></span><br><span class="line">	o(strings.TrimFunc(s, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r &lt; <span class="number">128</span> <span class="comment">// trim all ascii chars</span></span><br><span class="line">	&#125;)) <span class="comment">// 森z众</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数fmt-Print和fmt-Println-的区别是什么？"><a href="#函数fmt-Print和fmt-Println-的区别是什么？" class="headerlink" title="函数fmt.Print和fmt.Println 的区别是什么？"></a>函数<code>fmt.Print</code>和<code>fmt.Println</code> 的区别是什么？</h3><p><code>fmt.Println</code>函数总会在两个相邻的参数之间输出一个空格，然而<code>fmt.Print</code>函数仅当两个相邻的参数（的具体值）都不是字符串类型时才会在它们之间输出一个空格。</p><p>另外一个区别是<code>fmt.Println</code>函数会在结尾写入一个换行符，但是<code>fmt.Print</code>函数不会。</p><h3 id="函数log-Print-和函数-log-Println-有什么区别吗"><a href="#函数log-Print-和函数-log-Println-有什么区别吗" class="headerlink" title="函数log.Print 和函数 log.Println 有什么区别吗?"></a>函数<code>log.Print</code> 和函数 <code>log.Println</code> 有什么区别吗?</h3><p>函数<code>log.Print</code>与<code>log.Println</code>的区别与上一个问题里描述的关于函数<code>fmt.Print</code>和<code>fmt.Println</code>的第一个区别点类似。</p><p>这两个函数都会在结尾输出一个换行符。</p><h3 id="函数fmt-Print、fmt-Println和fmt-Printf的实现进行同步了吗？"><a href="#函数fmt-Print、fmt-Println和fmt-Printf的实现进行同步了吗？" class="headerlink" title="函数fmt.Print、fmt.Println和fmt.Printf的实现进行同步了吗？"></a>函数<code>fmt.Print</code>、<code>fmt.Println</code>和<code>fmt.Printf</code>的实现进行同步了吗？</h3><p>没有。 如果有同步的需求，请使用<code>log</code>标准库包里的相应函数。 你可以调用<code>log.SetFlags(0)</code>来避免每一个日志行的前缀输出。</p><h3 id="内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？"><a href="#内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？" class="headerlink" title="内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？"></a>内置的<code>print</code>和<code>println</code>函数与<code>fmt</code>和<code>log</code>标准库包中相应的打印函数有什么区别？</h3><p>除了上一个问题里提到的区别之外，这三组函数之间还有一些其他区别。</p><ol><li>内置的<code>print</code>/<code>println</code>函数总是写入标准错误。 <code>fmt</code>标准包里的打印函数总是写入标准输出。<code>log</code>标准包里的打印函数会默认写入标准错误，然而也可以通过<code>log.SetOutput</code>函数来配置。</li><li>内置<code>print</code>/<code>println</code>函数的调用不能接受数组和结构体参数。</li><li>对于组合类型的参数，内置的<code>print</code>/<code>println</code>函数将输出参数的底层值部的地址，而<code>fmt</code>和<code>log</code>标准库包中的打印函数将输出接口参数的动态值的字面形式。</li><li>目前（Go 1.15），对于标准编译器，调用内置的<code>print</code>/<code>println</code>函数不会使调用参数引用的值逃逸到堆上，而<code>fmt</code>和<code>log</code>标准库包中的打印函数将使调用参数引用的值逃逸到堆上。</li><li>如果一个实参有<code>String() string</code>或<code>Error() string</code>方法，那么<code>fmt</code>和<code>log</code>标准库包里的打印函数在打印参数时会调用这两个方法，而内置的<code>print</code>/<code>println</code>函数则会忽略参数的这些方法。</li><li>内置的<code>print</code>/<code>println</code>函数不保证在未来的Go版本中继续存在。</li></ol><h3 id="标准库包math-rand和crypto-rand生成的随机数之间有什么区别？"><a href="#标准库包math-rand和crypto-rand生成的随机数之间有什么区别？" class="headerlink" title="标准库包math/rand和crypto/rand生成的随机数之间有什么区别？"></a>标准库包<code>math/rand</code>和<code>crypto/rand</code>生成的随机数之间有什么区别？</h3><p>通过<code>math/rand</code>标准库包生成的伪随机数序列对于给定的种子是确定的。 这样生成的随机数不适用于安全敏感的环境中。 如果处于加密安全目的，我们应该使用<code>crypto/rand</code>标准库包生成的伪随机数序列。</p><h3 id="标准库中为什么没有math-Round函数"><a href="#标准库中为什么没有math-Round函数" class="headerlink" title="标准库中为什么没有math.Round函数?"></a>标准库中为什么没有<code>math.Round</code>函数?</h3><p><code>math.Round</code>函数是有的，但是只是从Go 1.10开始才有这个函数。 从Go 1.10开始，标准库添加了两个新函数<code>math.Round</code>和<code>math.RoundToEven</code>。</p><p>在Go 1.10之前，关于 <code>math.Round</code>函数是否应该被添加进标准包，经历了<a href="https://github.com/golang/go/issues/4594" target="_blank" rel="noopener">很长时候的讨论</a>。</p><h3 id="哪些类型不支持比较？"><a href="#哪些类型不支持比较？" class="headerlink" title="哪些类型不支持比较？"></a>哪些类型不支持比较？</h3><p>下列类型不支持比较：</p><ul><li>映射（map）</li><li>切片</li><li>函数</li><li>包含不可比较字段的结构体类型</li><li>元素类型为不可比较类型的数组类型</li></ul><p>不支持比较的类型不能用做映射类型的键值类型。</p><p>请注意：</p><ul><li>尽管映射，切片和函数值不支持比较，但是它们的值可以与类型不确定的<code>nil</code>标识符比较。</li><li>如果两个接口值的动态类型相同且不可比较，那么在运行时<a href="https://gfw.go101.org/article/interface.html#comparison" target="_blank" rel="noopener">比较这两个接口的值</a>会产生一个恐慌。</li></ul><p>关于为什么映射，切片和函数不支持比较，请阅读Go的官方FAQ中<a href="https://golang.google.cn/doc/faq#map_keys" target="_blank" rel="noopener">关于这个问答</a>。</p><h3 id="为什么两个nil值有时候会不相等？"><a href="#为什么两个nil值有时候会不相等？" class="headerlink" title="为什么两个nil值有时候会不相等？"></a>为什么两个<code>nil</code>值有时候会不相等？</h3><p><em>（Go官方FAQ中的<a href="https://golang.google.cn/doc/faq#nil_error" target="_blank" rel="noopener">这个答案</a>也回答了这个问题。）</em></p><p>一个接口值可以看作是一个包裹非接口值的盒子。被包裹在一个接口值中的非接口值的类型必须实现了此接口值的类型。 在Go中，很多种类型的类型的零值都是用<code>nil</code>来表示的。 一个什么都没包裹的接口值为一个零值接口值，即nil接口值。 一个包裹着其它非接口类型的nil值的接口值并非什么都没包裹，所以它不是（或者说它不等于）一个nil接口值。</p><p>当对一个nil接口值和一个nil非接口值进行比较时（假设它们可以比较），此nil非接口值将先被转换为nil接口值的类型，然后再进行比较； 此转换的结果为一个包裹了此nil非接口值的一个副本的接口值，此接口值不是（或者说它不等于）一个nil接口值，所以此比较不相等。</p><p>关于更详细的解释请阅读<a href="https://gfw.go101.org/article/interface.html" target="_blank" rel="noopener">接口</a>和<a href="https://gfw.go101.org/article/nil.html" target="_blank" rel="noopener">关于Go中的<code>nil</code></a>两篇文章。</p><p>一个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pi *<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> pb *<span class="keyword">bool</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = pi</span><br><span class="line">	<span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125; = pb</span><br><span class="line">	<span class="keyword">var</span> z <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(x == y)   <span class="comment">// false</span></span><br><span class="line">	fmt.Println(x == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">	fmt.Println(y == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">	fmt.Println(x == z)   <span class="comment">// false</span></span><br><span class="line">	fmt.Println(y == z)   <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么类型-T1和-T2没有共享相同底层类型，即使不同的类型T1和T2共享相同的底层类型？"><a href="#为什么类型-T1和-T2没有共享相同底层类型，即使不同的类型T1和T2共享相同的底层类型？" class="headerlink" title="为什么类型[]T1和[]T2没有共享相同底层类型，即使不同的类型T1和T2共享相同的底层类型？"></a>为什么类型<code>[]T1</code>和<code>[]T2</code>没有共享相同底层类型，即使不同的类型<code>T1</code>和<code>T2</code>共享相同的底层类型？</h3><p><em>（不久前，Go官方FAQ也增加了<a href="https://golang.google.cn/doc/faq#convert_slice_with_same_underlying_type" target="_blank" rel="noopener">一个相似的问题</a>。）</em></p><p>在Go语言中，仅当两个切片类型共享相同的<a href="https://gfw.go101.org/article/type-system-overview.html#underlying-type" target="_blank" rel="noopener">底层类型</a>时，其中一个切片类型才可以转换成另一个切片的类型而不需要使用<a href="https://gfw.go101.org/article/unsafe.html" target="_blank" rel="noopener"><code>unsafe</code>机制</a>。</p><p>一个非定义组合类型的底层类型是此组合类型本身。 所以即便两个不同的类型<code>T1</code>和<code>T2</code>共享相同的底层类型，类型<code>[]T1</code>和<code>[]T2</code>也依然是不同的类型，因此它们的底层类型也是不同的。这意味着其中一个的值不能转换为另一个。</p><p>底层类型<code>[]T1</code>和<code>[]T2</code>不同的原因是：</p><ul><li>把<code>[]T1</code>和<code>[]T2</code>的值相互转换的需求在实践中并不常见。</li><li>使得<a href="https://gfw.go101.org/article/type-system-overview.html#underlying-type" target="_blank" rel="noopener">底层类型的溯源规则</a>更加简单。</li></ul><p>同样的原因也适用于其它组合类型。 例如：类型<code>map[T]T1</code> 和 <code>map[T]T2</code>同样不共享相同的底层类型，即便<code>T1</code> 和 <code>T2</code>共享相同的底层类型。</p><p>类型<code>[]T1</code>的值时候有可能通过使用<code>unsafe</code>机制转换成<code>[]T2</code>的，但是一般不建议这么做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b = *(*[]MyInt)(unsafe.Pointer(&amp;a))</span><br><span class="line">	b[<span class="number">0</span>]= <span class="number">123</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// [123 8 9]</span></span><br><span class="line">	fmt.Println(b) <span class="comment">// [123 8 9]</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T \n"</span>, a) <span class="comment">// []int</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T \n"</span>, b) <span class="comment">// []main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哪些值可以被取地址，哪些值不可以被取地址？"><a href="#哪些值可以被取地址，哪些值不可以被取地址？" class="headerlink" title="哪些值可以被取地址，哪些值不可以被取地址？"></a>哪些值可以被取地址，哪些值不可以被取地址？</h3><p>以下的值是不可以寻址的：</p><ul><li>字符串的字节元素</li><li>映射元素</li><li>接口值的动态值（类型断言的结果）</li><li>常量（包括有名常量和字面量）</li><li>声明的包级别函数</li><li>方法（用做函数值）</li><li>中间结果值<ul><li>函数调用</li><li>显式值转换</li><li>各种操作，不包含指针解引用（dereference）操作，但是包含：<ul><li>通道接收操作</li><li>子字符串操作</li><li>子切片操作</li><li>加法、减法、乘法、以及除法等等。</li></ul></li></ul></li></ul><p>请注意：<code>&amp;T{}</code>在Go里是一个语法糖，它是<code>tmp := T{}; (&amp;tmp)</code>的简写形式。 所以<code>&amp;T{}</code>是合法的并不代表字面量<code>T{}</code>是可寻址的。</p><p>以下的值是可寻址的，因此可以被取地址：</p><ul><li>变量</li><li>可寻址的结构体的字段</li><li>可寻址的数组的元素</li><li>任意切片的元素（无论是可寻址切片或不可寻址切片）</li><li>指针解引用（dereference）操作</li></ul><h3 id="为什么映射元素不可被取地址？"><a href="#为什么映射元素不可被取地址？" class="headerlink" title="为什么映射元素不可被取地址？"></a>为什么映射元素不可被取地址？</h3><p>在Go中，映射的设计保证一个映射值在内存允许的情况下可以加入任意个条目。 另外为了防止一个映射中为其条目开辟的内存段支离破碎，官方标准编译器使用了哈希表来实现映射。 并且为了保证元素索引的效率，一个映射值的底层哈希表只为其中的所有条目维护一段连续的内存段。 因此，一个映射值随着其中的条目数量逐渐增加时，其维护的连续的内存段需要不断重新开辟来增容，并把原来内存段上的条目全部复制到新开辟的内存段上。 另外，即使一个映射值维护的内存段没有增容，某些哈希表实现也可能在当前内存段中移动其中的条目。 总之，映射中的元素的地址会因为各种原因而改变。 如果映射元素可以被取地址，则Go运行时（runtime）必须在元素地址改变的时候修改所有存储了元素地址的指针值。 这极大得增加了Go编译器和运行时的实现难度，并且严重影响了程序运行效率。 因此，目前，Go中禁止取映射元素的地址。</p><p>映射元素不可被取地址的另一个原因是表达式<code>aMap[key]</code>可能返回一个存储于<code>aMap</code>中的元素，也可能返回一个不存储于其中的元素零值。 这意味着表达式<code>aMap[key]</code>在<code>(&amp;aMap[key]).Modify()</code>调用执行之后可能仍然被估值为元素零值。 这将使很多人感到困惑，因此在Go中禁止取映射元素的地址。</p><h3 id="为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？"><a href="#为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？" class="headerlink" title="为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？"></a>为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？</h3><p>切片的内部类型是一个结构体，类似于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	elements unsafe.Pointer <span class="comment">// 引用着一个元素序列</span></span><br><span class="line">	length   <span class="keyword">int</span></span><br><span class="line">	capacity <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个切片间接引用一个元素序列。 尽管一个非空切片是不可取地址的，它的内部元素序列需要开辟在内存中的某处因而必须是可取地址的。 取一个切片的元素地址事实上是取内部元素序列上的元素地址。 因此，不可寻址的非空切片的元素也是可以被取地址的。</p><h3 id="对任意的非指针和非接口定义类型T，为什么类型-T的方法集总是类型T的方法集的超集，但是反之却不然？"><a href="#对任意的非指针和非接口定义类型T，为什么类型-T的方法集总是类型T的方法集的超集，但是反之却不然？" class="headerlink" title="对任意的非指针和非接口定义类型T，为什么类型*T的方法集总是类型T的方法集的超集，但是反之却不然？"></a>对任意的非指针和非接口定义类型<code>T</code>，为什么类型<code>*T</code>的方法集总是类型<code>T</code>的方法集的超集，但是反之却不然？</h3><p>在Go语言中，为了方便，对于一个非指针和非接口定义类型<code>T</code>，</p><ul><li>一个<code>T</code>类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此<code>T</code>的值是可寻址的情况下。 编译器在调用指针属主方法前，会自动取此<code>T</code>值的地址。 因为不是任何<code>T</code>值都是可寻址的，所以并非任何<code>T</code>值都能够调用为类型<code>*T</code>声明的方法。 这种便利只是一个语法糖，而不是一种固有的规则。</li><li>一个<code>*T</code>类型的值可以调用为类型<code>T</code>声明的方法。 这是因为解引用指针总是合法的。 这种便利不仅仅是一个语法糖，它也是一种固有的规则。</li></ul><p>所以很合理的， <code>*T</code>的方法集总是<code>T</code>方法集的超集，但反之不然。</p><p>事实上，你可以认为对于每一个为类型<code>T</code>声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。 详见<a href="https://gfw.go101.org/article/method.html#implicit-pointer-methods" target="_blank" rel="noopener">方法</a>一文。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">MethodX</span><span class="params">(v0 ParamType0, ...)</span> <span class="params">(ResultType0, ...)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器将会为*T隐式声明一个如下的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pt *T)</span> <span class="title">MethodX</span><span class="params">(v0 ParamType0, ...)</span> <span class="params">(ResultType0, ...)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (*pt).MethodX(v0, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多解释请阅读Go官方FAQ中的<a href="https://golang.google.cn/doc/faq#different_method_sets" target="_blank" rel="noopener">这个问答</a>。</p><h3 id="我们可以为哪些类型声明方法？"><a href="#我们可以为哪些类型声明方法？" class="headerlink" title="我们可以为哪些类型声明方法？"></a>我们可以为哪些类型声明方法？</h3><p>请阅读<a href="https://gfw.go101.org/article/method.html" target="_blank" rel="noopener">方法</a>一文获取答案。</p><h3 id="在Go里如何声明不可变量？"><a href="#在Go里如何声明不可变量？" class="headerlink" title="在Go里如何声明不可变量？"></a>在Go里如何声明不可变量？</h3><p>如下是三种<strong><em>不可变值\</em></strong>的定义：</p><ol><li>没有地址的值（所以它们不可以寻址）。</li><li>有地址但是因为种种原因在语法上不可以寻址的值。</li><li>可寻址但不允许在语法上被修改的值。</li></ol><p>在Go语言中，直到现在（Go 1.15），没有值满足第三种定义。</p><p>有名常量值满足第一种定义。</p><p>方法和声明的函数可以被视为声明的不可变值。 它们满足第二种定义。字符串的字节元素同样满足第二种定义。</p><p>在Go中没有办法声明其它不可变值。</p><h3 id="为什么没有内置的set容器类型？"><a href="#为什么没有内置的set容器类型？" class="headerlink" title="为什么没有内置的set容器类型？"></a>为什么没有内置的<code>set</code>容器类型？</h3><p>集合（set）可以看作是不关心元素值的映射。 在Go语言里，<code>map[Tkey]struct{}</code>经常被用做一个集合类型。</p><h3 id="什么是byte？什么是rune？-如何将-byte和-rune类型的值转换为字符串？"><a href="#什么是byte？什么是rune？-如何将-byte和-rune类型的值转换为字符串？" class="headerlink" title="什么是byte？什么是rune？ 如何将[]byte和[]rune类型的值转换为字符串？"></a>什么是byte？什么是rune？ 如何将<code>[]byte</code>和<code>[]rune</code>类型的值转换为字符串？</h3><p>在Go语言里，<code>byte</code>是<code>uint8</code>类型的一个别名。 换言之，<code>byte</code> 和 <code>uint8</code>是相同的类型。 <code>rune</code>和<code>int32</code>属于同样类似的关系。</p><p>一个<code>rune</code>值通常被用来存储一个Unicode码点。</p><p><code>[]byte</code>和<code>[]rune</code>类型的值可以被显式地直接转换成字符串，反之亦然。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s0 = <span class="string">"Go"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> bs = []<span class="keyword">byte</span>(s0)</span><br><span class="line">	<span class="keyword">var</span> s1 = <span class="keyword">string</span>(bs)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> rs = []<span class="keyword">rune</span>(s0)</span><br><span class="line">	<span class="keyword">var</span> s2 = <span class="keyword">string</span>(rs)</span><br><span class="line"></span><br><span class="line">	fmt.Println(s0 == s1) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(s0 == s2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于字符串的信息，请阅读<a href="https://gfw.go101.org/article/string.html" target="_blank" rel="noopener">Go中的字符串</a>一文。</p><h3 id="如何原子地操作指针值？"><a href="#如何原子地操作指针值？" class="headerlink" title="如何原子地操作指针值？"></a>如何原子地操作指针值？</h3><p>例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">	<span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">int</span> <span class="comment">// just a demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(newP *T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加载（读取）</span></span><br><span class="line">	<span class="keyword">var</span> _ = (*T)(atomic.LoadPointer(</span><br><span class="line">		(*unsafe.Pointer)(unsafe.Pointer(&amp;p)),</span><br><span class="line">		))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储（修改）</span></span><br><span class="line">	atomic.StorePointer(</span><br><span class="line">		(*unsafe.Pointer)(unsafe.Pointer(&amp;p)),</span><br><span class="line">		unsafe.Pointer(newP),</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换</span></span><br><span class="line">	<span class="keyword">var</span> oldP = (*T)(atomic.SwapPointer(</span><br><span class="line">		(*unsafe.Pointer)(unsafe.Pointer(&amp;p)),</span><br><span class="line">		unsafe.Pointer(newP),</span><br><span class="line">		))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 比较并交换</span></span><br><span class="line">	<span class="keyword">var</span> swapped = atomic.CompareAndSwapPointer(</span><br><span class="line">		(*unsafe.Pointer)(unsafe.Pointer(&amp;p)),</span><br><span class="line">		unsafe.Pointer(oldP),</span><br><span class="line">		unsafe.Pointer(newP),</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">	_ = swapped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，目前指针的原子操作使用起来非常得繁琐。</p><h3 id="iota是什么意思？"><a href="#iota是什么意思？" class="headerlink" title="iota是什么意思？"></a><code>iota</code>是什么意思？</h3><p>Iota是希腊字母表中的第九个字母。 在Go语言中，<code>iota</code>用在常量声明中。 在每一个常量声明组中，其值在该常量声明组的第<strong><em>N\</em></strong>个常量规范中的值为<code>N</code>。</p><h3 id="为什么没有一个内置的closed函数用来检查通道是否已经关闭？"><a href="#为什么没有一个内置的closed函数用来检查通道是否已经关闭？" class="headerlink" title="为什么没有一个内置的closed函数用来检查通道是否已经关闭？"></a>为什么没有一个内置的<code>closed</code>函数用来检查通道是否已经关闭？</h3><p>原因是此函数的实用性非常有限。 此类函数调用的返回结果不能总是反映输入通道实参的最新状态。 所以依靠此函数的返回结果来做决定不是一个好主意。</p><p>如果你确实需要这种函数，你可以不怎么费功夫地自己写一个。 请阅读<a href="https://gfw.go101.org/article/channel-closing.html" target="_blank" rel="noopener">如何优雅地关闭通道</a>一文来了解如何编写一个<code>closed</code>函数以及如何避免使用这样的函数。</p><h3 id="函数返回局部变量的指针是否安全？"><a href="#函数返回局部变量的指针是否安全？" class="headerlink" title="函数返回局部变量的指针是否安全？"></a>函数返回局部变量的指针是否安全？</h3><p>是的，在Go中这是绝对安全的。</p><p>支持栈的Go编译器将会对每个局部变量进行逃逸分析。 如果编译器发现某个局部变量开辟在栈上不是绝对安全的，则此局部变量将被开辟在堆上。 请阅读<a href="https://gfw.go101.org/article/memory-block.html" target="_blank" rel="noopener">内存块</a>一文了解更多。</p><h3 id="单词gopher-在Go社区中表示什么？"><a href="#单词gopher-在Go社区中表示什么？" class="headerlink" title="单词gopher\在Go社区中表示什么？"></a>单词<strong><em>gopher\</em></strong>在Go社区中表示什么？</h3><p>在Go社区中，<strong><em>gopher\</em></strong>表示Go程序员。 这个昵称可能是源自于Go语言采用了<a href="https://blog.golang.com/gopher" target="_blank" rel="noopener">一个卡通小地鼠（gopher）</a>做为吉祥物。 顺便说一下，这个卡通小地鼠是由<em>Renee French</em>设计的。 <em>Renee French</em>是Go项目首任负责人<em>Rob Pike</em>的妻子。</p></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">轻北</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.qing-bei.com/2020/08/09/GO%E9%97%AE%E7%AD%94101/">http://www.qing-bei.com/2020/08/09/GO%E9%97%AE%E7%AD%94101/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GO/">GO</a></div><div class="post_share"><div class="social-share" data-image="https://wx1.sbimg.cn/2020/06/09/16pic_1748097_b.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://wx2.sbimg.cn/2020/06/09/IMG_20200609_094422.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://wx2.sbimg.cn/2020/06/09/IMG_20200609_094512.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/14/%E5%88%9D%E8%AF%86python%E8%A3%85%E9%A5%B0%E5%99%A8/"><img class="next_cover" src="https://wx1.sbimg.cn/2020/06/09/16pic_1748097_b.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">初识python装饰器</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting=function(e,a){var e=e,d=a.split(",").filter(function(a){return e.indexOf(a)>-1});return d=0==d.length?e:d},guestInfo=requestSetting(["nick","mail","link"],"nick,mail,link"),requiredFields=requestSetting(["nick","mail","link"],"nick,mail");window.valine=new Valine({el:"#vcomment",appId:"SOztNhjDgvdFwsXY09QPjNwU-gzGzoHsz",appKey:"RhybWYtt4u2WNJhzFkrVgoJ2",notify:!1,verify:!1,placeholder:"Please leave your footprints",avatar:"monsterid",meta:guestInfo,pageSize:"10",lang:"en",recordIP:!0,serverURLs:"",emojiCDN:"//i0.hdslb.com/bfs/emote/",emojiMaps:{tv_doge:"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},enableQQ:!0,requiredFields:requiredFields})</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 轻北</div><div class="icp"><a href="http://www.beian.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="https://wx2.sbimg.cn/2020/06/08/74537af458689411e284d6441c415a44.png"><span>湘公网安备4301240200591号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="159195086280" m="1"></script></body></html><!-- rebuild by neat -->